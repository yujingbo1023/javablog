---
title: 24-Dva
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 一，Dva介绍

### 1，Dva介绍

官网：https://dvajs.com/

![1712194112642](./assets/1712194112642.png)‘

​	dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架!



**特点：**

- 易学易用，仅有 6 个 api，对 redux 用户尤其友好，配合 umi 使用后更是降低为 0 API
- elm 概念，通过 reducers, effects 和 subscriptions 组织 model
- 插件机制，比如 dva-loading 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading
- 支持 HMR，基于 babel-plugin-dva-hmr 实现 components、routes 和 models 的 HMR

![1712194622232](./assets/1712194622232.png)



学习dva，主要学习三块内容：

- 一些配置
- dva中的路由
- 状态管理



### 2，Dva脚手架



参考文档：https://dvajs.com/guide/getting-started.html#%E5%AE%89%E8%A3%85-dva-cli



通过 npm 安装 dva-cli 并确保版本是 `0.9.1` 或以上。

![1712194793324](./assets/1712194793324.png)



通过 `dva new` 创建新应用（以管理员身份运行cmd）

![1712195679541](./assets/1712195679541.png)



`cd` 进入 `dva-quickstart` 目录，并启动开发服务器：

![1712197106143](./assets/1712197106143.png)

![1712197150705](./assets/1712197150705.png)

在浏览器里打开 http://localhost:8000 ，你会看到 dva 的欢迎界面。

![1712197168697](./assets/1712197168697.png)





创建好的目录结构如下：

![1712197680164](./assets/1712197680164.png)



对于models说明，先看vuex中的数据流：

![1712197921696](./assets/1712197921696.png)



vuex：

![1712198048685](./assets/1712198048685.png)



看package.json文件，如下：

```json
{
  "private": true,
  "scripts": {
    "start": "roadhog server",
    "build": "roadhog build",
    "lint": "eslint --ext .js src test",
    "precommit": "npm run lint"
  },
  "dependencies": {
    "dva": "^2.4.1",
    "react": "^16.2.0",
    "react-dom": "^16.2.0"
  },
  "devDependencies": {
    "babel-plugin-dva-hmr": "^0.3.2",
    "eslint": "^4.14.0",
    "eslint-config-umi": "^0.1.1",
    "eslint-plugin-flowtype": "^2.34.1",
    "eslint-plugin-import": "^2.6.0",
    "eslint-plugin-jsx-a11y": "^5.1.1",
    "eslint-plugin-react": "^7.1.0",
    "husky": "^0.12.0",
    "redbox-react": "^1.4.3",
    "roadhog": "^2.5.0-beta.4"
  }
}
```



说明：

- 无需安装：redux及redux-saga、react-redux、react-router-dom等，dva把这些东西都集成好了，安装一个dva就相当于安装了这些全部东西！！

- react-router-dom使用的是v4版本

- redux使用的是 v3.7.2「我们之前使用的都是v4.0」

- 集成的配套插件版本有点低

  ![1712198361676](./assets/1712198361676.png)



## 二，Dva配置

配置参考：https://github.com/sorrycc/roadhog/blob/master/README_zh-cn.md



### 1，配置支持antd

安装依赖：

```
"antd": "4.24.7", //注意版本用v4「不是最新的v5」
"antd-icons": "^0.1.0-alpha.1",
"babel-plugin-import": "^1.13.5", //antd按需导入，默认是不支持按需导入的，需要手动按需导入
```

```
cnpm i antd@4.24.7 antd-icons@^0.1.0-alpha.1 babel-plugin-import@^1.13.5  
// 如果npm不行，可以使用cnpm 
```

![1712198655446](./assets/1712198655446.png)





把.webpackrc修改成.webpackrc.js，在此文件中配置antd按需导入：

![1712198789274](./assets/1712198789274.png)

```js
export default {
    /* 配置BABEL的插件 */
    "extraBabelPlugins": [
        // antd按需导入
        [
            "import",
            {
                "libraryName": "antd",
                "libraryDirectory": "es",
                "style": "css"
            }
        ],
    ],
}
```



测试：

![1712199305388](./assets/1712199305388.png)



配置使用中文：

![1712199483781](./assets/1712199483781.png)

```js
import React from 'react';
import { Router, Route, Switch } from 'dva/router';
import IndexPage from './routes/IndexPage';

// antd
import { ConfigProvider } from "antd"
import zhCN from "antd/es/locale/zh_CN"

function RouterConfig({ history }) {
  return (
    <ConfigProvider locale={zhCN}>
      <Router history={history}>
        <Switch>
          <Route path="/" exact component={IndexPage} />
        </Switch>
      </Router>
    </ConfigProvider>
  );
}

export default RouterConfig;
```



测试：

![1712199610060](./assets/1712199610060.png)



### 2，配置less

安装：

```
"less": "4.1.3",
"less-loader": "8.1.1",
```

```
cnpm i less@4.1.3 less-loader@8.1.1
```



只需要安装预编译语言的模块和对应的loader，就可以直接生效，不需要单独做配置。测试如下：

![1712199681700](./assets/1712199681700.png)

![1712199703747](./assets/1712199703747.png)



浏览器效果：

![1712199769647](./assets/1712199769647.png)





dva里的roadhog 默认会开启cssModules，配置文件：

```
"disableCSSModules":false
```

index.css文件：

```css
.head {
    margin: 0 15px;
}
```

组件：

```jsx
...
import styles from './index.css';
function Index(){
  return(
    <div className={style.head}>局部样式<div>
    <div className={style['head']}>局部样式<div>
  )
}
export default Index;
```

style.head会变成类似于index_xxx_head的形式，保证类名不重复（相当于把head类变成了index_xxx_head类，保证只在局部作用）。



可以手动关闭roadhog的cssModules或者在css样式文件里面添加 :global() 来转成全局样式。如下：

![1712200048265](./assets/1712200048265.png)



浏览器测试：

![1712200068231](./assets/1712200068231.png)

禁用 CSS 的 SourceMap 生成。配置如下：

![1712200184257](./assets/1712200184257.png)

```js
export default {
    "disableCSSModules": true, // 关闭css模块化
    "disableCSSSourceMap":true, // 禁用 CSS 的 SourceMap 生成。
    /* 配置BABEL的插件 */
    "extraBabelPlugins": [
        // antd按需导入
        [
            "import",
            {
                "libraryName": "antd",
                "libraryDirectory": "es",
                "style": "css"
            }
        ],
    ],
}
```





### 3，配置代理



配置如下：

![1712200276200](./assets/1712200276200.png)

```js
export default {
    "disableCSSModules": true, // 关闭css模块化
    "disableCSSSourceMap": true, // 禁用 CSS 的 SourceMap 生成。
    /* 配置BABEL的插件 */
    "extraBabelPlugins": [
        // antd按需导入
        [
            "import",
            {
                "libraryName": "antd",
                "libraryDirectory": "es",
                "style": "css"
            }
        ],
    ],
    /* 配置跨域代理 */
    "proxy": {
        "/api": {
            "target": "https://news-at.zhihu.com/api/4",
            "changeOrigin": true,
            "ws": true,
            "pathRewrite": {
                "/api": ""
            }
        }
    },
}
```



测试：

![1712200370545](./assets/1712200370545.png)

```js
fetch("/api/news/latest").then(response=>response.json()).then(value=>{
    console.log(value)
})
```



### 4，配置移动端

安装插件：

```
"lib-flexible": "^0.3.2",
"postcss-pxtorem": "5.1.1",
"babel-plugin-styled-components-px2rem":"^1.5.5", 
"styled-components":"^5.3.6"
```

```
cnpm i lib-flexible@^0.3.2 postcss-pxtorem@5.1.1 babel-plugin-styled-components-px2rem@^1.5.5 styled-components@^5.3.6
```



配置：

![1712384968225](./assets/1712384968225.png)

![1712385006034](./assets/1712385006034.png)

```js
import px2rem from 'postcss-pxtorem';
export default {
    "disableCSSModules": true, // 关闭css模块化
    "disableCSSSourceMap": true, // 禁用 CSS 的 SourceMap 生成。
    /* 配置PX转REM */
    "extraPostCSSPlugins": [
        px2rem({
            "rootValue": 75,
            "propList": ['*']
        })
    ],
    /* 配置BABEL的插件 */
    "extraBabelPlugins": [
        // antd按需导入
        [
            "import",
            {
                "libraryName": "antd",
                "libraryDirectory": "es",
                "style": "css"
            }
        ],
        // 配置PX转REM
        [
            "styled-components-px2rem",
            {
                "rootValue": 75
            }
        ]
    ],
    /* 配置跨域代理 */
    "proxy": {
        "/api": {
            "target": "https://news-at.zhihu.com/api/4",
            "changeOrigin": true,
            "ws": true,
            "pathRewrite": {
                "/api": ""
            }
        }
    },
}
```





测试：

![1712385140616](./assets/1712385140616.png)

![1712385165377](./assets/1712385165377.png)



测试styled-components：

![1712459599222](./assets/1712459599222.png)



对于style-components，如下：

![1712385231858](./assets/1712385231858.png)



### 5，ES6和CSS3处理

默认情况下，roadhog脚手架中，已完成了对ES6常规语法和CSS3语法的兼容性处理。它处理时，依赖我们设置的浏览器兼容列表。但是有些语法如装饰器语法，还需要我们安装单独的babel插件来处理。

- ES6语法：babel-loader / babel-preset-react-app
- CSS3语法：postcss-loader / autoprefixer





配置浏览器兼容列表：

![1712385744674](./assets/1712385744674.png)

```js
import px2rem from 'postcss-pxtorem';
export default {
    "disableCSSModules": true, // 关闭css模块化
    "disableCSSSourceMap": true, // 禁用 CSS 的 SourceMap 生成。
    /* 配置PX转REM */
    "extraPostCSSPlugins": [
        px2rem({
            "rootValue": 75,
            "propList": ['*']
        })
    ],
    /* 配置BABEL的插件 */
    "extraBabelPlugins": [
        // antd按需导入
        [
            "import",
            {
                "libraryName": "antd",
                "libraryDirectory": "es",
                "style": "css"
            }
        ],
        // 配置PX转REM
        [
            "styled-components-px2rem",
            {
                "rootValue": 75
            }
        ]
    ],
    /* 配置跨域代理 */
    "proxy": {
        "/api": {
            "target": "https://news-at.zhihu.com/api/4",
            "changeOrigin": true,
            "ws": true,
            "pathRewrite": {
                "/api": ""
            }
        }
    },
    /* 不同环境下的不同配置 */
    "env": {
        "development": {
            "extraBabelPlugins": [
                "dva-hmr"
            ],
            "browserslist": [
                "last 1 chrome versions",
                "last 1 firefox versions",
                "last 1 safari versions"
            ]
        },
        "production": {
            "browserslist": [
                "> 0.2%",
                "not dead",
                "not ie <= 8"
            ]
        }
    }
}
```



有些ES6+中的语法，没有对应的老语法，需要polyfill，安装之：

```
cnpm i @babel/polyfill@^7.12.1
```



配置：

![1712385853929](./assets/1712385853929.png)



### 6，配置index.ejs

原本的index页面如下：

![1712385972319](./assets/1712385972319.png)



可以配置自动引入，把后缀.html变成后缀.ejs，如下：

![1712386036774](./assets/1712386036774.png)



配置：

![1712386160226](./assets/1712386160226.png)



效果：

![1712386148842](./assets/1712386148842.png)



### 7，配置打包生成hash

打包如下：

![1712386252278](./assets/1712386252278.png)



打包成功后如下：

![1712386308832](./assets/1712386308832.png)



配置添加hash，如下：

![1712386341862](./assets/1712386341862.png)



再次打包：

![1712386361262](./assets/1712386361262.png)



测试：

![1712386391058](./assets/1712386391058.png)



### 8，基于cross-env设置环境变量



安装cross-env模块：

```
cnpm i cross-env@^7.0.3
```



配置：

![1712386524329](./assets/1712386524329.png)



测试：

![1712386576000](./assets/1712386576000.png)

![1712386585662](./assets/1712386585662.png)

## 三，Dva中的路由



### 1，Dva中的路由介绍

看项目的入口：

![1712444396483](./assets/1712444396483.png)



路由文件：

![1712444452105](./assets/1712444452105.png)



默认的路由模式是hash路由，如下：

![1712444609549](./assets/1712444609549.png)



如果要使用history路由，先安装模块：

```
cnpm i history@^4.10.1
```



使用时，参考文档：

![1712444765404](./assets/1712444765404.png)



配置之：

![1712444932564](./assets/1712444932564.png)

```js
import dva from 'dva';
import './index.css';
import '@babel/polyfill'
import createHistory from "history/createBrowserHistory"

// 1. Initialize
const app = dva({
    // 指定路由模式，默认是hash路由
    // createBrowserHistory / createHashHistory
    history:createHistory()
});

// 2. Plugins
// app.use({});

// 3. Model
// app.model(require('./models/example').default);

// 4. Router   处理路由
app.router(require('./router').default);

// 5. Start   在start之前，需要先处理路由
app.start('#root');
```



hash路由使用的最多，history路由有一些问题，还需要后端处理一下。



通过 extraEnhancers 可以扩展其它中间件，如：redux-persist

![1712445011970](./assets/1712445011970.png)



在dva/router中包含了两大块内容：

- react-router-dom 提供了所有的路由相关的API，当然是V5版本。
- react-router-redux [routerRedux]中的方法，就是把路由和redux结合在一起的一个模块，可以让我们在redux操作中，实现路由的跳转与传参。



在配置一级路由和二路由之前，先创建如下组件：

![1712445607036](./assets/1712445607036.png)

```jsx
function Vote(props){
    return (<div>
        <div>
            <h2>React比Vue值钱？<span> {3} </span></h2>
        </div>
        <div>
            <p>支持：{1} 人</p>
            <p>反对：{2} 人</p>
        </div>
        <div>
            <button onClick={()=>{}}>支持</button>
            <button onClick={()=>{}}>反对</button>
        </div>
    </div>)
}

export default Vote;
```

```jsx
function Count(props){
    return(<div>
        <span>0</span>
        <button>+1</button>
    </div>)
}

export default Count;
```

```jsx
function User(props){
    return(<div>
        <h1>我的模块</h1>
    </div>)
}

export default User;
```

```jsx
function Order(props){
    return(<div>
        <h1>订单</h1>
    </div>)
}

export default Order;
```

```jsx
function Profile(props){
    return(<div>
        <h1>个人信息</h1>
    </div>)
}

export default Profile;
```





### 2，配置一级路由和二级路由



配置一级路由如下：

![1712446983783](./assets/1712446983783.png)

```js
import React from 'react';
import { Router, Route, Switch } from 'dva/router';
import Vote from "./routes/Vote"
import Count from "./routes/Count"
import User from "./routes/User"

// antd
import { ConfigProvider } from "antd"
import zhCN from "antd/es/locale/zh_CN"
import "./index.less"
import "lib-flexible"

function RouterConfig({ history,app }) {
  // history对象是包含路由跳转方法的history对象
  // app 是基于dva创建的应用
  return (
    <ConfigProvider locale={zhCN}>
      {/* history={history} 必须要写 */}
      <Router history={history}>
        {/* 路由配置：之前我们讲的是V6版本，下面的写法是V5版本 */}
        <Switch>
          <Route path="/" exact component={Vote} />
          <Route path="/count" component={Count} />
          <Route path="/user" component={User} />
        </Switch>
      </Router>
    </ConfigProvider>
  );
}

export default RouterConfig;
```



测试：

![1712447018171](./assets/1712447018171.png)



配置二级路由：

![1712447282815](./assets/1712447282815.png)

```jsx
import React from "react";
import styled from "styled-components";
import {NavLink,Switch,Route,Redirect} from "dva/router"
import Order from "./user/Order"
import Profile from "./user/Profile"

const UserBox = styled.div`
    display:flex;
    .box{
        width:100px;
        a{
            display:block;
            color:#000;
            line-height:35px;
            font-size:14px;
            &.active{
                color:red;
            }
        }
    }
`;

function User(props){
    return(<UserBox>
        <div className="box">
            <NavLink to="/user/order">我的订单</NavLink>
            <NavLink to="/user/profile">我的信息</NavLink>
        </div>
        <div className="content">
            <Switch>
                <Redirect from="/user" exact to="/user/order" />
                <Route path="/user/order" component={Order} />
                <Route path="/user/profile" component={Profile} />
            </Switch>
        </div>
    </UserBox>)
}


export default User;
```



测试如下：

![1712447303450](./assets/1712447303450.png)



### 3，路由懒加载



前面的在配置一级路由和二级路由时，组件是上一来就加载好了，如下：

![1712447692997](./assets/1712447692997.png)



在配置路由懒加载之前，先说一个东西，叫models。在dva中，一个模块，就一个models，我们可以创建vote对应的model和count对应的model，如下：

![1712447923334](./assets/1712447923334.png)

![1712447942893](./assets/1712447942893.png)



```js
// dva中三大核心：model数据模型（每个模块的状态管理） + 路由 + 配置
export default{
    namespace:"count", // 模块名
    state:{},  // 状态
    reducers:{}, // 同步修改状态的方法
    effects:{} // 基于saga的语法，存放异步修改状态的方法
}
```

```js
export default{
    namespace:"vote", // 模块名
    state:{},  // 状态
    reducers:{}, // 同步修改状态的方法
    effects:{} // 基于saga的语法，存放异步修改状态的方法
}
```



在我们懒加载一个组件时，我们也可以懒加载这个组件对应的models，配置如下：

```jsx
import React from 'react';
import { Router, Route, Switch } from 'dva/router';
import dynamic from "dva/dynamic"
import Vote from "./routes/Vote"
// import Count from "./routes/Count"
// import User from "./routes/User"

// antd
import { ConfigProvider } from "antd"
import zhCN from "antd/es/locale/zh_CN"
// import "./index.less"
// import "lib-flexible"

function RouterConfig({ history,app }) {
  // history对象是包含路由跳转方法的history对象
  // app 是基于dva创建的应用

  // 基于dva/dynamic实现路由的懒加载：组件的懒加载和对应Model的懒加载
  const LazyCount = dynamic({
    app,
    models:()=>[import('./models/count')],
    component:()=>import("./routes/Count")
  })
  const LazyUser = dynamic({
    app,
    component:()=>import("./routes/User")
  })

  return (
    <ConfigProvider locale={zhCN}>
      {/* history={history} 必须要写 */}
      <Router history={history}>
        {/* 路由配置：之前我们讲的是V6版本，下面的写法是V5版本 */}
        <Switch>
          <Route path="/" exact component={Vote} />
          <Route path="/count" component={LazyCount} />
          <Route path="/user"  component={LazyUser} />
        </Switch>
      </Router>
    </ConfigProvider>
  );
}

export default RouterConfig;
```



测试：

![1712448341968](./assets/1712448341968.png)

![1712448380914](./assets/1712448380914.png)







添加魔法注释：

```js
const LazyCount = dynamic({
    app,
    models:()=>[import(/* webpackChunkName:'count' */ './models/count')],
    component:()=>import(/* webpackChunkName:'count' */ "./routes/Count")
})
const LazyUser = dynamic({
    app,
    component:()=>import(/* webpackChunkName:'user' */ "./routes/User")
})
```



指定打包后文件名字以及相同名字的文件会打包在一起，再次测试：

![1712448481879](./assets/1712448481879.png)

![1712448564560](./assets/1712448564560.png)





配置二级路由模块，也实现懒加载：

![1712448723391](./assets/1712448723391.png)

![1712448811649](./assets/1712448811649.png)

```js
const LazyOrder = dynamic({
    app: window.app,
    models: () => [],
    component: () => import(/* webpackChunkName:'user' */ "./user/Order")
})

const LazyProfile = dynamic({
    app: window.app,
    models: () => [],
    component: () => import(/* webpackChunkName:'user' */ "./user/Profile")
})
```

![1712448851088](./assets/1712448851088.png)



配置404组件：

![1712449266766](./assets/1712449266766.png)



### 4，配置路由表动态生成路由

在进行权限设计时，往往后端会给我们生成路由表，我们需要根据路由表，动态生成路由规则。现在我们先定义出这个路由表，如下：

![1712450047278](./assets/1712450047278.png)

```jsx
import dynamic from "dva/dynamic"
import Vote from "./routes/Vote"

// 路由懒加载
function lazy(component, models){
    if(typeof models === 'undefined') models = ()=>[];
    return dynamic({
        app:window.app, 
        models, 
        component
    })
}


// 配置路由表
const routes = [
    {
        path:"/",
        exact:true,
        component:Vote, 
        mate:{title:"首页"}
    },
    {
        path:"/count",
        component:lazy(
            ()=>import( /* webpackChunkName:"count" */ './routes/Count'), 
            ()=>[import(/* webpackChunkName:"count" */ './models/count')]
        ),
        mate:{title:"计数器"}
    },
    {
        path:"/user",
        component:lazy(
            ()=>import( /* webpackChunkName:"user" */ './routes/User'), 
        ),
        mate:{title:"个人中心"},
        // 二级路由
        children:[
            {
                path:"/user",
                exact:true,
                redirect:"/user/order"
            },
            {
                path:"/user/order",
                component:lazy(
                    ()=>import( /* webpackChunkName:"user" */ './routes/user/Order'), 
                ),
                mate:{title:"我的订单"}
            },
            {
                path:"/user/profile",
                component:lazy(
                    ()=>import( /* webpackChunkName:"user" */ './routes/user/Profile'), 
                ),
                mate:{title:"我的信息"}
            },
        ]
    },
    {
        path:"*",
        redirect:"/"
    }
]

export default routes;
```



有了路由表，需要写一个算法，动态生成路由规则们，如下：

![1712477138085](./assets/1712477138085.png)

```js
import React from 'react';
import { Router, Route, Switch,Redirect } from 'dva/router';
import routes from "./routerRoutes"


import { ConfigProvider } from "antd"
import zhCN from "antd/es/locale/zh_CN"

const Element = function Element(props){
  let {component:Component, history,location, match} = props;
  let config = {history, location, match}
  return <Component {...config}/>
}

// vue-template-admin  vue2的开源项目
const createRoute = (routes)=>{
  return <Switch>
    {
      routes.map((item,index)=>{
        let {path,exact,component,meta,redirect} = item;
        let config = {};
        if(redirect){
          config = {from:path, to:redirect}
          if(exact) config.exact = exact;
          return <Redirect key={index} {...config}/>
        }
        config = { path }
        if(exact) config.exact = exact;
        return <Route key={index} {...config} render={props=>{
          let title = meta?.title || "dva学习"
          document.title = title;
          return <Element {...props} {...item}/>
        }}/>
      })
    }
  </Switch>
}


function RouterConfig({ history,app }) {
  return (
    <ConfigProvider locale={zhCN}>
      <Router history={history}>
        {
          createRoute(routes)
        }
      </Router>
    </ConfigProvider>
  );
}

export default RouterConfig;
```



测试之：

![1712477159292](./assets/1712477159292.png)



对于二级路由，我们也写一个小算法，生成二级路由规则，如下：

![1712478413774](./assets/1712478413774.png)

```js
// 二级路由规则
export const LevelTwoRouterConfig = function LevelTwoRouterConfig({path}){
  let item = routes.find(item=>item.path === path);
  let children = item?.children;
  if(!children) return null;
  return createRoute(children)
}
// <LevelTwoRouterConfig path="/user" />
```



在User.jsx中，使用之如下：

![1712478496626](./assets/1712478496626.png)

```jsx
import React from "react";
import styled from "styled-components";
import {NavLink} from "dva/router"
import { LevelTwoRouterConfig } from "../router.js"

const UserBox = styled.div`
    display:flex;
    .box{
        width:100px;
        a{
            display:block;
            color:#000;
            line-height:35px;
            font-size:14px;
            &.active{
                color:red;
            }
        }
    }
`;

function User(props){
    return(<UserBox>
        <div className="box">
            <NavLink to="/user/order">我的订单</NavLink>
            <NavLink to="/user/profile">我的信息</NavLink>
        </div>
        <div className="content">
            <LevelTwoRouterConfig path="/user" />
        </div>
    </UserBox>)
}

export default User;
```



测试：

![1712478517155](./assets/1712478517155.png)





### 5，路由跳转与传参

使用Link组件，可以进行路由跳转，如下：

![1712478752776](./assets/1712478752776.png)

```jsx

import {Button} from "antd"
import { Link } from "dva/router"

function Order(props){
    return(<div>
        <h1>订单</h1>
        {/* 还有一种导航,叫声明式导航,通过Link,NavLink */}
        <Link to="/user/profile">按钮</Link>

        {/* 点击按钮进行跳转,叫编程式导航 */}
        {/* <Button type="primary">按钮</Button> */}
    </div>)
}

export default Order;
```



跳转时，可以传递参数，传参分三种：

- 问号传参  ?name=malu&age=18
- 路径传参(动态路由)  /user/profile/malu/18  
- 隐式传参



问号传参：

![1712478905535](./assets/1712478905535.png)

```jsx
import {Button} from "antd"
import { Link } from "dva/router"

function Order(props){
    return(<div>
        <h1>订单</h1>
        <Link to={{
            pathname:"/user/profile",
            search:"?name=malu&age=18"
        }}>按钮</Link>
    </div>)
}

export default Order;
```



测试：

![1712478940573](./assets/1712478940573.png)



使用编程式导航，如下：

![1712479283077](./assets/1712479283077.png)

```jsx

import {Button} from "antd"
import { Link } from "dva/router"

function Order(props){
    // 当访问 /user/order时,渲染Order组件,Order组件叫路由级别的组件
    // 路由级别的组件,它的props中自然就有history,location,match
    // console.log(props)
    let {history} = props;
    // history中有一些API
    //   go
    //   push
    //   replace
    //   back
    //   foward
    //   ...
    return(<div>
        <h1>订单</h1>
        <Button type="primary" onClick={()=>{
            // 问号传参: 数据会放在地址栏中,反复刷新页面,数据还在,不会丢失
            // push 和 repalce 区别
            history.push({
                pathname:"/user/profile",
                search:"?name=malu&age=18"
            })
        }}>按钮</Button>
    </div>)
}

export default Order;
```



除了问号传参，还有隐式传参，如下：

![1712479638436](./assets/1712479638436.png)

```jsx

import {Button} from "antd"
import { Link } from "dva/router"

function Order(props){
   
    let {history} = props;
  
    return(<div>
        <h1>订单</h1>
        <Button type="primary" onClick={()=>{
            // 隐式传参,基于state把数据传递给目标组件,数据不会暴露在url中,url相对就好看一点,安全一点
            // 但是刷新页面时，数据就没有了，一般不用
            history.push({
                pathname:"/user/profile",
                state:{
                    name:"malu",
                    age:18
                }
            })
        }}>按钮</Button>
    </div>)
}

export default Order;
```

```jsx
function Profile(props){
    // Profile也是路由级别的组件，
    // 它的props中，也有history,location,match
    // 想获取参数，通过location来获取
    //   location
    //     search  获取问号传参过来的数据  '?name=malu&age=18'  QS模块/URLSearchParams
    //     state  获取隐式传递过来的数据
    //     pathname
    let {location} = props;
    console.log(location)
    return(<div>
        <h1>个人信息</h1>
    </div>)
}

export default Profile;
```



刷新时，隐式传递的参数就没有了，如下：

![1712479684145](./assets/1712479684145.png)



还有一种传参，就是路径传参，就是所谓的动态路由，配置如下：

![1712479771976](./assets/1712479771976.png)



进行参数传递，如下：

![1712479890945](./assets/1712479890945.png)

```jsx
import {Button} from "antd"
import { Link } from "dva/router"

function Order(props){
   
    let {history} = props;
  
    return(<div>
        <h1>订单</h1>
        <Button type="primary" onClick={()=>{
            // 路径传参
            //  path:"/user/profile/:name?/:age?",
            //  /user/profile
            history.push(`/user/profile/malu/18`)
        }}>按钮</Button>
    </div>)
}

export default Order;
```



在目标组件的props中有一些对象，如下：

![1712480081003](./assets/1712480081003.png)

```jsx
function Profile(props){
    // Profile也是路由级别的组件，
    // 它的props中，也有history,location,match
    // 想获取参数，通过location来获取
    //   location
    //     search  获取问号传参过来的数据  '?name=malu&age=18'  QS模块/URLSearchParams
    //     state  获取隐式传递过来的数据
    //     pathname
    //   match
    //     params  可以非常方便地获取路径传参过来的数据
    console.log("--props:",props)

    let {location} = props;
    console.log(location)
    return(<div>
        <h1>个人信息</h1>
    </div>)
}

export default Profile;
```



前面的Profile组件，是路由级别的组件，只有路由级别的组件，它的props中才有：

- history
- location
- match



如果一个组件不是路由级别的组件，这个组件并没有参与路由的配置，这个组件想获取history, location, match，需要使用withRouter这个高阶函数，如下：

![1712480507760](./assets/1712480507760.png)

```jsx

// withRouter是一个高阶组件
import { withRouter } from "dva/router"

// 这个Demo组件没有参与路由的配置
// 此时，它的props中没有history,location,match
function Demo(props){
    console.log("Demo中的props:",props)

    return(<div>
        <h1>Demo</h1>
    </div>)
}

export default withRouter(Demo);
// export default Demo;
```

```jsx
import { Link } from "dva/router"
import Demo from "./Demo";

function Profile(props){
    // Profile也是路由级别的组件，
    // 它的props中，也有history,location,match
    // 想获取参数，通过location来获取
    //   location
    //     search  获取问号传参过来的数据  '?name=malu&age=18'  QS模块/URLSearchParams
    //     state  获取隐式传递过来的数据
    //     pathname
    //   match
    //     params  可以非常方便地获取路径传参过来的数据
    // console.log("--props:",props)

    let {location} = props;
    // console.log(location)
    return(<div>
        <h1>个人信息</h1>
        <Demo></Demo>
    </div>)
}

export default Profile;
```



### 6，react-router-redux

routerRedux是react-router-redux中提供的对象，这个对象中包含路由跳转的方法：

- go
- goBack
- goFoward
- push
- replace



相比props.history来说，routerRedux不仅可以在组件中实现跳转，并且可以在redux操作中实现路由跳转。它本身就是redux和router的结合操作。在使用时，分你是在redux中使用，还是在组件中使用。

- 在redux中使用
  - yield put(routerRedux.push(....))
- 在组件中使用
  - dispatch(routerRedux.push(....))
  - 一定要基于dispatch进行派发才会跳转，执行routerRedux.push(....)，返回一个action对象



在组件中使用：

![1712482601283](./assets/1712482601283.png)

```jsx

import {Button} from "antd"
import { Link, routerRedux } from "dva/router"
import {connect} from "dva"

function Order({dispatch}){
    
    return(<div>
        <h1>订单</h1>
        <Button type="primary" onClick={()=>{
            dispatch(
                // 路径传参
                routerRedux.push("/user/profile/malu/18")
            )
        }}>按钮</Button>
    </div>)
}

export default connect()(Order);
```



routerRedux.push("/user/profile/malu/18") 得到的是一个action，如下：

![1712482675526](./assets/1712482675526.png)





同样，可以进行问号传参，如下：

![1712482740299](./assets/1712482740299.png)

```jsx

import {Button} from "antd"
import { Link, routerRedux } from "dva/router"
import {connect} from "dva"

function Order({dispatch}){
    console.log(routerRedux.push("/user/profile/malu/18"));
    return(<div>
        <h1>订单</h1>
        <Button type="primary" onClick={()=>{
            dispatch(
                // 路径传参
                routerRedux.push({
                    pathname:"/user/profile",
                    search:"?name=malu&age=18"
                })
            )
        }}>按钮</Button>
    </div>)
}

export default connect()(Order);
```



目标组件中，也是通过props中的location，match来获取数据，不演示了。也可以进行隐式传参，如下：

![1712482822273](./assets/1712482822273.png)

```jsx

import {Button} from "antd"
import { Link, routerRedux } from "dva/router"
import {connect} from "dva"

function Order({dispatch}){
    console.log(routerRedux.push("/user/profile/malu/18"));
    return(<div>
        <h1>订单</h1>
        <Button type="primary" onClick={()=>{
            dispatch(
                // 路径传参
                routerRedux.push({
                    pathname:"/user/profile",
                    state:{name:"malu",age:20}
                })
            )
        }}>按钮</Button>
    </div>)
}

export default connect()(Order);
```







## 四，Dva中的Models



### 1，Model层相关概念

项目中所有的Model，一般都放在src/models目录下，如下：

![1712538929731](./assets/1712538929731.png)



可以在入口中，直接引入一个Model，然后进行注册，那么一加载页面，我们注册的Model就可以使用了。把此Model打包到主JS中的，如果一加载页面，就需要使用某个Model，就可以基于app.model进行注册。如下：

![1712539055616](./assets/1712539055616.png)

```js
import dva from 'dva';
import './index.css';
import voteModel from "./models/vote"

// 1. Initialize
const app = dva({
});
window.app = app;

// 2. Plugins
// app.use({});

// 3. Model
app.model(voteModel);

// 4. Router
app.router(require('./router').default);

// 5. Start
app.start('#root');
```



不需要页面一加载就使用的Model，我们可以和组件一样，做懒加载。只有路由匹配成功了，进入这个组件，才会把相关的JS加载出来，此时，对应的Model中的内容才能使用，如下：

![1712539365875](./assets/1712539365875.png)

```js
// 路由懒加载
function lazy(component, models){
    if(typeof models === 'undefined') models = ()=>[];
    return dynamic({
        app:window.app, 
        models, 
        component
    })
}

const routes = [
    {
        path:"/",
        component:Vote,  
        exact:true,
        mate:{title:"首页"}
    },
    {
        path:"/count",
        component:lazy(
            ()=>import( /* webpackChunkName:"count" */ './routes/Count'), 
            ()=>[import(/* webpackChunkName:"count" */ './models/count')]
        ),
        mate:{title:"计数器"}  
    },
    .....
]
```



如果所有的Model，全部打包到主JS中，页面一加载就把所有的Model都准备好了，我们想怎么用就怎么用。但是此时模块越多，对应的Model也很多，那么主JS就会比较大，第一次渲染速度就会降低。所以我们可以把不需要在第一次加载完就处理的Model，只有进入相关组件才需要处理的Model，可以通过dynamic配置成懒加载。

![1712539479195](./assets/1712539479195.png)



在每一个Model中都包含了5部分内容：

- namespace：模块名，这个名字是后期我们获取状态和进行派发的标识  
- state: 一个模块中存储的状态     state.count.num
- reducers:  存储一个个的方法，都是同步修改的方法，外部派发 dispatch('count/xxxx')
- effects: 基于redux-saga实现异步操作，异步派发
- subscriptions: 在这里订阅的方法，会在页面一加载的时候就会被执行。可以把页面一加载，就要去做的事情写在这里。在这里也可以基于history.listen做事件监听，保证进入哪个组件再处理也可以。



在Model中定义好状态了，在组件中可以使用了，先状态状态：

![1712539640531](./assets/1712539640531.png)





在组件中使用：

![1712539783662](./assets/1712539783662.png)

```jsx
import {connect} from "dva"

function Count({num,dispatch}){
    return(<div>
        <span>{num}</span>
        <button>+1</button>
    </div>)
}

// state=>state.count 把仓库中count模块中的状态，映射成组件的props
// connect还有第二个参数，第二个参数一般不写
export default connect(state=>state.count)(Count);
```





### 2，Model层操作



其实，仓库中状态的定义，我们可以直接写在入口中，如下：

![1712539973273](./assets/1712539973273.png)

```js
import dva from 'dva';
import './index.css';
import voteModel from "./models/vote"

// 1. Initialize
const app = dva({
    // 指定初始化状态
    initialState:{
        count:{
            num:200
        }
    }
});
window.app = app;

// 2. Plugins
// app.use({});

// 3. Model
app.model(voteModel);

// 4. Router
app.router(require('./router').default);

// 5. Start
app.start('#root');
```



不进行懒加载，直接在入口中进行注册，如下：

![1712540004132](./assets/1712540004132.png)

![1712540050745](./assets/1712540050745.png)

```js
import dva from 'dva';
import './index.css';
import voteModel from "./models/vote"
import countModel from "./models/count"

// 1. Initialize
const app = dva({
    // 指定初始化状态
    initialState:{
        count:{
            num:200
        }
    }
});
window.app = app;

// 2. Plugins
// app.use({});

// 3. Model
app.model(voteModel);
app.model(countModel);

// 4. Router
app.router(require('./router').default);

// 5. Start
app.start('#root');
```



在入口中，给Model模块赋初始状态，它的优先级要高于每个Model中设置的初始状态，需要注意的是，这个Model一定不是懒加载的。

![1712540141066](./assets/1712540141066.png)



一般情况下，都不会在入口中指定初始化状态：

![1712540197559](./assets/1712540197559.png)



把原有的reducer函数中的每一个switch/case情况写成一个个单独的方法，第一个形参state表示本Model中的状态，我们需要把获取的state克隆一份，然后函数最后返回的值，会替换当前模块中的state。第二个形参是action， 表示派发时，传递过来的action对象（里面有一个type属性和一个payload属性）。代码演示：

![1712540757006](./assets/1712540757006.png)

```js
export default {
    namespace: "count", // 模块名
    state: {  // 状态
        num: 100
    },
    reducers: {  // 同步修改状态的方法
        // state表示本模块中的状态  action就是派发时传递过来的action对象
        // 里面包含type 和 payload 
        // increment(state,action){
        // increment(state,{ payload = 1 }){
        //     state = {...state};  // 把老状态copy一份
        //     // state.num += action.payload;
        //     state.num += payload;
        //     // 函数最后返回值，会替换当前模块中的state
        //     return state;
        // }

        // 下面的写法也是可以的
        increment(state, { payload = 1 }) {
          // 函数最后返回值，会替换当前模块中的state
          return {
            ...state, 
            num:state.num+payload
          }
        }

        // 不要直接去修改state
        // increment(state, { payload = 1 }) {
        //     // 直接修改state
        //     state.num += paylaod;
        //     return state;
        // }
    },
    effects: {}, // 异步修改状态的方法
}
```



在组件中派发action，所谓的派发，就是通知reducers或effects中的方法执行，其中reducers是同步修改状态的，effects是异步修改状态的。如下：

![1712540779362](./assets/1712540779362.png)

```jsx
import {connect} from "dva"

function Count({num,dispatch}){
    return(<div>
        <span>{num}</span>
        <button onClick={()=>{
            dispatch({
                type:"count/increment",
                payload:5
            })
        }}>同步加</button>
    </div>)
}

// state=>state.count 把仓库中count模块中的状态，映射成组件的props
// connect还有第二个参数，第二个参数一般不写
export default connect(state=>state.count)(Count);
```



redux-saga中我们是基于take/takeLatest/takeEvery等方式创建监听器，此时在effects中写成一个个的生成器函数就可以。默认是基于takeEvery的方式进行监听的。其中方法名是我们创建的监听器的名字，方法就是派发的任务被监听后，要执行的工作saga。函数名不要和reducers中函数名一样，因为每次派发，reducers和effects中的方法都会进行匹配，如果函数名一样，则状态会被修改两次，一般在effects名字后面，都加Async。演示：

![1712541100438](./assets/1712541100438.png)

```js
effects: { // 异步修改状态的方法
    *incrementAsync(){
        console.log("haha")
    }
},
```



在组件中进行派发，只要名字中带有async的，就是异步派发。如下：

```jsx
import { connect } from "dva"

function Count({ num, dispatch }) {
    return (<div>
        <span>{num}</span>
        <button onClick={() => {
            dispatch({
                type: "count/increment",
                payload: 5
            })
        }}>同步加</button>
        <button onClick={() => {
            dispatch({
                type: "count/incrementAsync",
                payload: 10
            })
        }}>异步加</button>
    </div>)
}

// state=>state.count 把仓库中count模块中的状态，映射成组件的props
// connect还有第二个参数，第二个参数一般不写
export default connect(state => state.count)(Count);
```



画图：

![1712485388188](./assets/1712485388188.png)





effects方法中的形参有两个：

- 第1个是action，就是在组件中进行派发时，传递的action对象
- 第2个参数是redux-saga中提供的EffectsAPI，但是没有delay/debounce等待
  - 基于yield select() 可以获取所有模块的公共状态（let xxx = yield select()）。也可以获取指定Model中的状态（let {num} = yield select(state=>state.count)）
  - 基于yield put就可以派发一个action。

![1712541293269](./assets/1712541293269.png)

![1712541335851](./assets/1712541335851.png)



写一个delay方法，如下：

![1712541438834](./assets/1712541438834.png)

```js
const delay = (interval=1000)=>{
    return new Promise(resolve=>{
        setTimeout(()=>{
            resolve()
        },interval)
    })
}
```



基于yield call调用上面的延迟函数，基于yield put实现派发，如下：

![1712541593679](./assets/1712541593679.png)

```js
effects: { // 异步修改状态的方法
    *incrementAsync({payload},{call,put,select}){
        // let xx = yield select(state=>state.count);
        // console.log("xx:",xx)

        yield call(delay,2000);
        yield put({
            type:"increment",
            payload
        })
    }
},
```





如果要设置不同类型的监听器，数组第二项中指定监听器的类型。可以这样写：

![1712541748351](./assets/1712541748351.png)

```js
effects: { // 异步修改状态的方法
    incrementAsync:[
        function* ({payload},{call,put,select}){
            yield call(delay,2000);
            yield put({
                type:"increment",
                payload
            })
        },
        // 数组第二项是指定监听器的类型
        {type:'takeLatest'}
    ]
},
```



还可以指定其它类型：

```
{type:'throttle',ms:500}
```



快速实现支持和反对，异步支持和异步反对，如下：

```js
const delay = (interval=1000)=>{
    return new Promise(resolve=>{
        setTimeout(()=>{
            resolve()
        },interval)
    })
}

export default {
    namespace:"vote", // 模块名
    state:{  // 状态
        supNum:10,
        oppNum:100
    }, 
    reducers:{
        support(state){
            return {
                ...state,
                supNum:state.supNum+1
            }
        },
        oppose(state){
            return {
                ...state,
                oppNum:state.oppNum+1
            }
        }
    }, 
    effects:{
        *supportAsync(_, {call, put}){
            yield call(delay, 2000);
            yield put({type:'support'})
        },
        opposeAsync:[
            function* (_, {call, put}){
                yield call(delay, 2000);
                yield put({type:'oppose'})
            },
            {type:'takeLatest'}
        ]
    }, 
}
```



组件中派发上面的任务：

![1712542957315](./assets/1712542957315.png)



```jsx
import { connect } from "dva"
function Vote({ supNum, oppNum, dispatch }) {
    return (<div>
        <div>
            <h2>React比Vue值钱？<span> {supNum + oppNum} </span></h2>
        </div>
        <div>
            <p>支持：{supNum} 人</p>
            <p>反对：{oppNum} 人</p>
        </div>
        <div>
            <button onClick={() => {
                dispatch({ type: 'vote/support' })
            }}>同步支持</button>
            <button onClick={() => {
                dispatch({ type: 'vote/oppose' })
            }}>同步反对</button>
            <button onClick={() => {
                dispatch({ type: 'vote/supportAsync' })
            }}>异步支持</button>
            <button onClick={() => {
                dispatch({ type: 'vote/opposeAsync' })
            }}>异步反对</button>
        </div>
    </div>)
}

export default connect(state => state.vote)(Vote);
```





### 3，dva中的subscription

subscriptions中写的方法，页面一加载就会把它里面所有方法都执行，它里面写的方法是普通方法，并不是Generator函数。

![1712543360214](./assets/1712543360214.png)

![1712543401371](./assets/1712543401371.png)

![1712543461715](./assets/1712543461715.png)

```js
subscriptions:{
    fn(){
        console.log("fn...")
    },
    gn(){
        console.log('gn...');
    }
}
```





形参中有history和dispatch两个属性。history是包含路由跳转和监听history对象的listener。dispatch是进行派发的方法。

![1712543573799](./assets/1712543573799.png)



如果想页面一加载（或者是指定某个条件下），我们想从服务器异步获取数据，修改引Model中的状态值，则可以写在subscriptions中。

![1712543781345](./assets/1712543781345.png)



方法只有页面一加载的时候，订阅执行一次，在后期路由切换中，不再执行，如下：

![1712543879245](./assets/1712543879245.png)



如果想让它在页面一加载时，执行一次，在路由切换时，也执行，操作如下：

![1712544067676](./assets/1712544067676.png)



现在想访问/时执行，访问 /count时不执行，如下：

![1712544236760](./assets/1712544236760.png)



只要访问 / 就加1，如下：

![1712544343483](./assets/1712544343483.png)

```js
subscriptions:{
    // async setup({history,dispatch}){
    //     console.log("xxxxxxxxxxxx")
    //     await delay(2000)
    //     dispatch({type:'support'})
    // }

    setup({history,dispatch}){
        history.listen(async (location)=>{
            let {pathname} = location;
            if(pathname === '/'){
                await delay(2000)
                dispatch({type:'support'})
            }
        })
    }
}
```





history.listen表示创建一个监听器，监听器是可以移除的，如下：

![1712544590702](./assets/1712544590702.png)



上面的演示是在vote Model没有懒加载的情况下执行的效果。对于count组件和对应的Model，可以懒加载，如下：

![1712544688659](./assets/1712544688659.png)

![1712544717619](./assets/1712544717619.png)



在count.js中写subscriptions，如下：

![1712544861778](./assets/1712544861778.png)

![1712544929739](./assets/1712544929739.png)



###  4，dva-loading插件

![1712545116331](./assets/1712545116331.png)



安装插件：

```
npm i dva-loading@^3.0.22
```

![1712545301329](./assets/1712545301329.png)



看Count组件，打印出dispatch函数执行的结果：

![1712545564574](./assets/1712545564574.png)



上面的打印结果是und，原因是在effects中没有写返回值，如下：

![1712545642697](./assets/1712545642697.png)



上面异步加使用的是takeLatest创建的监听器，就已经实现了所谓的防抖，如下：

![1712545780010](./assets/1712545780010.png)



现在不在监听saga中做防抖处理，如下：

![1712545901804](./assets/1712545901804.png)



给按钮添加一个loading，实现防抖，如下：

![1712546193569](./assets/1712546193569.png)



```jsx
import { connect } from "dva"
import { Button } from "antd"
import { useState } from "react"

function Count({ num, dispatch }) {
    let [loading, setLoading] = useState(false)
    return (<div>
        <span>{num}</span>
        <Button type="primary" onClick={() => {
            dispatch({
                type: "count/increment",
                payload: 5
            })
        }}>同步加</Button>
        <Button type="primary" loading={loading} onClick={async () => {
            setLoading(true)
            await dispatch({
                type: "count/incrementAsync",
                payload: 10
            })
            setLoading(false)
        }}>异步加</Button>
    </div>)
}

// state=>state.count 把仓库中count模块中的状态，映射成组件的props
// connect还有第二个参数，第二个参数一般不写
export default connect(state => state.count)(Count);
```



上面是自己写状态控制，现在我们可以使用dva-loading插件，如下：

![1712546361602](./assets/1712546361602.png)

```js
import dva from 'dva';
import './index.css';
import voteModel from "./models/vote"
import createLoading from "dva-loading"

// import countModel from "./models/count"

// 1. Initialize
const app = dva({
    // 指定初始化状态
    // initialState:{
    //     count:{
    //         num:200
    //     }
    // }
});
window.app = app;

// 2. Plugins
app.use(createLoading());

// 3. Model
app.model(voteModel);
// app.model(countModel);

// 4. Router
app.router(require('./router').default);

// 5. Start
app.start('#root');
```



在组件中，就可以结构出来了，如下：

![1712546594056](./assets/1712546594056.png)







### 5，使用redux-logger中间件



安装redux-logger中间件：

```
cnpm i redux-logger@2.10.2
```



查看一个依赖的版本：

```
npm view redux-logger versions
```



使用redux-logger中间件：

![1712547559601](./assets/1712547559601.png)



测试一下：

![1712547755955](./assets/1712547755955.png)

















































