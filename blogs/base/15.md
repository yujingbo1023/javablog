---
title: 15-TS精讲
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 一，TS介绍

### 1，没有TS带来的问题

看如下代码：

![1699943421146](./assets/1699943421146.png)

如果使用ts来写，如下：

```ts

// args:数据类型  string是一个数据类型  
// string[]  是数组类型  这个数组中只能放字符串
function getLen(args:string | string[]) {
  return args.length;
}

console.log(getLen("hello ts"));
console.log(getLen(["a", "b", "c"]));

// 在你写代码过程中就报错了
// console.log(getLen([1,2,3]));  // 不ok

// console.log(getLen(123));  // 不ok
// console.log(getLen()); // 不ok

console.log("后面的代码~~~~");
```

### 2，TS介绍

TypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码。我们可以将TypeScript理解成加强版的JavaScript。可以说它非常重要，因为现在很多框架源码或公司的业务代码都使用TS来写。也可以说它不重要，因为现在大部分项目还是使用JS来写的。我们可以把TypeScript理解成更加强大的JavaScript，不仅让JavaScript更加安全，而且给它带来了诸多好用的好用特性；

很多项目都采用TS：
* Angular源码在很早就使用TypeScript来进行了重写，并且开发Angular也需要掌握TypeScript； 
* Vue3源码也采用了TypeScript进行重写，在阅读源码时你会看到大量TypeScript的语法； 
* 包括目前已经变成最流行的编辑器VSCode也是使用TypeScript来完成的； 
* 包括在React中已经使用的ant-design的UI库，也大量使用TypeScript来编写； 
* 目前公司非常流行Vue3+TypeScript、React+TypeScript的开发模式； 
* 包括小程序开发，也是支持TypeScript的；

网站：

* 官方网站：https://www.typescriptlang.org/
* 中文官网： https://www.tslang.cn/

### 3，环境搭建

创建一个vue3+ts的项目：

![1699943019192](./assets/1699943019192.png)

运行项目：

![1699943171971](./assets/1699943171971.png)

## 二，TS中的数据类型

### 1，TS变量的声明

格式：var/let/const 标识符: 数据类型 = 赋值; 

```ts
// 没有写类型，ts会自动推导出来
let a = 110;
// a = "hello"; // 不ok  不能把string类型的数据赋值给number类型

// var/let/const 变量名:数据类型 = 赋值
// java中：   int a = 110;
let b: number = 666;
b = 888;

let c: string = "hello ts";
c = 'hi ts'

console.log(a,b,c);
```

自动类型推导：

```ts
let a = 110;   // a的类型就已经确定了，是number类型
let b = "hi";   // b的类型就已经确定了，是string类型

a = 'ok';  // 不ok
b = 888;    // 不ok
```

### 2，number类型

```ts
// ts和js一样，不分小数和整数，都是number
// 在java中，分小数和整数，小数是float和double，整数是int
let num = 100;  // 10进制
num = 200;
num = 300;

num = 0b110; // 2进制
num = 0o567; // 8进制
num = 0xf123; // 16进制
```

### 3，boolean类型

```ts
// boolean类型只有两个值：true,false
let b: boolean = true;
b = false;

// 1 > 2 结果是boolean类型
let flag = 1 > 2; // flag的类型会自动推导
```

### 4，string类型

```ts
// string要小写
let str: string = 'hi ts';
str = "hello ts";

let userName = "malu";
let userAge = 18;
let height = 1.88;

// ts中写代码，提示给js中给力的多
let info = `my name is ${userName}，age is ${userAge}，height is ${height}`;

console.log(info);
```

### 5，Array类型

```ts
// names是一个数组，里面只能放string类型
// 也就是说在ts或java中，说到数组，它里面一般都是放同一种类型
// let names:string[] = ["a",1,true];  // 不ok

// 在真实开发中，一般情况下，数组中都是放同一种数据类型
// 不要放不同的类型的数据
let names: string[] = ["a", "b", "c"];
console.log(names); 
names.push("d")
// names.push(666);  //不ok
console.log(names);

// 定义数组的另一种方式：需要我们讲到泛型后你才能理解
let nums: Array<number> = [1, 2, 3];
nums.push(666);
console.log(nums);
```

### 6，Object类型

```ts
// 你感觉可能是这样写的，其实这样写不对
let obj1: object = {
  a: 1,
  b: 2,
  c: 3
}

console.log(obj1.a);  // 报红  获取数据时，报错了
obj1.d = 4;
console.log(obj1.d);  // 报红

// { x: number, y: number } 整体是一个类型
let obj2: { x: number, y: number } = {
  x: 1,
  y: 2
}
console.log(obj2.x);
obj2.y = 22;
console.log(obj2.y);

// 可以给一个类型起别名  type
type MyType = { m: string, n: number };
let obj3: MyType = {
  m: 'hi',
  n: 123
}
```

### 7，Symbol类型

JS中的Symbol可以创建一个唯一值：

```js
// 在js中，如果键同名了，后面的会覆盖掉前面
// const person = {
//   identity: 'coding',
//   identity: 'teacher',
// }
// console.log(person);  // { identity: 'teacher' }

const person = {
    [Symbol()]: 'coding',
    [Symbol()]: "teacher"
}
console.log(person); // { [Symbol()]: 'coding', [Symbol()]: 'teacher' }
```

TS中使用之：

```ts
let s1:symbol = Symbol('id')
let s2:symbol = Symbol('id')

const person = {
  [s1]: 'coding',
  [s2]: "teacher"
}
console.log(person);  
```

### 8，null和undefined类型

```ts
// null类型只有一个值是null
// undefined类型只有一个值是undefined
let x: null = null;
let y: undefined = undefined;
```

### 9，函数的参数类型

```ts
function sum(x:number,y:number,z:number) {
  return x + y + z;
}

let res = sum(1, 2, 3);  // res的类型会自动推导
console.log(res);  // 6

// let res2 = sum("1", "2", "3"); // 报红
```

### 10，函数的返回值类型

```ts
// 指定函数的返回值类型
function sum(x: number, y: number, z: number): number {
  // return x + y + z;

  // return "hello";// 报红
}

let res = sum(1, 2, 3);  // res的类型会自动推导
console.log(res);  // 6

// let res2 = sum("1", "2", "3"); // 报红
```

看一个小案例：

```ts
// type是给一个类型起别名
// 别名是TodoType
type TodoType = {
  text: string,
  done: boolean
}

function getTodos(txt:string): TodoType[] {
  let todos: TodoType[] = [];
  todos.push({ text: txt, done: false })
  return todos;
}

console.log(getTodos('学习ts'));  // [ { text: '学习ts', done: false } ]
```

### 11，匿名函数参数

```ts
let names: string[] = ["malu", "wc", "xq"];

// forEach中写的函数是匿名函数
// 匿名函数中形参的类型会根据上下文推导出它的类型
names.forEach(function (item,index,arr) {
  console.log(item,index,arr);
})

// 匿名函数的形参类型，最好不要加类型，就靠它自动推导就OK
names.forEach(function (item:string, index:number, arr:string[]) {
  console.log(item, index, arr);
})

names.forEach(item=>console.log(item))
```

### 12，对象类型

```ts
// let malu: { name: string, age: number, height: number } = { name: "ml", age: 18, height: 1.88 };

type MaluType = { name: string, age: number, height: number };
let malu: MaluType = { name: "ml", age: 18, height: 1.88 };
console.log(malu);

// ?表示属性可以有可以没有
type PointType = {
  x: number,
  y: number,
  z?: number,
}

function print(point: PointType) {
  console.log("x坐标是：", point.x);
  console.log("y坐标是：", point.y);
  console.log("z坐标是：", point.z);
}

print({ x: 1, y: 2, z: 3 })
```

### 13，可选类型

```ts
type PointType = {
  x: number,
  y: number,
  z?: number,  // 可选属性
}

function print(point: PointType) {
  console.log("x坐标是：", point.x);
  console.log("y坐标是：", point.y);
  // 由于z是可选的，使用z时，作一个判断
  if (point.z) {
    console.log("z坐标是：", point.z);
  }
}

print({ x: 1, y: 2, z: 3 })
print({ x: 1, y: 2 })
```

### 14，any类型

一个数据如果是any类型，它可以赋值任何类型的数据，和JS就一样了，所以一般不会使用any。当我们无法确定一个变量的类型时，并且它的类型可能会发生变化，此时也是可以使用any类型。

```ts
// 如果一个变量是any类型，可以赋值任何值，和JS一样。
let a: any = 1;
a = "hi";
a = true;

a = { x: 1, y: 2 }
console.log(a.x);
console.log(a.y);

// 数组names中可以放任意类型的数据，和JS一样了
let names: any[] = [1, true, "hi", undefined]
console.log(names);
```

### 15，unknown类型

unknown类型是TS中的一种特殊的数据类型，用于描述一个不确定的变量。和any有点类似，但是在unknown类型上做任何事情都是不合法的。

```ts
function foo(): string {
  return "hi ts"
}

function bar(): number {
  return 123;
}

let flag = true;
// res的数据类型是unknown类型
let res: unknown;
if (flag) {
  res = foo();
} else {
  res = bar();
}
// 类型缩小
if (typeof res === 'string') {
  console.log(res.length);
}

console.log(res);

console.log("---------------");

let xx: unknown;
xx = 123;
xx = "hi vue";
xx = { a: 1, b: 2 }
xx.c = 456;  // 报红了
console.log(xx);
```

### 16，void类型

void是用来指定函数返回值类型的，如果函数没有返回值，返回值类型就是void，和java一样。

```ts
// void用于指定函数没有返回值
function sum(x: number, y: number): void {
  console.log(x + y);

  // return 123; // 报错
}
let res = sum(1, 2);
console.log(res);

let names: string[] = ["malu", "wc", "xq"];

// 匿名函数的形参item会自动推导
// 匿名函数的返回值类型是什么？ 鼠标摸一下，发现是void
names.forEach(function (item) {
  console.log(item);
  return 123; // 没有报红  它会根据上下文推导出你到底返回值是什么类型
})

// fn是一个函数，函数也有类型
let fn: () => void = () => { }

// () => void 是一个类型  要求没有形参 没有返回值
type FnType = () => void;
// let fn2: FnType = (a)=>{}  // 报红
let fn2: FnType = () => { return 123; }  // 没报红
console.log(fn2());
```

### 17，never类型

never表示永远不会发生类型，如一个函数是死循环，这个函数永远不可能有返回值。或者函数中抛出了一个错误，也是永远不可能有返回值。

```ts
// 写项目中，never基本上用不到
// 在封装一些框架或工具库时，可能会用到

function fn(): never {
  throw new Error();

  // while(true){}  // 死循环
}

console.log(fn());
```

### 18，tuple类型

在JS中没有元组类型，但是在Python，Swift等语言中有元组类型，在JAVA中也是没有元组类型。

```ts
// [number, string, boolean] 整体是一个元组类型
// 每一个元素的数据类型都定死了
let info1: [number, string, boolean] = [1, 'hi', true]

type MyTupleType = [number, number, number];
let info2: MyTupleType = [1, 2, 3];

// 要保存一个人的信息：wc, 18, 1.88
let person = {  // 通过对象来保存，用的最多
  name: "wc",
  age: 18,
  height: 1.88
}

// person2是一个数组
let person2: any[] = ["wc", 18, 1.88];

let person3: [string, number, number] = ["wc", 18, 1.88];
console.log(person3[0]);  // wc
console.log(person3[1]);  // 18
```

元组和数组的区别？

* 数组中放相同类型的元素，不同类型的元素不建议放在数组中，当然也可以放在对象中。
* 元素中每一个元素可以有自己特有类型，根据索引就可以获取对应的值。

元组的应用：

```ts
//  [number, (newValue: number) => void] 整体是元组类型
function useState(initialState: number): [number, (newValue: number) => void] {
  let stateVlaue = initialState;
  function setValue(newValue: number) {
    stateVlaue = newValue;
  }
  return [stateVlaue, setValue];
}

// 期望函数返回值的类型是元组
// counter 是状态   setCounter 是修改状态的方法
let [counter, setCounter] = useState(10);
setCounter(20)
```

### 19，联合类型

把两个或多个其它类型组合成一种新的类型，就是联合类型。

```ts
// number | string 联合类型
let a: number | string = 110;
a = 'hi';

if (typeof a === 'string') {
  console.log(a.length);
}

// 如果一个数据是联合类型，赋值时可以赋值给其中的一种类型
function fn(msg: number | string) {
  // 类型缩小
  if (typeof msg === 'string') {
    console.log(msg.length);
  } else {
    console.log(msg);
  }
}

fn(110)
fn('hi ts')

```

### 20，类型别名

通过type可以给一个类型起别名，通常是给一个对象类型起别名。

```ts
// type就是给某个类型起别名
type MyNumber = number;
let age: MyNumber = 110;

// 给一个联合头型起别名
type MsgType = number | string;

// 给一个对象类型起别名
type PointType = {
  x: number,
  y: number
}

// 后面这个别名就可以是一种类型了
function printPoint(point: PointType) {
  console.log(point.x,point.y);
}

printPoint({x:1,y:2})
```

### 21，接口声明（难）

接口和类型别名比较像，在定义对象类型时，使用类型别名实现的，使用接口也可以使用。我是这样记的：

* type 是给某个类型起别名
* interface是发明一种新的类型

```ts
// 声明一个接口
// interface相当于发明了一种数据类型，也是用于约束对象的
// type是用来起别名
interface PointType {
  x: number,
  y: number,
  z?: number
}

function printPoint(point: PointType) {
  console.log(point.x, point.y);
  if (point.z) {
    console.log(point.z);
  }
}

printPoint({ x: 1, y: 2, z: 3 })
```

interface和type的区别？

* interface是发明一种新的类型，只能约束对象类型，type除了约束对象类型之外，还可以约束其它类型。说白了就是type的使用范围更广，接口只能约束对象类型。
* interface可以重复对某个接口定义属性和方法，type不能重复。
* interface可以继承。interface可以被类实现（和java一样）。

写代码演示他们之间的区别：

```ts
// type的使用范围更广，接口只能约束对象类型
type MyNumber = number;
type Xxx = number | string | boolean;

// -------------------------

// type 别名不能重名
// type PointType1 = {
//   x: number,
//   y: number,
// }
// type PointType1 = {
//   z?: number
// }

// -------------------------

// interface发明的类型是可以重名的
// interface只能约束对象类型
interface PointType1 {
  x: number,
  y: number,
}
interface PointType1 {
  z?: number
}

function printPoint(point: PointType1) {
  console.log(point.x, point.y);
  if (point.z) {
    console.log(point.z);
  }
}

printPoint({ x: 1, y: 2, z: 3 })

// -------------------------

// interface是可以继承的
interface IPerson {
  name: string,
  age: number
}
interface IMalu extends IPerson {
  height?: number
}
let ml: IMalu = {
  name: "ml",
  age: 18,
  height: 1.88
}

// 什么时候使用interface，什么时候使用type类型别名？
//    只约束一个对象中有什么属性时，推荐使用interface
//    如果不是约束一个对象，仅仅是给一个类型起别名，使用type
```

### 22，交叉类型 

前面说过联合类型，如下：

```ts
// 'malu' 是一个字面量类型
let ml: 'malu' = 'malu';

// 'left'  就是一个类型，叫字面量类型
// 'left' | 'right' | 'top' | 'botton'  整体是一个联合类型
type MyType = 'left' | 'right' | 'top' | 'botton';

let a:MyType = 'right'
```

还有一种类型，叫交叉类型，交叉类型是所的条件都要满足：

```ts
interface ITeach {
  name: string,
  age: number
}

interface ICode {
  name: string,
  coding: () => void;
}

// ITeach & ICode 整体是一个交叉类型
type InfoType = ITeach & ICode;

let info: InfoType = {
  name: "ml",
  age: 18,
  coding() {
    console.log("coding...");
  }
}
```

### 23，类型断言

有时候ts并不能获取一个数据的具体类型，此时我们就可以使用类型断言，类似于强制类型转化。

```ts
// document.getElementById("logo")  得到这个dom元素，ts也不知道它是什么类型，那才可以断言
// HTMLImageElement 这是一种数据类型
let ele = document.getElementById("logo") as HTMLImageElement

if (ele !== null) {
  ele.src = "xxx";

  console.log(ele);
}

let age = 110;
// age 断言成 string类型
// let age2 = age as string;  // 报红

// let age3 = age as any;
```

### 24，非空类型断言

```ts
interface IPerson {
  name: string
  age: number
  friend?: {
    name: string
  }
}

let info: IPerson = {
  name: "ml",
  age: 18,
  friend: {
    name:"xq"
  }
}
// ?. 是一个新的运算符
console.log(info.friend?.name);

// 类型缩小
if (info.friend) {
  console.log(info.friend);
}

// 非空类型断言（有点危险，一定要确保有friend时再使用）
// ! 表示非空断言
console.log(info.friend!.name);
```

### 25，字面量类型

```ts
// malu就是一种数据类型
let myname: 'malu' = 'malu';
// 18也是一种数据类型，都是字面量类型
let age: 18 = 18;

// "left" | "right" | "up" | "down"  整体是一个联合类型
type Direction = "left" | "right" | "up" | "down"
const d1: Direction = "left"

type MethodType = "get" | "post"
function request(url: string, method: MethodType) { }
request("http:xxx", 'get')

let obj = { url: "xxx", method: "post" }
// obj.method 得到的是字符串类型
// request(obj.url,obj.method) // 报红
request(obj.url, obj.method as 'post') // 报红
```

### 26，类型缩小

```ts

```

### 27，函数类型

```ts

```

### 28，函数重载

```ts

```

### 29，This

```ts

```
