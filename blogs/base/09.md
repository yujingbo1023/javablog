---
title: 09-网络编程
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---



## 零，网络扫盲

```
网络的起源：网络主要是指以太网络，以太网(Ethernet)指的是由Xerox（施乐）公司创建。可以实现多个设备之间的通讯。

网络通讯基本条件：
1. 具有接收发送硬件。专门的设备可以负责将数据进行发送，同时可以负责接收，这个设备就是网卡。
   有两种：有线网卡和无线网卡
   a) 调制（发送数据），将电脑上的二进制数据转化成电信号 abcd->1100 高高低低 电压
   b) 解调（接收数据），将接收到的电信号转换成二进制信息 高高低低 电压 1100->abcde
   网络速率：
   百兆网卡（100M）  表示每秒最多可以传输 100000000 bit数据
   千兆网卡（1000M）  表示每秒最多可以传输 1000000000 bit数据
   万兆网卡（10000M）  表示每秒最多可以传输 10000000000 bit数据
2. 具有传输数据的介质  
   1）有线传输介质：网线 ===>  电信号 ，  光纤线  ===>  光信号
   2）无线传输介质：wifi 蓝牙 红外  波段
   传输介质的速率一般情况下也是分：百兆 千兆 和万兆的。
3. 具有传输速率协商，速率协商过程会根据木桶原理，找速率最低点 
   电脑（1Gbps = 每秒钟 会发送1Gb数据  1*1024*1024*1024~1073741824）
   电脑（100Mbps )
   介质（网线 5类 6类 7类）   


网络通信的规范（OSI7层模型）：open system interconnect开放系统互连参考模型，是由ISO(国际标准化组织)定义的。
1. 应用层：http协议就是应用层的协议，还有很多其它的协议，提供了应用程序的接口。
2. 表示层：实现数据解码和编码、加密和解密、压缩和解压缩。将上层的数据进行转换和编译压缩为标准的文件。
3. 会话层：负责建立、维护管理和终止应用程序之间的会话。
4. 传输层：提供可靠的端到端的报文传输和差错控制技术，负责建立可靠连接。TCP协议。
5. 网络层：
6. 数据链路层：
7. 物理层


交换机：
```



| 层次 | 层次名称                  | 功能简述                                                     |
| ---- | ------------------------- | ------------------------------------------------------------ |
| 01   | 物理层（Physical）        | 实现在介质上传输比特；并提供机械的和电气的规范； 负责把这个的比特从一跳移动到另一跳； 定义数据传输速率、信号的传输模式（单工 半双工 全双工） |
| 02   | 数据链路层（Data Link）   | 将分组数据封装成帧；提供局域网内的节点之间数据传输 实现在不可靠的物理链路上，提供可靠的数据传输服务； 实现组帧、物理编址、流量控制、差错控制、接入控制 |
| 03   | 网络层（Network Layer）   | 将分组数据从源端传送到目的端，实现不通局域网之间网络互联 实质上就是提供路由选择寻址，将上层分段的数据进行打包 并且在网络层为设备提供了逻辑地址 |
| 04   | 传输层（Transport Layer） | 提供可靠的端到端的报文传输和差错控制技术，负责建立可靠连接 可以实现服务点编制、分段与重组、连接控制、流量控制 并且将上层分段的数据进行打包 |
| 05   | 会话层（Session）         | 负责建立、维护管理和终止应用程序之间的会话                   |
| 06   | 表示层（Presentation）    | 对数据进行转换、加密和压缩处理 实现数据解码和编码、加密和解密、压缩和解压缩 将上层的数据进行转换和编译压缩为标准的文件，如 jpg gif ascii码等 |
| 07   | 应用层（Application）     | 提供应用程序的接口，使应用程序能够使用网络服务 很多常见应用层通讯协议，都遵循应用层协议的相关标准 |







## 一，必备基础

### 1，两台计算机进行通信

假设 wc上了一个野鸡大学买了一台电脑，电脑里存了1部小电影，整宿整宿的在宿舍反复的看。

![1696726523919](./assets/1696726523919.png)

wc 如何想要和室友xq 进行收发数据，可以通过一根网线来进行连接，并进行数据的传输。ipconfig

![1696726549739](./assets/1696726549739.png)

### 2，同宿舍多个计算机进行通信

其他的室友如何也想和他们的电脑相互连接然后进行资源的共享，此时就需要一个设备 【二层交换机】组件一个局域网。

![1696724099519](./assets/1696724099519.png)

二层交换机如下：

![1696724078707](./assets/1696724078707.png)

当电脑接入交换机之后，我们需要为每台电脑分配一个IP，例如：
* 电脑1：192.168.10.1
* 电脑2：192.168.10.2
* 电脑3：192.168.10.3
* 电脑4：192.168.10.4

局域网内容个电脑之间是基于ARP协议来进行通信，例如：A电脑向 IP为192.168.10.3的另一个电脑发送消息。它的流程是这样的：

* 第一步：A封装数据包(有头信息，有数据)，此时只知道目标IP不知道目标mac地址（未知mac地址时默认会设置为FF）。
* 第二步：将数据包发送到交换机，交换机通过广播的形式将数据发送给所有电脑。
* 第三步：目标电脑接收到数据包后，监测自己是否是目标IP。
  + 是，收到数据并回复。
  + 不是，则丢弃包。

为防止每次发送消息都是广播形式，每台电脑的内部都为维护了一个ARP表，接受到数据时（无论是否自己的）都会记录自己了解的IP和MAC的对应关系，以便于下次在发送消息时，就知道了目标的mac地址，直接让交换机转发给指定的电脑（单播）。例如：

```txt
 	 Internet地址                 物理地址
    192.168.10.1            14-9d-da-2a-dd-0a
    192.168.10.3            14-9d-da-2a-dd-0c
    	...
```

同时，当有消息发送经过二层交换机时他的内容也会维护记录了交换机接口和连接的电脑的mac地址的对应关系，这样一来，交换机在进行数据转发时，效率就更高了。例如：

```txt
    接口（网卡）               mac地址
      接口1              14-9d-da-2a-dd-0A
      接口2              14-9d-da-2a-dd-0B
      接口3              14-9d-da-2a-dd-0C
      ...
```

注意：每台电脑出厂时在网卡中都设置了唯一的mac地址（不重复），网卡集成在主板上，如果更换了主板则mac地址也会变更。

### 3，多宿舍进行通信

多个宿舍之间想想要组建一个相互可以通信网络，此时需要【二层交换机】和【企业路由器】配合组建稍微大一点的局域网（同时也可缓解广播风暴）。

![1696724558084](./assets/1696724558084.png)

企业路由器：

![1696724615505](./assets/1696724615505.png)

划分好网络结构之后，其实会给各宿舍的电脑分配IP和网关，例如：

```txt
   宿舍A：
        - 电脑1：192.168.10.1  网关：192.168.10.254
        - 电脑2：192.168.10.2  网关：192.168.10.254
        - 电脑3：192.168.10.3  网关：192.168.10.254
        - 电脑4：192.168.10.4  网关：192.168.10.254
   宿舍B
        - 电脑1：192.168.20.1  网关：192.168.20.254
        - 电脑2：192.168.20.2  网关：192.168.20.254
        - 电脑3：192.168.20.3  网关：192.168.20.254
        - 电脑4：192.168.20.4  网关：192.168.20.254
```

然后再在路由器中配置路由表（包含网段和路由器上的接口的对应关系），例如：

```txt
     接口             IP
     eth0         192.168.10.254（192.168.10网段）
     eth1         192.168.20.254（192.168.20网段）
```

想与外部网络通信，需要配置网关，网关就是路由表中配置的指向此网段的IP。其实就类似于贸易出口都需要经过海关。数据通信的过程结合了APR协议和IP协议，例如：宿舍A的电脑1向宿舍B的电脑3发送消息（目标IP：192.168.20.3）。简化过程：
* 宿舍A的电脑1，通过广播或单播将数据发送到网关（路由器）
* 路由器接收到数据之后，再通过对应的接口把数据通过广播的形式发送到宿舍B。

注意：各自局域网内通过学习并记录相关mac地址后，就可以不再使用广播形式，而是使用单播来发送消息了。

### 4，三层交换机

三层交换机集成了 交换机 & 路由器的功能（大部分路由器功能），上述的三个设备其实可以用一个三层交换机就可以搞定。

![1696724911210](./assets/1696724911210.png)

三层交换机：

![1696724886544](./assets/1696724886544.png)

在三层交换机上分别做如下几件事：
* 划分两个vlan，模拟出来路由器的两个接口
* 将交换机的接口划分给指定的vlan，例如：
  + 接口1、2、3划分给一个vlan，相当于交换机连接上了路由器
  + 接口4、5、6划分给一个vlan，相当于交换机连接上了路由器。
* 电脑连接上交换机
* 进行相应的配置。

```txt
    宿舍A（左边）电脑配置：
        - 电脑1：192.168.10.1  网关：192.168.10.254   对应交换机接口：1
        - 电脑2：192.168.10.2  网关：192.168.10.254   对应交换机接口：2
        - 电脑3：192.168.10.3  网关：192.168.10.254   对应交换机接口：3
    宿舍B（右边）电脑配置：
        - 电脑1：192.168.20.1  网关：192.168.20.254   对应交换机接口：4
        - 电脑2：192.168.20.2  网关：192.168.20.254   对应交换机接口：5
        - 电脑3：192.168.20.3  网关：192.168.20.254   对应交换机接口：6
    
    交换机中的路由配置：
          接口               IP
         左vlan        192.168.10.254（192.168.10网段）
         右vlan        192.168.20.254（192.168.20网段）
```

通过上述的配置之后，就可以实现宿舍A和宿舍B的网络通信了。

### 5，小型企业网络架构

![1696725063024](./assets/1696725063024.png)

### 6，家庭网络架构

家用路由器集成了是交换机和路由的功能（性能差、价格便宜）。

![1696725192719](./assets/1696725192719.png)

### 7，互联网

![1696725220524](./assets/1696725220524.png)

### 8，客户端和服务器

**客户端：** Client 客户所使用的电脑中安装的应用程序。   <br/>

**服务端：** Server 存放网页，客户端程序，数据处理程序，数据库的电脑。 <br/>

![1696725347977](./assets/1696725347977.png)

**客户端（网页浏览器、网络爬虫或者其它的工具）作用**

* 发起一个HTTP请求到服务器上指定端口（默认端口为80）
* 我们称这个客户端为用户代理程序（user agent）

**服务端作用**

* 响应的服务器上存储着一些资源，比如HTML文件和图像
* 我们称这个响应服务器为源服务器（origin server）

### 9，一切要从URI说起

**URI**

* Uniform Resource Identifier 统一资源标识符，用来唯一标识一个资源

  

**URL**

* Uniform Resource Locator 统一资源定位符，用来唯一标识一个资源

* URL也可以用来标识一个资源，而且它还可以指明如何定位资源

  

**URN**

* Uniform Resource Name 统一资源命名 通过名字表示资源

  

**URL肯定是一个URI，URI并不一定是URL，也有可能是URN，URL与URN是URI的子集**

* 你要找WC这个人，WC就是一个URI，URI没有寻找资源的方式
* 家庭住址 => URL 定位
* 姓名+身份证号 => URN

![1696725414188](./assets/1696725414188.png)

**对于我们来说，最重要的是URL，它的作用**

* 资源标识
* 有定位资源的功能
* 指明了获取资源所采用的协议

**URL格式**

* 协议名称 + 主机名称 + 端口号 + 路径 + 文件 + 查询所需的字符串 + HASH
* http:// baidu.com :80 /01/index.html ?a=1&b=2 #abc
* scheme:// host port path filename ?query hash



### 10，BS架构和CS架构

**BS架构**

* Browser/Server(浏览器/服务器), 利用浏览器去呈现界面，浏览器提供浏览器所需要的数据
* 优点：无需安装客户端软件，只需要有浏览器，无需升级客户端。
* 缺点：浏览器的兼容性可能有问题，功能性相对弱一点，安全性弱，交互性弱。

**CS架构**

* Client/Server 将应用程序放到一个软件中，可以是Android也可以是iOS，服务器给客户端软件提供它需要的数据。
* 优点：界面丰富，交互性强，响应速度快，安全性强。
* 缺点：开发成本高，需要下载安装，维护成本高，升级麻烦。

### 11，购买云服务器和域名

**服务器分类**

* 实体服务器：自己购买服务器。
* 云服务器：阿里云，华为云，JD云....

**域名分类**

* 通用类
  + .com 工商金融企业
  + .com.cn 公司
  + .gov 政府
  + .net 提供互联网网络服务机构
  + .org 各类组织机构
  + .edu 教育机制
* 国家地区分类
  + .cn 中国
  + .ca 加拿大
  + .uk 英国
  + .jp 日本
* 域名级别
  + 顶级域名（一级域名） baiu.com 一般我们买的是一级域名，在一级域名下可以配 置N个二级域名
  + 二级域名 zhidao.baidu.com image.baidu.com wenku.baidu.com tieba.baidu.com
  + 三级域名 sport.news.baidu.com
  + www.baidu.com 也是所谓的二级域名

**www: world Wide Web 万维网**

* Internet，叫因特网。这个因特网中提供非常多的服务，如www网页服务，ftp文件传输服务，E-mail电子邮件服务，Telnet远程登录服务...，www是浏览器访问网页的服务，所以说，很早之前，所有的网站主页域名前面都会加上www。后来，可以配置二域名和三级域名，不同的域名，就可以对应不同的业务，而业务处理任务会分配到不同的服务器，所以，不再需要使用www来标注主页了。但是加上www，已经成为一种习惯了，所以现在，很多网站都还会做DNS解析www，说到底还是尊重用户习惯。国外的网站基本上都不会使用www。

### 12，DNS解析

**DNS**：Domain Name Server(域名服务器)

* 作用：域名与对应的IP转化的服务器
* DNS中保存了一张域名与对应的IP地址的表，一个域名对应一个IP地址，一个IP地址可以对应多个域名
* 说白了，根据域名，通过DNS解析就可以得到一个IP 地址。就可以找到对应的服务器

### 13，IP地址和端口号

**IP**：Internet Protocol Address 互联网协议地址 IP地址

* 作用：分配给用户上网使用的互联网协议
* 分类：IPv4 IPv6

根据IP地址，就可以找到对应的服务器，服务器上可以提供N种服务器，你需要哪种服务呢？就需要根据端口号，来区分你需要哪种服务。

* 端口号范围：0~65535 0~1024是系统使用的 1025~65535之间
* 知名端口号：http协议下：80 https协议下：443 mysql: 3306 FTP协议下：20 21...

### 14，TCP连接

**TCP**：transmission Control Protocol 传输控制协议

* 特点：在收发数据之前，必须建立可靠的连接。TCP就是可靠连接。UDP不可靠连接。

* 建立连接基础：三次握手

* 应用场景：HTTP请求(HTTP请求就是基于TCP的)，FTP文件传输，邮件发送

* 优点：速度慢，稳定，重传机制

* 缺点：效率低，占用资源，容易被攻击

  

**TCP 三次握手理解 (双方确认)（非常重要，面试必问）**

* TCP是一个端到端的 可靠 面相连接的协议
* HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）
* 根据IP，找到对应的服务器，发起TCP的三次握手

图示：

![1696725743318](./assets/1696725743318.png)

**为什么要3次握手？**

我们假定第一次发送的请求, 因为网络延迟很慢才到达服务端，然后客户端以为这服务器居然不理睬我， 然后
默默的关闭的等待连接的请求，走开了（好比追女神）；但事实呢？女神（服务器）是因为各种各样的原因，很
晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！但是，A早已经远走高飞，这个请求A完全不会收到
（在第二次握手，服务端打开连接，等待客户端的响应），那么女生呢，以为对方收到了，就会一直等待，这样
B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；而三次握手, 就不会发生，服务端同意连
接了，但是A缺一直没有下一步的动作，导致资源浪费；

**关闭TCP连接四次挥手的理解 (客气挽留)**

* 不能直接一次性断开连接(双方知晓), 万一还有什么数据没有传完, 造成数据的丢失!

图示：

![1696725776374](./assets/1696725776374.png)

**为什么要4次挥手？**

这和有礼貌的好友道别一样：（a：客户端 b: 服务端） 1、一开始A想要回家离开，但是呢？怕B还有事情要交代，
那么呢？只好先向B打招呼，我要走了，请求停止交谈(请求断开连接)，(此时，a到B的连接没有断开，依旧可以
进行通信）； 2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看, 你等等, 
等我说完你再走。 3、B确实没啥要补充的了，就告知你我可以撤了 4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )

**总结三次握手和四次挥手**

* 建立连接 => 三次握手 (双方确认)
   - (1) 服务器啊, 我是浏览器, 我要和你建立连接
   - (2)服务器看到了, 好的, 那么建立连接吧, 我准备好了, 你确定吗?
   - (3)浏览器: 是的, 我确定!
   - (4) 连接就建立成功，三次握手 = 连接的发起 + 双方的确认
* 断开连接 => 四次挥手 (客气挽留)
  + (1) 一方A发起断开连接的消息
  + (2) 另一方B会确认收到断开的需求, 但是会要求等一等, 确认是否数据传输完毕
  + (3) B当确认完之后, 确实数据都传完了, 告知A, 连接可以断开了
  + (4) A确认收到消息, 告知B, 我要走了

### 15，HTTP的概念

HTTP是基于TCP协议，HTTP(HyperText Transfer Protocol,超文本传输协议)是访问万维网使用的核心通信协议。



**HTTP：HyperText Transfer Protocol 超文本传输协议**：

* 客户端和与服务器之间传递数据的规范
* HTTP请求：按照HTTP协议（规则），由客户端（浏览器）向服务器发出请求
* HTTP响应：按照HTTP协议（规则），由服务器给出响应



**HTTPS:** HyperText Transfer Protocol Secure 超文本传输安全协议。

* HTTP的安全版本（安全的基础是SSL/TLS）

* SSL: Secure Sockets Layer 安全套接层

* TLS：transport Layer Security 传输层安全

* 说白了，就是为了网络通信提供的一种安全协议，对网络连接进行加密

  

**HTTP和HTTPS的区别**

* HTTP是不安全 HTTPS可以防止攻击
* HTTP协议传输的内容是明文，直接在TCP连接上传递，客户端和服务器都无法验证对方的身份
* HTTPS协议的传输内容都是被SSL/TLS加密，且运行在SSL/TLS，SSL/TLS运行在TCP连接上，所以传递的数据是安全

### 16，HTTP报文



HTTP请求报文：

- 第一部分：请求行
  - 请求方法：GET, POST, PUT， OPTION， DELETE，......
  - URL：
    - host叫主机（IP地址/域名:端口）+ 请求资源
    - 请求资源：
      - 正常的语法资源：/myblog/imgs/1.png
      - 默认请求 /   /myblog/     会在/后面自动加一些资源：  /index.html  index.php  index.jsp  index.xxx.... 
      - 请求资源需要传递参数：  /myblog/imgs/1.png?name=malu&pwd=123
    - 协议（HTTP/HTTPS/FTP）+host（访问网站域名/地址/端口）+请求资源  -- 请求信息 == URL
  - 请求HTTP版本信息
    - 1.0 属于TCP短连接访问  		一次连接对应一次请求
    - 1.1 属于TCP长连接访问  		一次连接对应多次请求 
    - 2.0 可以实现并发请求处理    适合电商网站
- 第二部分：请求头
  - Accept:  确认客户端请求资源类型信息  
  - Referer:  告知服务端是从哪访问过来的。消息头用于表示发出请求的原始URL；
    - 无Referer，代表直接访问网站资源
    - 有Referer，可以获得跳转源url地址信息（记录推广次数）
      - 视频网站：会员登录，http://www.aiqiyi.com/vip/xxx  ==> vip电影
      - 不是会员： http://www.aiqiyi.com/  ==> vip电影 只能试看10分钟
  - Accept-Language:  请求返回语言字符信息
  - Accept-Encoding: 浏览器支持的压缩编码是 gzip 和 deflate
  - Connection:  keep-alive   表示持久的客户端与服务连接；定义客户端与服务建立TCP连接方式（短连接/长连接）
  - Cookie:  第一次访问服务器，服务器给浏览器种植一些cookie，后面再去请求服务器，就需要带上这些cookie，这样服务器就可以认识你了。
    - Cookie中保存也是一些数据，这些数据是存储在浏览器端的，每次请求这些数据都要带上这些数据。
    - 识别用户访问行为      抖音网站   美女   cookie 123
    - cookie 123   记录123 美女 
    - cookie 123   记录123 美女 
    - cookie 123   记录123 美女 
    - 推广 美女居多       体育
  - 和缓存相关的请求头，后面说。
- 空行
- 第三部分：请求正文（请求主体）
  - 一般是利用post方法进行请求时，会含有请求主体信息





HTTP响应报文：

- 第一部分：响应行（起始行）
  - 200 表示状态码，常用状态码分类：
    - 1xx:  提供信息（需要客户端提供信息）
    - 2xx:请求成功提交，并能够正确的处理请求
    - 3xx:客户端被重定向到其它资源
    - 4xx:请求包含某种错误，说白了，就是客户端请求异常，显示错误页面  404
    - 5xx:服务器执行请求时遇到错误，说白了，就是服务器响应异常，需要检查服务器代码
  - 需要掌握的：
    - 100  Continue：表示服务端收到了客户端的请求信息（POST），但是没有收到请求主体信息
    - 200 OK: 本状态码表示已成功提交请求，且响应主体中包含请求结果。
    - 201 Created: 客户端进行PUT请求时，有数据文件上传到服务端成功后，会响应201状态码信息
    - 301 Moved Permanently：本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。
    - 302 Found 本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL.
    - 304 Not Modified。     本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与工If-None-Match消息头确定客户端是否拥有最新版本的资源。
    - 401 Unauthorized 服务器在许可请求前要求HTTP进行身份验证。WWW-Authenticate消息头详细说明所支持的身份验证类型。
    - 403 Forbidden 本状态码指出，不管是否通过身份验证，禁止任何人访问被请求的资源。
    - 404 Not Found。 本状态码表示所请求的资源并不存在。
    - 405 Method Not Allowed	本状态码表示指定的URL不支持请求中使用的方法。例如，如果试图在不支持PUT方法的地方使用该方法，就会收到本状态码。服务端做了请求方法限制.
    - 500 Internal Server Error	本状态码表示服务器在执行请求时遇到错误。当提交无法预料的输人、在应用程序处理过程中造成无法处理的错误时，通常会收到本状态码。应该仔细检查服务器响应的所有内容，了解与错误性质有关的详情。
    - 503 Service Unavailable。	通常，本状态码表示尽管Web服务器运转正常.并且能够响应请求，但服务器访问的应用程序还是无法作出响应。应该进行核实，是否因为执行了某种行为而造成这个结果。
- 第二部分：响应头
  - 有一堆的响应头，和请求头，一样，也是需要我们学掌握
- 第三部分：响应主体（响应体，服务器给你响应回来的数据）
  - 就是服务器正儿八经返回回来的数据



HTTP是基于TCP通信协议来传递数据。通过一个可靠的连接来交换信息。在交换信息之前，客户端和服务器之间需要有规则。

**HTTP通信包含两部分**

* HTTP请求 Request
* HTTP响应 Response

![1696726003692](./assets/1696726003692.png)

在HTTP请求和HTTP响应中，都包含了HTTP报文，报文也是一块数据，在客户端与服务器之间发送的数据块。这些报文也是在客户端与服务器之间流行。所以HTTP报文也叫报文流。

**HTTP请求报文组成部分**

* 对报文进行描述的起始行
* HTTP各种头（header），也叫http报文头，不同的头含义是不一样的
* 请求体（请求正文）（可选的），就是客户端给服务器的数据

![1696726035558](./assets/1696726035558.png)

**HTTP响应报文组成部分**

* 响应行（起始行） HTTP/1.0 200表示状态码 OK叫状态描述符
* 响应头 header
* 响应体 服务器给客户端响应的数据

![1696726051121](./assets/1696726051121.png)

### 17，postman的使用



### 18，HTTP协议版本

**HTTP/0.9**

1. 仅支持GET请求
2. 仅能请求HTML资源
3. 发布于1991年

**HTTP/1.0**

1. 增加了POST请求和HEAD请求
2. 支持多种数据格式的请求和访问
3. 添加了缓存的功能
4. 增加了状态码，内容编码
5. 浏览器的每次请求都需要与服务器建立一个TCP连接，请求处理完成后立即断开TCP连接，每次建立连接增加了性能损耗
6. 也就是说早期的HTTP1.0是不支持长连接（持久化连接）的，只支持串行连接
7. 后期的HTTP1.0添加了Connection:keep-alive字段，开始支持持久化连接
8. 发布于1996年

**HTTP/1.1(目前使用最广泛的版本)**

1. 采用持久连接(Connection: keep-alive)，多个请求可以共用同一个TCP连接
2. 增加PUT/PATC/OPTION/DELETE等请求方式
3. 增加了host字段，指定服务器域名
4. 增加了100状态码，支持只发送头信息
5. 支持内容传递，只传递一部分和文件断点继传
6. 发布于1997年；

**HTTP/2.0**

1. 增加了双工模式 客户端同时发送N个请求，服务器同时处理N个请求
2. 服务器推送 服务器可以主动推送数据给客户端
3. 发布于2015年



HTTP协议版本总结：

- HTTP1.0  属于短链接      一次连接对应一次请求
- HTTP1.1  属于长链接      一次连接对应多次请求
- HTTP2.0  可以实现并发请求处理   适合电商网站





### 19，HTTP的请求方式

**GET**：GET 方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。
**HEAD**：HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。比如在准备下载一个文件前，先获取文件的大小，再决定是否进行下载；
**POST**：POST 方法用于将实体提交到指定的资源。
**PUT**：PUT 方法用请求有效载荷（payload）替换目标资源的所有当前表示；
**DELETE**：DELETE 方法删除指定的资源；
**PATCH**：PATCH 方法用于对资源应部分修改；
**CONNECT**：CONNECT 方法建立一个到目标资源标识的服务器的隧道，通常用在代理服务器，网页开发很少用到。
**TRACE**：TRACE 方法沿着到目标资源的路径执行一个消息环回测试。

**在开发中使用最多的是GET、POST请求**

* GET主要是用来获取数据
* GET也可以传递数据给服务器，通过查询字符串，就是在URL中把数据扔给服务器
* POST可以对数据进行添加，删除，修改，数据是放在FormData

**GET和POST区别（面试题）**

* post更安全：get请求是把数据放在url，每个人都可以看到，相对来说，不安全。
* get请求，数据放在url，url的长度是有限，get请求传递给服务器的数据大小是有限的
* post请求，传递给服务器的数据理论上来说是无限的
* get请求只能发送ASCII字符数据，post请求能发送更多的数据类型
* post比get速度慢，post接收数据之前会先将请求头发送给服务器确认，然后发送数据
* get请求会进行数据缓存，post没有

**GET过程**

1. 第三次握手，浏览器确认并发送请求头和数据
2. 服务器返回200 OK响应

**POST过程**

1. 第三次握手，浏览器确认并发送post请求头
2. 服务器返回状态码100后，continue响应
3. 浏览器开始扔数据到服务器
4. 服务器返回200 OK响应



请求方式总结：

- GET请求：最最最最常用的请求，它的主要作用是从Web服务器获取一个资源。也可以把数据扔给服务器，但是不能通过请求正文扔给服务器，需要通过url把数据扔给服务器。浏览器地址栏中写的url，发出的请求都是get请求。在html标签中写的标签，有些标签也是会发请求，这些请求也是get请求。还有一些发get请求的方式，后面说。

  ```
  http://8.148.23.9/myblog/index.html?username=malu&pwd=123
  
  ?username=malu&pwd=123 叫查询字符串，就是传递给服务器的数据，服务器需要接收这些数据
  ```

- POST：表示客户端有信息需要提交给服务端时，使用的方法。

- HEAD： 和GET方法相似，不同之处在于服务器不会在其响应中返回消息主体。

- OPTIONS:  这种方法要求服务器报告对某一特殊资源有效的HTTP方法; 显示出服务端允许的请求方法。

- PUT：这个方法试图使用包含在请求主体中的内容，向服务器上传指定的资源；可以实现将本地数据资源上传到服务器端

- DELETE：删除服务器上的某个资源。







### 20，Request Header

**在request对象的header中也包含很多有用的信息，客户端会默认传递过来一些信息**

![1696726215106](./assets/1696726215106.png)

**content-type是这次请求携带的数据的类型**

* application/x-www-form-urlencoded：表示数据被编码成以 '&' 分隔的键 - 值对，同时以 '=' 分隔键和值
* application/json：表示是一个json类型；
* text/plain：表示是文本类型；
* application/xml：表示是xml类型；
* multipart/form-data：表示是上传文件；

**content-length**

* 文件的大小长度

**keep-alive**

* http是基于TCP协议的，但是通常在进行一次请求和响应结束后会立刻中断
* 在http1.0中，如果想要继续保持连接
  + 浏览器需要在请求头中添加 connection: keep-alive
  + 服务器需要在响应头中添加 connection:keey-alive
  + 当客户端再次放请求时，就会使用同一个连接，直接一方中断连接
* 在http1.1中，所有连接默认是 connection: keep-alive的
  + 不同的Web服务器会有不同的保持 keep-alive的时间
  + Node中默认是5s中

**accept-encoding**

* 告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip编码，对应 .gz文件

**accept**

* 告知服务器，客户端可接受文件的格式类型

**user-agent**

* 客户端相关的信息

**罗列常见的请求头：**

|       Header        |                             解释                             |                             示例                             |
| :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|       Accept        |                 指定客户端能够接收的内容类型                 |                Accept: text/plain, text/html                 |
|   Accept-Charset    |                 浏览器可以接受的字符编码集。                 |                  Accept-Charset: iso-8859-5                  |
|   Accept-Encoding   |    指定浏览器可以支持的 web 服务器返回内容压缩编码类型。     |               Accept-Encoding: compress, gzip                |
|   Accept-Language   |                      浏览器可接受的语言                      |                   Accept-Language: en, zh                    |
|    Accept-Ranges    |           可以请求网页实体的一个或者多个子范围字段           |                     Accept-Ranges: bytes                     |
|    Authorization    |                     HTTP 授权的授权证书                      |      Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==       |
|    Cache-Control    |                 指定请求和响应遵循的缓存机制                 |                   Cache-Control: no-cache                    |
|     Connection      |     表示是否需要持久连接。（HTTP 1.1 默认进行持久连接）      |                      Connection: close                       |
|       Cookie        | HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器。 |                Cookie: $Version=1; Skin=new; |
|   Content-Length    |                        请求的内容长度                        |                     Content-Length: 348                      |
|    Content-Type     |                 请求的与实体对应的 MIME 信息                 |       Content-Type: application/x-www-form-urlencoded        |
|        Date         |                     请求发送的日期和时间                     |             Date: Tue, 15 Nov 2010 08:12:31 GMT              |
|       Expect        |                    请求的特定的服务器行为                    |                     Expect: 100-continue                     |
|        From         |                    发出请求的用户的 Email                    |        [From: user@email.com](mailto:user@email.com)         |
|        Host         |                指定请求的服务器的域名和端口号                | [Host: www.zcmhi.com(opens new window)](http://www.zcmhi.com/) |
|      If-Match       |                只有请求内容与实体相匹配才有效                |         If-Match: “737060cd8c284d8af7ad3082f209582d”         |
|  If-Modified-Since  | 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码 |       If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT       |
|    If-None-Match    | 如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变 |      If-None-Match: “737060cd8c284d8af7ad3082f209582d”       |
|      If-Range       | 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag |         If-Range: “737060cd8c284d8af7ad3082f209582d”         |
| If-Unmodified-Since |           只在实体在指定时间之后未被修改才请求成功           |      If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT      |

### 21，Response Header

**响应的header中包括一些服务器给客户端的信息**

![1696726323439](./assets/1696726323439.png)

**HTTP Responses Header 响应头**

|       Header        |                             解释                             |                             示例                             |
| :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    Max-Forwards     |               限制信息通过代理和网关传送的时间               |                       Max-Forwards: 10                       |
|       Pragma        |                    用来包含实现特定的指令                    |                       Pragma: no-cache                       |
| Proxy-Authorization |                     连接到代理的授权证书                     |   Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==    |
|        Range        |                 只请求实体的一部分，指定范围                 |                     Range: bytes=500-999                     |
|       Referer       |         先前网页的地址，当前请求网页紧随其后, 即来路         | [Referer: http://www.zcmhi.com/archives/71.html(opens new window)](http://www.zcmhi.com/archives/71.html) |
|         TE          |   客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息   |                 TE: trailers, deflate; q=0.5                 |
|       Upgrade       |    向服务器指定某种传输协议以便服务器进行转换（如果支持）    |        Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11        |
|     User-Agent      |           User-Agent 的内容包含发出请求的用户信息            |             User-Agent: Mozilla/5.0 (Linux; X11)             |
|         Via         |            通知中间网关或代理服务器地址，通信协议            |         Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)          |
|       Warning       |                    关于消息实体的警告信息                    |               Warn: 199 Miscellaneous warning                |
|       Header        |                             解释                             |                             示例                             |
|    Accept-Ranges    |      表明服务器是否支持指定范围请求及哪种类型的分段请求      |                     Accept-Ranges: bytes                     |
|         Age         |     从原始服务器到代理缓存形成的估算时间（以秒计，非负）     |                           Age: 12                            |
|        Allow        |        对某网络资源的有效的请求行为，不允许则返回 405        |                       Allow: GET, HEAD                       |
|    Cache-Control    |           告诉所有的缓存机制是否可以缓存及哪种类型           |                   Cache-Control: no-cache                    |
|  Content-Encoding   |            web 服务器支持的返回内容压缩编码类型。            |                    Content-Encoding: gzip                    |
|  Content-Language   |                         响应体的语言                         |                   Content-Language: en, zh                   |
|   Content-Length    |                         响应体的长度                         |                     Content-Length: 348                      |
|       Header        |                             解释                             |                             示例                             |
|  Content-Location   |                请求资源可替代的备用的另一地址                |                 Content-Location: /index.htm                 |
|     Content-MD5     |                    返回资源的 MD5 校验值                     |            Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==             |
|    Content-Range    |                在整个返回体中本部分的字节位置                |            Content-Range: bytes 21010-47021/47022            |
|    Content-Type     |                     返回内容的 MIME 类型                     |            Content-Type: text/html; charset=utf-8            |
|        Date         |                   原始服务器消息发出的时间                   |             Date: Tue, 15 Nov 2010 08:12:31 GMT              |
|        ETag         |                  请求变量的实体标签的当前值                  |           ETag: “737060cd8c284d8af7ad3082f209582d”           |
|       Expires       |                     响应过期的日期和时间                     |            Expires: Thu, 01 Dec 2010 16:00:00 GMT            |
|    Last-Modified    |                    请求资源的最后修改时间                    |         Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT         |
|      Location       | 用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源  | [Location: http://www.zcmhi.com/archives/94.html(opens new window)](http://www.zcmhi.com/archives/94.html) |
|       Pragma        |      包括实现特定的指令，它可应用到响应链上的任何接收方      |                       Pragma: no-cache                       |
| Proxy-Authenticate  |        它指出认证方案和可应用到代理的该 URL 上的参数         |                  Proxy-Authenticate: Basic                   |
|       refresh       | 应用于重定向或一个新的资源被创造，在 5 秒之后重定向（由网景提出，被大部分浏览器支持） | [Refresh: 5; url= http://www.zcmhi.com/archives/94.html(opens new window)](http://www.zcmhi.com/archives/94.html) |
|     Retry-After     |     如果实体暂时不可取，通知客户端在指定时间之后再次尝试     |                       Retry-After: 120                       |
|       Server        |                      web 服务器软件名称                      |         Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)         |
|     Set-Cookie      |                       设置 Http Cookie                       |     Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1      |
|       Trailer       |               指出头域在分块传输编码的尾部存在               |                    Trailer: Max-Forwards                     |
|  Transfer-Encoding  |                         文件传输编码                         |                  Transfer-Encoding:chunked                   |
|        Vary         |        告诉下游代理是使用缓存响应还是从原始服务器请求        |                           Vary: *                            |
|         Via         |              告知代理客户端响应是通过哪里发送的              |         Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)          |
|       Warning       |                    警告实体可能存在的问题                    |              Warning: 199 Miscellaneous warning              |
|       Header        |                             解释                             |                             示例                             |
|  WWW-Authenticate   |             表明客户端请求实体应该使用的授权方案             |                   WWW-Authenticate: Basic                    |

### 22， Response响应状态码

* Http状态码（Http Status Code）是用来表示Http响应状态的数字代码
* Http状态码非常多，可以根据不同的情况，给客户端返回不同的状态码
* MDN响应码解析地址：https://developer.mozilla.org/zh-CN/docs/web/http/status

![1696726379391](./assets/1696726379391.png)

**HTTP状态码列表:**

| 状态码  | 状态码英文名称                      | 中文描述                                                     |
| ------- | ----------------------------------- | ------------------------------------------------------------ |
| **100** | **Continue**                        | **继续。**[客户端 (opens new window)](http://www.dreamdu.com/webbuild/client_vs_server/)**应继续其请求** |
| **101** | **Switching Protocols**             | **切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议** |
|         |                                     |                                                              |
| **200** | **OK**                              | **请求成功。一般用于GET与POST请求**                          |
| **201** | **Created**                         | **已创建。成功请求并创建了新的资源**                         |
| **202** | **Accepted**                        | **已接受。已经接受请求，但未处理完成**                       |
| **203** | **Non-Authoritative Information**   | **非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本** |
| **204** | **No Content**                      | **无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档** |
| **205** | **Reset Content**                   | **重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域** |
| **206** | **Partial Content**                 | **部分内容。服务器成功处理了部分GET请求**                    |
|         |                                     |                                                              |
| **300** | **Multiple Choices**                | **多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择** |
| **301** | **Moved Permanently**               | **永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替** |
| **302** | **Found**                           | **临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI** |
| **303** | **See Other**                       | **查看其它地址。与301类似。使用GET和POST请求查看**           |
| **304** | **Not Modified**                    | **未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源** |
| **305** | **Use Proxy**                       | **使用代理。所请求的资源必须通过代理访问**                   |
| **306** | **Unused**                          | **已经被废弃的HTTP状态码**                                   |
| **307** | **Temporary Redirect**              | **临时重定向。与302类似。使用GET请求重定向**                 |
|         |                                     |                                                              |
| **400** | **Bad Request**                     | **客户端请求的语法错误，服务器无法理解**                     |
| **401** | **Unauthorized**                    | **请求要求用户的身份认证**                                   |
| **402** | **Payment Required**                | **保留，将来使用**                                           |
| **403** | **Forbidden**                       | **服务器理解请求客户端的请求，但是拒绝执行此请求**           |
| **404** | **Not Found**                       | **服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面** |
| **405** | **Method Not Allowed**              | **客户端请求中的方法被禁止**                                 |
| **406** | **Not Acceptable**                  | **服务器无法根据客户端请求的内容特性完成请求**               |
| **407** | **Proxy Authentication Required**   | **请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权** |
| **408** | **Request Time-out**                | **服务器等待客户端发送的请求时间过长，超时**                 |
| **409** | **Conflict**                        | **服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突** |
| **410** | **Gone**                            | **客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置** |
| **411** | **Length Required**                 | **服务器无法处理客户端发送的不带Content-Length的请求信息**   |
| **412** | **Precondition Failed**             | **客户端请求信息的先决条件错误**                             |
| **413** | **Request Entity Too Large**        | **由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息** |
| **414** | **Request-URI Too Large**           | **请求的URI过长（URI通常为网址），服务器无法处理**           |
| **415** | **Unsupported Media Type**          | **服务器无法处理请求附带的媒体格式**                         |
| **416** | **Requested range not satisfiable** | **客户端请求的范围无效**                                     |
| **417** | **Expectation Failed**              | **服务器无法满足Expect的请求头信息**                         |
|         |                                     |                                                              |
| **500** | **Internal Server Error**           | **服务器内部错误，无法完成请求**                             |
| **501** | **Not Implemented**                 | **服务器不支持请求的功能，无法完成请求**                     |
| **502** | **Bad Gateway**                     | **充当网关或代理的服务器，从远端服务器接收到了一个无效的请求** |
| **503** | **Service Unavailable**             | **由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中** |
| **504** | **Gateway Time-out**                | **充当网关或代理的服务器，未及时从远端服务器获取请求**       |
| **505** | **HTTP Version not supported**      | **服务器不支持请求的HTTP协议的版本，无法完成处理**           |

### 23，同源策略

**同源策略：Same Origin Policy SOP 是浏览器的策略**

* 同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是浏览器的一种安全策略
* 规定：只允许两个页面有相同的源时，一个页面才可以去访问另一个页面中的数据。
* 源：说白了，就是指域名 相同的源指的是有相同的域名
* 换句话说，jd.com不能去获取taobao.com下面的数据

有一个这样的域名：http://www.wangcai.com

* http://zhidao.wangcai.com       不同源
* http://www.wangcai.com:8080       不同源
* https://www.wangcai.com       不同源
* http://www.wangcai.com/phone/index.html       同源
* http://www.wangcai.com/phone/huawei/index.html       同源

**总结**

* 源：协议 + 域名 + 端口
* 同源：相同的协议 && 相同域名 && 相同的端口
* 不同源：不同的协议 || 不同的域名 || 不同的端口

**不受同源策略的限制**

* 资源的引入 如：img标签的src link标签的href script标签的src
* 页面中的超连接 a标签中的href
* 表单的提交
* 重定向页面



### 24，开源接口

如果请求的url，得到的是一个json数据，通常这个url叫API接口。



开源接口：

    https://docs.tenapi.cn/
    https://www.free-api.com/
    https://api.aa1.cn/



### 25，宝塔的使用

准备一个服务器：

![1721611503750](./assets/1721611503750.png)



下载宝塔：

![1721611523807](./assets/1721611523807.png)



把宝塔扔到服务器上：

![1721611556550](./assets/1721611556550.png)



双击安装，也是傻瓜式安装：

![1721611588047](./assets/1721611588047.png)



尝试连接：

![1721611733201](./assets/1721611733201.png)

![1721611705741](./assets/1721611705741.png)





放到8888端口：

![1721611836688](./assets/1721611836688.png)



再次尝试访问：

![1721611867601](./assets/1721611867601.png)

![1721611896041](./assets/1721611896041.png)



需要大家注册一个宝塔账号，在面板中进行绑定，如下：

![1721612289635](./assets/1721612289635.png)



常用的设置：

![1721612504169](./assets/1721612504169.png)



在宝塔中放开某个端口：

![1721612653124](./assets/1721612653124.png)



安装软件：

![1721612754007](./assets/1721612754007.png)



![1721612813180](./assets/1721612813180.png)



在物理上机，连接mysql，创建数据库：

![1721613247467](./assets/1721613247467.png)

![1721613311418](./assets/1721613311418.png)







通过宝塔云部署一个项目：

![1721613425307](./assets/1721613425307.png)

![1721613520085](./assets/1721613520085.png)



在上传网站源码之前，还需要做一些配置，如下：

![1721613596997](./assets/1721613596997.png)

![1721613648504](./assets/1721613648504.png)

![1721613702811](./assets/1721613702811.png)



.....





### 26，BP抓包

下载软件：

![1721618182976](./assets/1721618182976.png)



解压：

![1721618272194](./assets/1721618272194.png)

点击`运行.bat`，如下：

![1721618421597](./assets/1721618421597.png)



然后出现如下界面，先不要动：

![1721618453383](./assets/1721618453383.png)



生成秘钥：

![1721618486541](./assets/1721618486541.png)

![1721618540072](./assets/1721618540072.png)





把秘钥copy到如下的界面中：

![1721618611810](./assets/1721618611810.png)



点击下一个：

![1721618646954](./assets/1721618646954.png)



点击手动激活：

![1721618721396](./assets/1721618721396.png)



![1721618756773](./assets/1721618756773.png)



继续操作：

![1721618800110](./assets/1721618800110.png)



![1721618834376](./assets/1721618834376.png)



点击下一个，成功安装：

![1721618851528](./assets/1721618851528.png)



到此，这个软件就安装成功了。点击运行，如下：

![1721618968924](./assets/1721618968924.png)

![1721618981468](./assets/1721618981468.png)

![1721619100381](./assets/1721619100381.png)



配置浏览器要走代理：

![1721619165303](./assets/1721619165303.png)

![1721619191040](./assets/1721619191040.png)

![1721619232505](./assets/1721619232505.png)



到此，浏览器发的请求，都要走代理，如下：

![1721619585158](./assets/1721619585158.png)



但是https不行，如下：

![1721619628594](./assets/1721619628594.png)



BP生成证书，如下：

![1721619741406](./assets/1721619741406.png)

![1721619775995](./assets/1721619775995.png)

![1721619811209](./assets/1721619811209.png)



![1721619830348](./assets/1721619830348.png)





在浏览器中加载这个证书：

![1721619879468](./assets/1721619879468.png)

![1721619891695](./assets/1721619891695.png)

![1721619986195](./assets/1721619986195.png)



再次测试https请求：

![1721620349418](./assets/1721620349418.png)





































