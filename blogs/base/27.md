---
title: 27-手写Promise
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

##  一，手写Promise



### 1，实现constructor

new Promise可以创建一个Promise对象，这个对象身上有很多方法（实例方法）：

- then
- catch
- finally



Promise本身也有一些方法，类方法(静态方法)：

- Promise.resolve
- Promise.reject
- Promise.all
- Promise.allSetteld
- Promise.race
- Promise.any



开始实现promise，如下：

![1713337564034](./assets/1713337564034.png)

```html
<script src="./mypromise.js"></script>
<script>
    // 改变promise状态有三种方式
    //   1）resolve  
    //   2）reject
    //   3）报错了
    let p = new MyPromise((resolve,reject)=>{
        console.log("执行器....")
        // resolve("包包")
        // reject("没钱")

        // 执行器中报错了，promise也会失败
        console.log(aaa)
        // throw new Error("xxx")
    });
    console.log(p)
    // console.log(p.#a) // 得不到私有属性的
    // console.log(p.#state) // 得不到私有属性的
</script>
```

```js
// IIFE
//    写类：class  fun
; (function (window) {
    // console.log('mypromise...');
    class MyPromise {
        // Private field 私有属性
        // #a = 1;
        #state = 'pendding';
        #result;  // 保存要么是成功的结果，要么是失败的结果
        constructor(exector) {
            // console.log("constructor...",exector)

            // 把等待的promise变成成功
            const changeResolved = (value) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
            };

            // 把等待的promise变成失败
            const changeRejected = (reason) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
            };

            try{
                exector(changeResolved,changeRejected);
            }catch(error){
                // this.#state = 'rejected';
                // this.#result = error;
                changeRejected(error);
            }
        }
    }
    window.MyPromise = MyPromise;
})(window);
```



### 2，then方法传入回调函数

需要等到promise的状态发生变化了，再去调用then中两个回调函数中的其中一个。

```html
<script src="./mypromise.js"></script>
<script>
    let p = new MyPromise((resolve,reject)=>{
        console.log("执行器....")
        // resolve("包包")
        // reject("没钱")

        // 执行器中报错了，promise也会失败
        // console.log(aaa)
        // throw new Error("xxx")

        setTimeout(()=>{
            // resolve("包包")
            reject("没钱")
        },1000)
    });
    // console.log(p)

    // then方法中传递了两个函数
    p.then(value=>{
        console.log("value:",value)
    }, reason=>{
        console.log("reason:",reason)
    });

</script>
```

```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;  
        #callbackObj = {};

        constructor(exector) {
            const changeResolved = (value) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
                // if(this.#callbackObj.onResolved){
                //     this.#callbackObj.onResolved?.(value)
                // }
                // 等到状态发生变化了,再去调用then中的回调函数
                this.#callbackObj.onResolved?.(value)
            };

            const changeRejected = (reason) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
                this.#callbackObj.onRejected?.(reason)
            };

            try{
                exector(changeResolved,changeRejected);
            }catch(error){
                changeRejected(error);
            }
        }
        then(onResolved, onRejected){
            if (this.#state === 'fulfilled') {
                onResolved(this.#result)
            }else if (this.#state === 'rejected') { 
                onRejected(this.#result)
            }else{
               this.#callbackObj = {
                onResolved,
                onRejected
               }
            }
        }
    }
    window.MyPromise = MyPromise;
})(window);
```



### 3，存储多个then中的回调

看如下代码：

```html
<script src="./mypromise.js"></script>
<script>
    let p = new MyPromise((resolve,reject)=>{
        console.log("执行器....")
        // resolve("包包")
        // reject("没钱")

        // 执行器中报错了，promise也会失败
        // console.log(aaa)
        // throw new Error("xxx")

        setTimeout(()=>{
            resolve("包包")
            // reject("没钱")
        },1000)
    });
    // console.log(p)

    // then方法中传递了两个函数
    p.then(value=>{
        console.log("value1:",value)
    }, reason=>{
        console.log("reason1:",reason)
    });
    p.then(value=>{
        console.log("value2:",value)
    }, reason=>{
        console.log("reason2:",reason)
    });
    p.then(value=>{
        console.log("value3:",value)
    }, reason=>{
        console.log("reason3:",reason)
    });

</script>
```



p.then了多次，把每一次中的回调都要存储起来。当状态发生变化时，需要把每一个回调函数取出来执行，如下：

```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;  
        #callbackList = [];

        constructor(exector) {
            const changeResolved = (value) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
                // if(this.#callbackObj.onResolved){
                //     this.#callbackObj.onResolved?.(value)
                // }
                // 等到状态发生变化了,再去调用then中的回调函数
                // this.#callbackObj.onResolved?.(value)
                this.#callbackList.forEach(callback => {
                    callback.onResolved(value);
                });
            };

            const changeRejected = (reason) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
                // this.#callbackObj.onRejected?.(reason)
                this.#callbackList.forEach(callback => {
                    callback.onRejected(reason);
                });
            };

            try{
                exector(changeResolved,changeRejected);
            }catch(error){
                changeRejected(error);
            }
        }
        then(onResolved, onRejected){
            if (this.#state === 'fulfilled') {
                onResolved(this.#result)
            }else if (this.#state === 'rejected') { 
                onRejected(this.#result)
            }else{
               this.#callbackList.push({
                    onResolved,
                    onRejected
               })
            }
        }
    }
    window.MyPromise = MyPromise;
})(window);
```



还有一个小问题，如下：

```html
<script src="./mypromise.js"></script>
<script>
    let p = new MyPromise((resolve,reject)=>{
        resolve("包包")
        // reject("没钱")

        // 执行器中报错了，promise也会失败
        // console.log(aaa)
        // throw new Error("xxx")

        // setTimeout(()=>{
        //     resolve("包包")
        //     // reject("没钱")
        // },1000)
    });
    // console.log(p)

    // then方法中传递了两个函数
    // 同步代码和异步代码:
    //    异步代码:
    //       1)定时器中的回调
    //       2)发ajax请求
    //       3)then中的回调函数
    p.then(value=>{
        console.log("value1:",value)
    }, reason=>{
        console.log("reason1:",reason)
    });

    // 代码执行时是,先执行同步代码,再执行异步代码
    console.log("malu")

</script>
```



说白了，then中的两个回调函数是异步代码。完善MyPromise，如下：

```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;  
        #callbackList = [];

        constructor(exector) {
            const changeResolved = (value) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
                // if(this.#callbackObj.onResolved){
                //     this.#callbackObj.onResolved?.(value)
                // }
                // 等到状态发生变化了,再去调用then中的回调函数
                // this.#callbackObj.onResolved?.(value)
                this.#callbackList.forEach(callback => {
                    callback.onResolved(value);
                });
            };

            const changeRejected = (reason) => {
                if(this.#state !== 'pendding'){
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
                // this.#callbackObj.onRejected?.(reason)
                this.#callbackList.forEach(callback => {
                    callback.onRejected(reason);
                });
            };

            try{
                exector(changeResolved,changeRejected);
            }catch(error){
                changeRejected(error);
            }
        }
        then(onResolved, onRejected){
            if (this.#state === 'fulfilled') {
                setTimeout(()=>{
                    onResolved(this.#result)
                })
            }else if (this.#state === 'rejected') { 
                setTimeout(()=>{
                    onRejected(this.#result)
                })
            }else{
               this.#callbackList.push({
                    onResolved,
                    onRejected
               })
            }
        }
    }
    window.MyPromise = MyPromise;
})(window);
```



### 5，then链



.then的返回值是一个新的promise，也就是说在then方法中，需要返回一个新的promise，直接实现如下：



```html
<script src="./mypromise.js"></script>
<script>
    let p = new MyPromise((resolve,reject)=>{
        resolve("包包")
        // reject("没钱")

        // 执行器中报错了，promise也会失败
        // console.log(aaa)
        // throw new Error("xxx")

        // setTimeout(()=>{
        //     resolve("包包")
        //     // reject("没钱")
        // },1000)
    });

    p.then(value1=>{
        console.log("value1:",value1)
        console.log(xxx)
        // return p1;
    }, reason1=>{
        console.log("reason1:",reason1)
        // return 123;
        // return p1
        // console.log(xxx)
    }).then(value2=>{
        console.log("value2:",value2)
    }, reason2=>{
        console.log("reason2:",reason2)
    });


</script>
```



```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;
        #callbackList = [];

        constructor(exector) {
            const changeResolved = (value) => {
                if (this.#state !== 'pendding') {
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
                this.#callbackList.forEach(callback => {
                    callback.onResolved(value);
                });
            };

            const changeRejected = (reason) => {
                if (this.#state !== 'pendding') {
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
                this.#callbackList.forEach(callback => {
                    callback.onRejected(reason);
                });
            };

            try {
                exector(changeResolved, changeRejected);
            } catch (error) {
                changeRejected(error);
            }
        }
        then(onResolved, onRejected) {
            return new MyPromise((resolve, reject) => {
                if (this.#state === 'fulfilled') {
                    setTimeout(() => {
                        try {
                            const res = onResolved(this.#result)
                            // res情况有：1）普通数据  2）promise  3)报错
                            if (res instanceof MyPromise) {
                                res.then(value=>{
                                    resolve(value);
                                },reason=>{
                                    reject(reason)
                                })
                            } else {
                                resolve(res)
                            }
                        }catch(error){
                            reject(error)
                        }
                    })
                } else if (this.#state === 'rejected') {
                    setTimeout(() => {
                        try {
                            const res = onRejected(this.#result)
                            // res情况有：1）普通数据  2）promise  3)报错
                            if (res instanceof MyPromise) {
                                res.then(value=>{
                                    resolve(value);
                                },reason=>{
                                    reject(reason)
                                })
                            } else {
                                resolve(res)
                            }
                        }catch(error){
                            reject(error)
                        }

                        
                    })
                } else {
                    this.#callbackList.push({
                        onResolved,
                        onRejected
                    })
                }
            })
        }
    }
    window.MyPromise = MyPromise;
})(window);
```

问题：

![1713345550202](./assets/1713345550202.png)



封装一个handler函数，如下：

```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;
        #callbackList = [];

        constructor(exector) {
            const changeResolved = (value) => {
                if (this.#state !== 'pendding') {
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
                this.#callbackList.forEach(callback => {
                    callback.onResolved(value);
                });
            };

            const changeRejected = (reason) => {
                if (this.#state !== 'pendding') {
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
                this.#callbackList.forEach(callback => {
                    callback.onRejected(reason);
                });
            };

            try {
                exector(changeResolved, changeRejected);
            } catch (error) {
                changeRejected(error);
            }
        }
        then(onResolved, onRejected) {
            return new MyPromise((resolve, reject) => {

                const handler = (cb) => {
                    try {
                        const res = cb(this.#result)
                        // res情况有：1）普通数据  2）promise  3)报错
                        if (res instanceof MyPromise) {
                            res.then(value => {
                                resolve(value);
                            }, reason => {
                                reject(reason)
                            })
                        } else {
                            resolve(res)
                        }
                    } catch (error) {
                        reject(error)
                    }
                }

                if (this.#state === 'fulfilled') {
                    setTimeout(() => {
                        handler(onResolved);
                    })
                } else if (this.#state === 'rejected') {
                    setTimeout(() => {
                        handler(onRejected);
                    })
                } else {
                    this.#callbackList.push({
                        onResolved:()=>{
                            handler(onResolved);
                        },
                        onRejected:()=>{
                            handler(onRejected);
                        },
                    })
                }
            })
        }
    }
    window.MyPromise = MyPromise;
})(window);
```



### 6，then方法参数的默认值



看如下的使用：

```html
<script src="./mypromise.js"></script>
<script>
    let p = new MyPromise((resolve,reject)=>{
        // resolve("包包")
        reject("没钱")

        // 执行器中报错了，promise也会失败
        // console.log(aaa)
        // throw new Error("xxx")

        // setTimeout(()=>{
        //     resolve("包包")
        //     // reject("没钱")
        // },1000)
    });

    p.then(value1=>{
        console.log("value1:",value1)
    }).then(null, reason2=>{
        console.log("reason2:",reason2)
    });
</script>
```



实现then的顺延，如下：

```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;
        #callbackList = [];

        constructor(exector) {
            const changeResolved = (value) => {
                if (this.#state !== 'pendding') {
                    return;
                }
                this.#state = 'fulfilled';
                this.#result = value;
                this.#callbackList.forEach(callback => {
                    callback.onResolved(value);
                });
            };

            const changeRejected = (reason) => {
                if (this.#state !== 'pendding') {
                    return;
                }
                this.#state = 'rejected';
                this.#result = reason;
                this.#callbackList.forEach(callback => {
                    callback.onRejected(reason);
                });
            };

            try {
                exector(changeResolved, changeRejected);
            } catch (error) {
                changeRejected(error);
            }
        }
        then(onResolved, onRejected) {
            // 实现then的顺延
            if (typeof onResolved !== 'function') {
                onResolved = value=>value;
            }
            if (typeof onRejected !== 'function') {
                onRejected = reason=>{
                    throw reason;
                }
            }
            return new MyPromise((resolve, reject) => {

                const handler = (cb) => {
                    try {
                        const res = cb(this.#result)
                        // res情况有：1）普通数据  2）promise  3)报错
                        if (res instanceof MyPromise) {
                            res.then(value => {
                                resolve(value);
                            }, reason => {
                                reject(reason)
                            })
                        } else {
                            resolve(res)
                        }
                    } catch (error) {
                        reject(error)
                    }
                }

                if (this.#state === 'fulfilled') {
                    setTimeout(() => {
                        handler(onResolved);
                    })
                } else if (this.#state === 'rejected') {
                    setTimeout(() => {
                        handler(onRejected);
                    })
                } else {
                    this.#callbackList.push({
                        onResolved:()=>{
                            handler(onResolved);
                        },
                        onRejected:()=>{
                            handler(onRejected);
                        },
                    })
                }
            })
        }
    }
    window.MyPromise = MyPromise;
})(window);
```





### 7，实现catch

catch本质还是then，实现如下：

```js
; (function (window) {
    class MyPromise {
        #state = 'pendding';
        #result;
        #callbackList = [];

        constructor(exector) {
			// ..... 
        }
        then(onResolved, onRejected) {
            // ..... 
        }
        catch(onRejected){
            return this.then(null, onRejected)
        }
    }
    window.MyPromise = MyPromise;
})(window);
```



使用之：

```html
<script src="./mypromise.js"></script>
<script>
    let p = new MyPromise((resolve,reject)=>{
        // resolve("包包")
        reject("没钱")

        // 执行器中报错了，promise也会失败
        // console.log(aaa)
        // throw new Error("xxx")

        // setTimeout(()=>{
        //     resolve("包包")
        //     // reject("没钱")
        // },1000)
    });

    p.then(value=>{
        console.log("value:",value)
    }).catch(reason=>{
        console.log("reason:",reason)
    });
</script>
```



### 8，静态方法resolve



### 9，静态方法reject



### 10，静态方法all



### 11，静态方法rece



















































