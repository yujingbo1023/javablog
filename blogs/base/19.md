---
title: 19-webpack5精讲
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 一. webpack5串讲



前面我们基于脚手架创建的项目，都是基于webpack。vue-element-admin也是基于webpack。学习webpack就是学习一堆的配置。



### 1，认识webpack

官网：https://webpack.js.org/

介绍：

![1689556596973](./assets/1689556596973.png)

我们之前写项目，使用的vue-element-admin也是基于webpack的，之前我们通过vue-cli创建的项目也是基于webpack的。今天我们需要自己去搭建开发环境，不使用官方提供的脚手架。

**总结：**

* webapck是一个构建工具，是基于node的，电脑上必须安装node，node版本需要大于16
* 打包器，是从入口开始，按照模块依赖进行打包，最终得到浏览器的可以识别的静态资源。
* 从某种程度来说，webpack代表的是一种架构能力。

### 2，搭建环境

创建一个文件夹，如下：

![1689556818827](./assets/1689556818827.png)

初始化一个配置文件，如下：

![1689556857734](./assets/1689556857734.png)

安装本次课程所需要的依赖，如下：

![1689556927232](./assets/1689556927232.png)

依赖如下：

```json
{
  "name": "react-webpack",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.22.1",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/plugin-proposal-decorators": "^7.22.3",
    "@babel/preset-env": "^7.22.4",
    "@babel/preset-react": "^7.22.3",
    "babel-loader": "^9.1.2",
    "css-loader": "^6.8.1",
    "eslint": "^8.41.0",
    "eslint-config-airbnb": "^19.0.4",
    "eslint-plugin-import": "^2.27.5",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-webpack-plugin": "^4.0.1",
    "file-loader": "^6.2.0",
    "html-webpack-plugin": "^5.5.1",
    "mini-css-extract-plugin": "^2.7.6",
    "sass": "^1.62.1",
    "sass-loader": "^13.3.1",
    "style-loader": "^3.3.3",
    "url-loader": "^4.1.1",
    "vue-loader": "^15.8.0",
    "vue-style-loader": "^4.1.3",
    "vue-template-compiler": "^2.7.14",
    "webpack": "^5.84.1",
    "webpack-cli": "^5.1.1",
    "webpack-dev-server": "^4.15.0"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "vue": "^2.7.14",
    "vue-loader-plugin": "^1.3.0",
    "webpack-merge": "^5.9.0"
  }
}
```

安装之，如下：

![1689556968568](./assets/1689556968568.png)

现在，就安装webpack，webpack-cli。webpack是核心包，提供了很多的API，插件。后面我们要用到这些API和插件。webpack-cli提供了很多命令。

我们有两种安装方式，第一种，全局安装, (不推荐)，全局安装相当它把当成一个工具进行安装了。如下：

* cnpm i webpack -g   （不需要操作）
* cnpm i webpack-cli -g   （不需要操作）

第二种，就是在项目中安装（推荐，刚开始全局安装过了），如下：

* cnpm i webpack -D     // -D表示开发依赖  
* cnpm i webpack-cli -D

测试你的webpack是否安装成功，如下：

![1689557210457](./assets/1689557210457.png)

学习webpack，就是学习一堆的配置，这些配置你也不需要记，官方说，你要配置，需要在项目的根目录下面创建一个webpack.config.js文件，如下：

![1689557305760](./assets/1689557305760.png)

![1689557440083](./assets/1689557440083.png)



代码如下：

```js
module.exports = {
  // 入口
  entry: "./src/main.js",
  // 出口
  output: {}
}

```





开始打包，如下：

![1689557677435](./assets/1689557677435.png)

看一下，打包后文件，如下：

![1689557705508](./assets/1689557705508.png)

现在指定mode，如下：

![1689557750637](./assets/1689557750637.png)

再次打包，如下：

![1689557788306](./assets/1689557788306.png)

再次看一下打包后的文件，如下：

![1689557824501](./assets/1689557824501.png)

需要webpack.config.js文件名变了，打包时，需要手动指定，如下：

![1689558135828](./assets/1689558135828.png)

![1689558226430](./assets/1689558226430.png)

还可以配置一个脚本，如下：

![1689558348940](./assets/1689558348940.png)

运行脚本，如下：

```js
cnpm run build
npm run build
```

需要通过yarn，是不需要run，直接yarn build就OK。

### 3，入口和出口

入口有三种写法，上面的是第一种写法，使用的是相对路径，也可以使用绝对路径，如下：

![1689558589392](./assets/1689558589392.png)

入口还可以写成对象的形式，如下：

![1689558699472](./assets/1689558699472.png)



配置代码如下：

```js
const path = require("path")

module.exports = {
  mode: "development", // 开发打包
  // 入口
  // entry: "./src/main.js",
  // entry: path.resolve(__dirname, "src/main.js"),  // 绝对路径
  entry: {
    // app表示你打包后的资源名字就是app
    app1: path.resolve(__dirname, "src/main.js"),  // 绝对路径
  },
  // 出口
  output: {}
}

```





看一上vue打包后资源如下：

![1689559049085](./assets/1689559049085.png)

然后指定出口，如下：

![1689559110772](./assets/1689559110772.png)

测试如下：

![1689559172535](./assets/1689559172535.png)

出口必须指定绝地路径，如下：

![1689559271641](./assets/1689559271641.png)

最好还是叫dist，有的地方，叫build，我们就叫dist。也可以在出口中指定打包后的文件叫什么，如下：

![1689559351116](./assets/1689559351116.png)

说一下单词，如下：

![1689559459841](./assets/1689559459841.png)

filename可以指定一个格式化字符串，可以指定hash值，如下：

![1689559711597](./assets/1689559711597.png)

说白了，输入的JS模块所依赖的源码发生了变化，打包时，hash值也会发生变化，用于解决浏览器缓存导致页面不刷新的问题。

能不能把打后的js文件，放到js文件夹下面的，可以的，如下：

![1689560828374](./assets/1689560828374.png)



配置代码：

```js
const path = require("path")

module.exports = {
  mode: "development", // 开发打包
  // 入口
  // entry: "./src/main.js",
  // entry: path.resolve(__dirname, "src/main.js"),  // 绝对路径
  entry: {
    // app表示你打包后的资源名字就是app
    app: path.resolve(__dirname, "src/main.js"),  // 绝对路径
  },
  // 出口
  output: {
    path: path.resolve(__dirname, "dist"),  // 绝对路径
    // filename:"bundle.js"  // 一捆  一束
    filename: "js/[name].[chunkhash:8].js"  // 一捆  一束
  }
}
```





### 4，配置开发服务器

前面打包是把包打包到硬盘上的。在开发时，需要配置一个开发服务器，这个开发服务器可以直接让我们在内存中打包，速度是远远高于硬盘的。我们之前用的脚手架，都是在内存中打开。

安装一个开发服务器，叫webpack-dev-server，如下：

![1689561199628](./assets/1689561199628.png)

安装之，如下：

![1689561310216](./assets/1689561310216.png)

配置之，如下：

![1689561388782](./assets/1689561388782.png)

之前打包是使用webpack进行打包的，直接是在硬盘上的打包，现在我们需要使用内存打，如下：

![1689561515497](./assets/1689561515497.png)

访问之，如下：

![1689561559668](./assets/1689561559668.png)

可以配置一个脚本，如下 ：

![1689561606083](./assets/1689561606083.png)

执行脚本，如下：

![1689561633029](./assets/1689561633029.png)

### 5，创建页面，把打包后的js插入页面

创建一个页面，如下：

![1689561812664](./assets/1689561812664.png)

我们在内存中打包，如下：

![1689561830083](./assets/1689561830083.png)

访问之，如下：

![1689561846785](./assets/1689561846785.png)

你要知道，你刚才是内存打包，在内存是有打包后的js文件的，能不能把打包的的js插入到上面的页面中呢？看一下，如下 ：

![1689561923186](./assets/1689561923186.png)

![1689561974964](./assets/1689561974964.png)

结论，并没有把打包后的js文件，插入到页面中，那个我们就使用一个插件，叫html-webpack-plugin，如下：

![1689562033766](./assets/1689562033766.png)

之前已经安装完了。

使用之，如下：

![1689562173603](./assets/1689562173603.png)

再次在内存中打包，如下：

![1689562207786](./assets/1689562207786.png)

测试之，如下：

![1689562237055](./assets/1689562237055.png)

![1689562246890](./assets/1689562246890.png)

![1689562300799](./assets/1689562300799.png)

在硬盘上打包试一下，如下：

![1689562360135](./assets/1689562360135.png)

![1689562347352](./assets/1689562347352.png)



配置代码：

```js
const path = require("path")
const HtmlWebpackPlugin = require("html-webpack-plugin")

module.exports = {
  mode: "development", // 开发打包
  // 入口
  // entry: "./src/main.js",
  // entry: path.resolve(__dirname, "src/main.js"),  // 绝对路径
  entry: {
    // app表示你打包后的资源名字就是app
    app: path.resolve(__dirname, "src/main.js"),  // 绝对路径
  },
  // 出口
  output: {
    path: path.resolve(__dirname, "dist"),  // 绝对路径
    // filename:"bundle.js"  // 一捆  一束
    filename: "js/[name].[chunkhash:8].js"  // 一捆  一束
  },
  // 配置开发服务器
  devServer: {
    port: 8080
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./public/index.html"
    })
  ]
}
```





再一下vue脚手架，如下：

![1689562404094](./assets/1689562404094.png)

### 6，区分硬盘打包和内存打包

打包分两种，一种是开发时的打包，一种是生产时的打包。不同的打包方式，是有不同的配置的，现在有两种打包方式，也就是说有两种配置，但是这两种配置中有一些公共的配置，把这些配置区分出来，创建如下的文件，如下：

![1689643001203](./assets/1689643001203.png)

先写公共的配置，如下：

![1689643200722](./assets/1689643200722.png)

开发配置，如下：

![1689643227901](./assets/1689643227901.png)

生产配置，如下：

![1689643261254](./assets/1689643261254.png)

在webpack.config.js中使用之，如下：

![1689643348518](./assets/1689643348518.png)

配置脚本，如下：

![1689643407786](./assets/1689643407786.png)

在webpack.config.js中就可以得到env，如下：

![1689643524563](./assets/1689643524563.png)

![1689643597965](./assets/1689643597965.png)

简写如下：

![1689643658290](./assets/1689643658290.png)

不能使用原生js合并，需要使用来合并，如下：

![1689643697497](./assets/1689643697497.png)

使用之，如下：

![1689643849347](./assets/1689643849347.png)

测试之，如下：

![1689643912076](./assets/1689643912076.png)

![1689643949815](./assets/1689643949815.png)

![1689643963694](./assets/1689643963694.png)

### 7，html-webpack-plugin

之前，在硬盘上打包，都会生成dist，下一次打包还会生成dist，但是之前dist下面的文件并不会自动删除，如果你想每一次打包都删除上次dist下面的文件，配置如下：

![1689644231152](./assets/1689644231152.png)

注意一点：如果源码没有变，打包后的app.xxxxxx.js也不会变，只有源码变了，才会生成新的文件。

接下来，讲webpack-html-plugin这个插件。看官网：

![1689644347748](./assets/1689644347748.png)

上午我们已经安装这了，并使用了。如下：

![1689644369097](./assets/1689644369097.png)

上面配置了template，是用来指定页面的位置，可以使用绝对路径，如下：

![1689644451027](./assets/1689644451027.png)

默认它把打包后js插入到了head标签中，打包查看如下：

![1689644473716](./assets/1689644473716.png)

![1689644494833](./assets/1689644494833.png)

配置把js文件插入到body结束标签之前，如下：

![1689644633596](./assets/1689644633596.png)

![1689644661437](./assets/1689644661437.png)

测试如下：

![1689644680721](./assets/1689644680721.png)

还可以做一些基本的配置，如下：

![1689644775400](./assets/1689644775400.png)

还需要在页面中title标签位置写如下代码：

![1689644824511](./assets/1689644824511.png)

重新打包，测试如下：

![1689644863510](./assets/1689644863510.png)

还可以配置一个小icon，制作一个icon，如下：

![1689644922947](./assets/1689644922947.png)

![1689644982083](./assets/1689644982083.png)

![1689645005917](./assets/1689645005917.png)

![1689645064929](./assets/1689645064929.png)

![1689645093280](./assets/1689645093280.png)

![1689645131251](./assets/1689645131251.png)

重新打包，测试之，如下：

![1689645293243](./assets/1689645293243.png)

### 8，ProgressPlugin

是webpack内置的插件，如下：

![1689645371034](./assets/1689645371034.png)

![1689645402101](./assets/1689645402101.png)

使用之，如下：

![1689645480383](./assets/1689645480383.png)

再次打包，如下：

![1689645507949](./assets/1689645507949.png)

配置hander，如下：

![1689645615270](./assets/1689645615270.png)

![1689645643749](./assets/1689645643749.png)

### 9，babel

在入口中写一点ES6+的代码如下：

![1689646658033](./assets/1689646658033.png)

![1689646766313](./assets/1689646766313.png)

打包，测试浏览器能不能识别，如下：

![1689646793025](./assets/1689646793025.png)

![1689646822845](./assets/1689646822845.png)

发现，谷歌浏览器可以识别。但是有的浏览器是不认识的。再一个更新的语法，如下：

![1689646894351](./assets/1689646894351.png)

在内存中打包，如果源码变了，会自动重新打包，如下：

![1689647093488](./assets/1689647093488.png)

![1689647147264](./assets/1689647147264.png)

也就是说，webapck对于ES6+中的一些语法，它也不能直接转化成ES5，不能转化成ES5，浏览器对ES5的兼容性是最好，我们需要使用loader，loader就是把webpack不能识别的模块，转化成webpack可以识别的模块。如下：

![1689647289197](./assets/1689647289197.png)

JS模块中有高级语法，高级语法，如何转化成低级语法，让webpack识别呢？

答：最最最最最厉害的就是babel。

要使用babel，就需要安装babel，如下：

![1689647329047](./assets/1689647329047.png)

![1689647369716](./assets/1689647369716.png)

安装之，如下：

![1689647484174](./assets/1689647484174.png)

配置配置，如下：

![1689647702545](./assets/1689647702545.png)

再次打包，如下：

![1689647809662](./assets/1689647809662.png)

ES6中的语法，非常多，你要转化语法，需要安装对应插件，如你要把箭头函数转化成普通函数，那你就需要安装一个箭头函数转普通函数的插件，如你要把let转化成var，你需要安装一把let转成var的插件。也就说如果项目中用到了非常多的ES6语法，都需要转化，那就可以安装500个插件，babel给我们封装了很多预设，预设是插件集合，也就是集合中包含了很多的插件，如有一个预设，它可以把ES6中的大部分语法，转化成ES5，这个预设叫@babel/preset-env。预设并不是转化所有语法，仅仅是大部分的，个别语法转化不了，需要单独安装插件。我们先去安装 预设，如下：

![1689648035852](./assets/1689648035852.png)

![1689648053585](./assets/1689648053585.png)

然后需要配置，如下：

![1689648221010](./assets/1689648221010.png)

再次打包，如下：

![1689648260530](./assets/1689648260530.png)

说明，你上面使用的预设不能打包装饰器，需要单独去安装对应的插件（打补丁），如下：

![1689648367001](./assets/1689648367001.png)

![1689648394157](./assets/1689648394157.png)

安装如下：

![1689648464154](./assets/1689648464154.png)

配置如下：

![1689648551355](./assets/1689648551355.png)

安装完后，打包如下：

![1689648559959](./assets/1689648559959.png)

![1689648574745](./assets/1689648574745.png)

后面我们需要学习一堆的loader，去转化不同的模块(使用loader来处理)。

* .js    
* .vue    vue-loader
* .jsx
* .ts
* .png
* .less
* .sass
* .css
* .json
* .....

后面我们也需要学习一堆的插件，插件是用来增强webpack。

### 10，打包JSX模块

react也是一个模块，如下：

![1689649472221](./assets/1689649472221.png)

看一下版本，如下 ：

![1689649493880](./assets/1689649493880.png)

安装之，还需要安装一个react-dom模块，如下：

![1689649514499](./assets/1689649514499.png)

创建一个App.jsx组件，如下：

![1689649641123](./assets/1689649641123.png)

在main.js中引入，并渲染，如下：

![1689728999690](./assets/1689728999690.png)

打包main.js，你要知道，main.js中引入了一个jsx模块，如下：

![1689649742395](./assets/1689649742395.png)

说明，webpack，默认情况下是不能处理jsx文件的，此时，就需要使用babel进行编译，说到babel就要想到预设和插件，此时，jsx就需要一个预设来处理，如下：

![1689649778428](./assets/1689649778428.png)

安装预设，如下：

![1689649799274](./assets/1689649799274.png)

进行配置，如下：

![1689649828057](./assets/1689649828057.png)

再进行打包，如下：

![1689649869339](./assets/1689649869339.png)

还需要配置一个loder，如下：

![1689649907330](./assets/1689649907330.png)

再次打包，如下：

![1689649927952](./assets/1689649927952.png)

重新查看访问之，如下：

![1689650244615](./assets/1689650244615.png)

到此，打包jsx（react中的组件）就OK了，你可以尝试打包一下vue文件，你就创建一个App.vue，尝试打包，100%打包不成功。因为webpack压根不认识.vue文件，你需要安装对应的loader和预设，使用loader加载你的.vue文件，使用预设去翻译你的vue代码。

### 11，配置source-map

先看一个问题，代码如下：

![1689729268836](./assets/1689729268836.png)

看一下控制台，如下：

![1689729471697](./assets/1689729471697.png)

如果想让代码的报错位置正确，需要配置一个devtool，如下：

![1689729522575](./assets/1689729522575.png)

![1689729578879](./assets/1689729578879.png)

不同的配置代表的含义是不一样的。配置如下：

![1689729650422](./assets/1689729650422.png)

此时报错的位置和控制台中就保持一样的了，如下：

![1689729710136](./assets/1689729710136.png)

在生产中，可以不去配置source-map，上线的也是打包后的代码，可以不配置，也可以配置 ：

![1689729787402](./assets/1689729787402.png)

在硬盘上打包，如下：

![1689729813277](./assets/1689729813277.png)

![1689729932231](./assets/1689729932231.png)

![1689729972981](./assets/1689729972981.png)

### 12，ProvidePlugin

分析：

![1689730228879](./assets/1689730228879.png)

![1689730249091](./assets/1689730249091.png)

如何把某些包放到全局中，此时需要使用ProvidePlugin，如下：

![1689730293539](./assets/1689730293539.png)

配置之，如下：

![1689730407483](./assets/1689730407483.png)

动了配置文件，需要重新打包，再去访问之，如下：

![1689730427361](./assets/1689730427361.png)

![1689730447605](./assets/1689730447605.png)

打包时，我们不希望webpack去打包node_module，配置如下：

![1689730536110](./assets/1689730536110.png)

### 13，把第三方包抽离出来

现在尝试去打包，如下：

![1689730584794](./assets/1689730584794.png)

分析之，如下：

![1689730856443](./assets/1689730856443.png)

你可以看一下，你之前，打包vue，生成的js文件，如下：

![1689730905192](./assets/1689730905192.png)

现在就需要把第三方包抽离出来，如下：

![1689731044763](./assets/1689731044763.png)

再次打包如下：

![1689731106070](./assets/1689731106070.png)

![1689731126299](./assets/1689731126299.png)

### 14，打包css和sass

写一点样式，如下：

![1689731271199](./assets/1689731271199.png)

在入口文件中，引入css文件，如下：

![1689731298201](./assets/1689731298201.png)

 不用想，webpack肯定不能加载css文件，肯定是需要一个loader进行加载的，测试如下：

![1689731343434](./assets/1689731343434.png)

此时，就需要安装对应的loader，如下：

![1689731442388](./assets/1689731442388.png)

对css模块处理，需要安装两个laoder，如下：

![1689731473009](./assets/1689731473009.png)

开始配置，如下：

![1689731624975](./assets/1689731624975.png)

看浏览器控制台：

![1689731635910](./assets/1689731635910.png)

![1689731673921](./assets/1689731673921.png)

在生产打包时，需要把css抽离出来，此时我们需要用到一个插件，这个插件中带了一个loader，安装一下：

![1689731757131](./assets/1689731757131.png)

![1689731770316](./assets/1689731770316.png)

之前安装过了，如下：

![1689731804162](./assets/1689731804162.png)

配置如下：

![1689731925158](./assets/1689731925158.png)

打包如下：

![1689731974812](./assets/1689731974812.png)

在内存中打包如下：

![1689732001004](./assets/1689732001004.png)

测试如下：

![1689732020710](./assets/1689732020710.png)

现在希望把打包后的样式放到css文件夹，并且加上hash值，解决缓存问题，如下：

![1689732146952](./assets/1689732146952.png)

打包如下：

![1689732112619](./assets/1689732112619.png)

测试如下 ：

![1689732185572](./assets/1689732185572.png)

也就是说，在开发时，样式，采用的是内部样式，在上线时，样式采用的是外部样式。

然后打包scss，创建scss文件，如下 ：

![1689732812471](./assets/1689732812471.png)

在入口文件中，引入，如下：

![1689732845642](./assets/1689732845642.png)

尝试打包，如下：

![1689732878916](./assets/1689732878916.png)

此时，就需要使用sass-loader来加载编译scss代码，安装如下：

![1689732904612](./assets/1689732904612.png)

配置如下：

![1689733027876](./assets/1689733027876.png)

看一下，是否可以处理scss代码，浏览器测试之，如下：

![1689733062784](./assets/1689733062784.png)

同理，如果是less也是一样的，需要使用less-loader来处理。

### 15，打包图片   

在webpack眼中，一切都是模块，图片当然也是模块。准备一张图片，如下：

![1689733146714](./assets/1689733146714.png)

在App组件中，使用图片，如下：

![1689733198499](./assets/1689733198499.png)

测试如下：

![1689733218277](./assets/1689733218277.png)

在webpack4中，有两个laoder可以处理，在wabpack5中这两个laoder就淘汰了，这两个laoder如下：

* url-loader
* file-loader

我们还是简单去演示一下，如何使用，安装之如下：

![1689733252898](./assets/1689733252898.png)

配置如下：

![1689733328475](./assets/1689733328475.png)

测试如下 ：

![1689733387771](./assets/1689733387771.png)

在硬盘上打包如下：

![1689733411557](./assets/1689733411557.png)

生成的文件如下：

![1689733435571](./assets/1689733435571.png)

使用url-loader再测试一下，url-loader比file-loader更强大，如下 ：

![1689733470881](./assets/1689733470881.png)

打包如下：

![1689733509161](./assets/1689733509161.png)

![1689733560361](./assets/1689733560361.png)

在内存上测试如下：

![1689733577130](./assets/1689733577130.png)

![1689733612907](./assets/1689733612907.png)

当时，url-loader也可以配置，配置成是事要打包成字符串。这个自行学习。参考代码如下：

```js
 {
     test: /\.(png|jpg|svg|gif|jpeg|webp)$/,
     use: [{
         loader: 'url-loader',
         options: {
             // limit单位是字节    1个字节 = 8位
             //                  1KB = 1024个字节
             //                  1MB = 1024KB
             limit: 1024 * 50, // 如果图片小于50kb，打包字符串，如果图片大于50kb，打包成图片
             name: 'img/[name].[hash:8].[ext]'
         }
     }]
 },
```

在webpack5中上面的两个laoder就淘汰了，对于图片的处理，webpack都内置好了，处理如下：

![1689733713278](./assets/1689733713278.png)

打包如下 ：

![1689733756881](./assets/1689733756881.png)

可以进一步优化如下：

![1689733839892](./assets/1689733839892.png)

打包完，测试后，如下：

![1689733851365](./assets/1689733851365.png)

![1689733867914](./assets/1689733867914.png)

### 16，ESLint

eslint是用来进行代码检测。也非常重要，在很多公司，都是要求使用eslint的，如果代码写的不符合要求，有可能代码就提交到不到仓库。在很早之前，有一个laoder，叫eslint-loader来校验代码，现在这个laoder已经淘汰了。现在使用的是一个插件，如下：

![1689734301564](./assets/1689734301564.png)

安装之，如下:

![1689734328003](./assets/1689734328003.png)

还需要安装eslint，eslint里面包含了很多的校验规则，安装如下：

![1689734361809](./assets/1689734361809.png)

这个插件不能进行校验，这个插件是把eslint集成到webpack中的。代码校验是在开发时进行校验的，配置就需要配置到开发环境中，如下：

![1689734560437](./assets/1689734560437.png)

尝试打包一下，如下 ：

![1689734578429](./assets/1689734578429.png)

在浏览器中看效果如下：

![1689734686199](./assets/1689734686199.png)

上面的插件仅仅是把eslint集成到webpack中，对于eslint的配置文件，还需要单独配置，打开eslint的官网，如下：

![1689734731513](./assets/1689734731513.png)

![1689734780470](./assets/1689734780470.png)

创建eslint的配置文件，有多种方式，创建一个eslint的配置文件, 如下：

![1689735089167](./assets/1689735089167.png)

只要动了配置文件，都需要重启开发服务器，如下：

![1689734987894](./assets/1689734987894.png)

测试如下：

![1689735114026](./assets/1689735114026.png)

尝试添加一些规则，如下：

![1689735216453](./assets/1689735216453.png)

看浏览器，如下：

![1689735279612](./assets/1689735279612.png)

修改之如下：

![1689735356944](./assets/1689735356944.png)

再次测试之，如下：

![1689735369442](./assets/1689735369442.png)

注释掉刚才的规则，如下：

![1689735424706](./assets/1689735424706.png)

现在尝试不加分号，如下：

![1689735441648](./assets/1689735441648.png)

动了配置文件，需要重启服务器，测试如下 ：

![1689735458032](./assets/1689735458032.png)

![1689735478473](./assets/1689735478473.png)

eslint中都有哪些规则呢？如下：

https://blog.csdn.net/qq_51657072/article/details/124427270

再尝试使用一个，如下：

![1689735564378](./assets/1689735564378.png)

现在在代码中就写一个console，如下：

![1689735588867](./assets/1689735588867.png)

重启服务器，测试如下：

![1689735602012](./assets/1689735602012.png)

![1689735629151](./assets/1689735629151.png)

修改之，如下：

![1689735672976](./assets/1689735672976.png)

测试如下：

![1689735701245](./assets/1689735701245.png)

还需要知道，在控制台中也会给出提示，如下：

![1689735729307](./assets/1689735729307.png)

可以关闭规则，如下：

![1689735783938](./assets/1689735783938.png)

如果是警告提示，不弹出模态框，如下：

![1689735818073](./assets/1689735818073.png)

配置如下：

![1689735892841](./assets/1689735892841.png)

规则如下 ：

![1689735912881](./assets/1689735912881.png)

重启，测试如下：

![1689735951015](./assets/1689735951015.png)

对于react代码中的jsx的校验，eslint规则并不完善，有一个公司，推出一个校验包，叫eslint-config-arbnb，如下：

![1689815250808](./assets/1689815250808.png)

直接下载eslint-config-airbnb不好下载，需要把它内置的其它都下载下来，如下：

![1689815375036](./assets/1689815375036.png)

之前都下载完了，如下：

![1689815419162](./assets/1689815419162.png)

集成airbnb对react代码的检测，如下：

![1689815674420](./assets/1689815674420.png)

使用React写一个计数器，如下：

![1689815565372](./assets/1689815565372.png)

此时，再打包，会报大量的错误，如下：

![1689815587139](./assets/1689815587139.png)

![1689815714259](./assets/1689815714259.png)

如果不想让eslint检测我们的src下面所有的代码，可以创建一个.eslintignore的配置文件，如下：

![1689815797347](./assets/1689815797347.png)

![1689815841846](./assets/1689815841846.png)

在eslint中提供了一些注释，可以忽略对某一行或某一片代码的查检，如下：

![1689815890056](./assets/1689815890056.png)

![1689815973469](./assets/1689815973469.png)

遇到了错误，怎么办？

![1689816034595](./assets/1689816034595.png)

总结解决eslint报错的方式：

1. 创建一个eslint的配置文件，修改rules，rules是自定义规则。
2. 使用eslint注释，非常多，临时地忽略检测
3. 在项目的根目录下面创建一个.eslintignore的文件，里面写src/*，可以忽略对src下面的所有的文件的检测
4. 老老实实找到错误的位置，把代码写规范了，前提是需要熟悉公司中使用了哪些规则

最后说一下，对于ES6中新的语法检测，还有一个包，叫@babel/eslint-parser。需要安装：

![1689816434570](./assets/1689816434570.png)

配置如下：

![1689816484383](./assets/1689816484383.png)

### 17，使用vue脚手架中的eslint

创建vue脚手架创建项目，如下：

![1689816512462](./assets/1689816512462.png)

![1689816530142](./assets/1689816530142.png)

![1689816561161](./assets/1689816561161.png)

![1689816601207](./assets/1689816601207.png)

![1689816649727](./assets/1689816649727.png)

弹出vue脚手架中webpack的配置，如下：

![1689816729919](./assets/1689816729919.png)

### 18，配置路径相关

配置如下：

![1689816874223](./assets/1689816874223.png)

使用之，如下：

![1689816907533](./assets/1689816907533.png)

效果如下：

![1689816998473](./assets/1689816998473.png)

### 19，搭建Vue的开发环境

参考地址：https://blog.csdn.net/qq_40412456/article/details/122334286

创建App.vue组件，如下：

![1689817160431](./assets/1689817160431.png)

在main.js中引入Vue，渲染Vue组件，如下：

![1689817186669](./assets/1689817186669.png)

尝试打包，如下：

![1689817211280](./assets/1689817211280.png)

安装依赖：

![1689817287311](./assets/1689817287311.png)

这些依赖之前都安装好，如下：

![1689817345465](./assets/1689817345465.png)

配置如下：

![1689817405994](./assets/1689817405994.png)

![1689817446881](./assets/1689817446881.png)

尝试打包，如下：

![1689817460751](./assets/1689817460751.png)

![1689817478749](./assets/1689817478749.png)

### 20，打包less

自行研究

### 21，打包字体图标

自行研究

### 22，打包主流程

![1701918843078](./assets/1701918843078.png)



Webpack **首先**需要根据输入配置(`entry/context`) 找到项目入口文件；**之后**根据按模块处理(`module/resolve/externals` 等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，最后**再根据**后处理相关配置项(`optimization/target` 等)合并模块资源、注入运行时依赖、优化产物结构等。



输入：

- 从文件系统读入代码文件；

模块递归处理：

- 调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；

后处理：

- 所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；

输出：

- 将 Chunk 写出到外部文件系统；



### 23，配置分类



从上述打包流程角度，Webpack 配置项大体上可分为两类：

- 流程类：作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项
- 工具类：打包主流程之外，提供更多工程化工具的配置项





### 24，主流程类配置



流程类的配置：

- 输入输出
  - `entry`：用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件；
  - `output`：配置产物输出路径、名称等；
  - `context`：项目执行上下文路径；
- 模块处理：
  - `resolve`：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块
  - `module`：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理
  - `externals`：用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作
- 后处理
  - `mode`：编译模式短语，支持 `development`、`production` 等值，可以理解为一种声明环境的短语
  - `target`：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异
  - `optimization`：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能





### 25，工具类配置



工具类的配置（除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具）。提升开发效率的配置：

- `devServer`：用于配置与 HMR 强相关的开发服务器功能
- `devtool`：用于配置产物 Sourcemap 生成规则
- `watch`：用于配置持续监听文件变化，持续构建



性能优化化的配置：

- `cache`：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果
- `performance`：用于配置当产物大小超过阈值时，如何通知开发者



日志类的配置：

- `stats`：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用
- `infrastructureLogging`：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件

![1701919955595](./assets/1701919955595.png)



Webpack 提供了上百项复杂配置，但大体上都可以归类为流程类配置或工具类配置，对于流程类配置应该多关注它们对编译主流程的影响；而工具类则更加内聚，基本上一种配置项解决一种工程化问题。
























