---
title: 11-vue2
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 一，Hello Vue2

### 1，vue2介绍

特点：

* MVVM框架
* 响应式（声明式）
* 丰富的指令（DOM功能的抽象）
* 基于选项式（template、data、computed、watch、methods....）
* Vue的文档，最好的教程    https://v2.cn.vuejs.org/
* vue的生态丰富且简单
* 渐近式的（可大可小的项目都能做）

vue的开发思想：

当我们需要在交互事件中改变视图时，先在data选项中声明一个合适的变量，再在交互事件中改变这个声明式变量即可，视图自动更新，这是一种间接的操作。

关于vue.js的版本

* **vue2**，经典版本，现在绝大部分的企业项目都是用vue2版本开发。
* vue3，也是主流，后面都会过渡到vue3上。

体验一下vue2，如下：

![1697074083546](./assets/1697074083546.png)

参考代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 引入vue.js -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.7.10/dist/vue.js"></script>
</head>

<body>
    <!-- 这个div叫vm实例对应的模板 -->
    <div id="app">
        <!-- {{}} 叫小胡子语法 -->
        <h2>{{name}}</h2>
        <button @click="changeData">改变数据</button>
    </div>

    <script>
        // Vue是一个构造器   new一个构造器就可以得到一个对象
        // vm也叫根组件   new Vue时，传递一个配置对象
        // 配置对象中需要写很多的选项
        // 所有的响应式数据，都会挂载到vm上。
        // vm代理data中所有的响应式数据
        let vm = new Vue({
            // el表示vm实例与上面的html容器进行关联
            el: "#app",
            // data是一个选项
            // data就是给模板提供数据的，放在data中的数据是响应式数据
            // 所谓的响应式的数据，就是数据变了，模板会自动刷新
            // 现在开发思想就变了：
            //   之前：获取DOM，操作DOM，改变视图
            //   现在：定义响应式数据，改变响应式数据，视图会自动的更新
            data() {
                return {
                    name: "码路", // 响应式数据
                }
            },
            methods: {
                changeData() {
                    // 改变响应式数据
                    // this，表示vm实例
                    this.name = "xxx";
                }
            }
        });
    </script>
</body>

</html>
```

再去体验一下，数据驱动视图，如下：

![1697074443573](./assets/1697074443573.png)

参考代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <!-- 1.引入vue.js文件 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>

<body>
    <!-- 模板 -->
    <div id="app">
        <h1>欢迎学习Vue.js</h1>
        <div>我叫{{name}}，微信{{wechat}}</div>

        <input type="button" value="点我" @click="clickMe">
    </div>

    <script>
        // 2.创建Vue实例，并且让vm与HTML中的容器进行关联
        let vm = new Vue({
            el: "#app",
            // data是给模板提供数据
            data: {
                name: "wc",
                wechat: "8764567765"
            },
            methods: {
                clickMe() {
                    this.name = "malu";
                    this.wechat = "66666666"
                }
            },
        });
    </script>
</body>

</html>
```

总结一下：

* vue的思想：数据驱动视图
* data  定义响应式数据，所谓的响应式，就是数据变了，视图会自动刷新
* el  让vm实例与某个容器进行关联
* methods   是专门用于定义函数方法的地方

## 二，Vue常见指令

vue中基本上不会再手动操作DOM，vue作者就帮我们封装了很多的指令。什么是指令？就是vue内置的一套“模板（都是以v-），用于在视图节点上动态绑定变量（表达式）的。**指令实际上是DOM功能的抽象，所以指令实际上也是DOM操作。**

**指令分类：**

* 文本相关的指令
* 属性绑定相关的指令
* 事件绑定相关的指令
* 表单相关的指令
* 列表渲染相关的指令
* 条件渲染相关的指令
* 其它指令
* 自定义指令

### 1，文本相关的指令

```html
下面的是文本相关的指令：

- {{}}文本插值、v-text、v-once、v-cloak、v-html
- {{}} 用于绑定节点的文本，它和v-text功能是一样的。区别是{{}}这种绑定值的方式会出现“{{}}一闪而过”的效果，建议使用v-cloak来解决。
- v-text 用于绑定节点的文件，在大多数时候，它和 {{}} 可以相互替换。
- v-once 用于指定节点的动态内容只绑定一次。当前节点中所对应的变量发生变化，视图不更新。一般情况下，v-once只能和{{}}一起用。
- v-once 和 v-cloak 都是不需要接收表达式来做为“值”
- v-html 用于绑定动态的html节点，相当于DOM中的 innerHTML。这个指令默认已经做了“防注入攻击XSS”的处理
```

代码演示：

![1697075930360](./assets/1697075930360.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        [v-cloak] {
            display: none;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <div>
            <!-- {{}} 小胡子语法仅仅是v-text指令的语法糖 -->
            <h2 v-cloak>{{name}}</h2>
            <!-- v-text "name" 不是字符串，不是字符串，不是字符串 -->
            <!-- 是表达式，后面看到"" 里面放的是表达式 -->
            <h2 v-text="name"></h2>
            <h2 v-text=" '年龄：' + age "></h2>
            <h2 v-text=" `年龄：${age}` "></h2>
            <h2 v-cloak>{{'年龄：' +age}}</h2>
            <div v-text="msg"></div>
            <div v-html="msg"></div>
            <h2 v-once>{{age}}</h2>
            <button @click="changeAage">改变age</button>
        </div>
    </div>
    <script>
        // setTimeout(() => {
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    age: 18,
                    msg: `<a href="http://www.baidu.com">百度一下</a>`,
                }
            },
            methods: {
                changeAage() {
                    this.age++
                }
            }
        });
        // }, 2000);
    </script>
</body>

</html>
```

### 2，属性绑定相关的指令

```html
- v-bind 用于动态绑定节点的属性（比如title、value、class、style等）
- v-bind 用得非常多，所以经常简写成 : &lt; div :id='变量'>&lt; /div>
- 动态class语法（一）：&lt; div :class='`${变量1} ${变量2} `'>&lt; /div>
- 动态class语法（二）：&lt; div :class='[表达式1, 表达式2, ...]'>&lt; /div>
- 动态class语法（三）：&lt; div :class='{ 类名1: 布尔值1, 类名2: 布尔值2, ... }'>&lt; /div>
- 动态style语法（一）：&lt; div :style='`color:red;fontSize:20px`'>&lt; /div>
- 动态style语法（二）：&lt; div :style='[{css键值对}, {css键值对}, ...]'>&lt; /div>
- 动态style语法（三）：&lt; div :style='{css键值对}'>&lt; /div>
```

绑定普通的属性，代码如下：

![1697078074924](./assets/1697078074924.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h1 title="haha">我是一个孤独的h2</h1>
        <!-- 一个指令后面的""中放的是表达式 -->
        <h1 v-bind:title="a1">我是一个孤独的h2</h1>
        <h1 :title="a1">我是一个孤独的h2</h1>
        <h1 v-bind="{title:a1,class:a2}">我是一个孤独的h2</h1>

        <img :src="imgUrl" alt="">
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    a1: 'ok',
                    a2: 'bad',
                    imgUrl: "https://img0.baidu.com/it/u=1732521231,1421026517&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1697216400&t=407e58ecae68be0e0bbf7d27ac586278",
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

绑定class属性，如下：

![1697078618827](./assets/1697078618827.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h1 class="box">绑定class属性</h1>
        <h1 :class="a1">绑定class属性</h1>
        <h1 :class=" `${a1} ${a2}` ">绑定class属性</h1>
        <h1 :class=" [a1,a2] ">绑定class属性</h1>
        <h1 :class=" [ 1==1 ? a1 : a2 ] ">绑定class属性1111</h1>
        <h1 :class=" {box1:true,box2:true} ">绑定class属性</h1>
        <h1 :class=" obj ">绑定class属性</h1>
        <h1 :class=" {f1:Math.random()>0.5} ">绑定class属性</h1>
        <h1 :class=" {f1:110} ">绑定class属性</h1>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    a1: "info",
                    a2: "danger",
                    clr: "red",
                    size: "19",
                    obj: {
                        box3: true,
                        box4: true
                    }
                }
            },
            methods: {}
        })
    </script>
</body>

</html>
```

还有一个比较特殊，绑定style，如下：

![1697079234029](./assets/1697079234029.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- v-bind是单向绑定：把JS中的数据绑定到HTML上。  修改JS中的响应式数据，HTML也会修改。 -->
        <h1 style="color: red; background-color: pink;">绑定行内样式</h1>
        <h1 :style=" `color:yellowgreen; background-color: pink;` ">绑定行内样式</h1>
        <h1 :style=" `color:${a1}; background-color: ${a2};` ">绑定行内样式</h1>
        <h1 :style=" {color:a2,fontSize:fs+'px'} ">绑定行内样式</h1>
        <h1 :style=" [{color:'red'},{fontSize:fs+'px'},{textDecoration:'line-through'}] ">绑定行内样式</h1>
        <h1 :style=" {[a3]:a1} ">绑定行内样式</h1>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    a1: 'blue',
                    a2: 'gold',
                    fs: "46",
                    a3: 'color'
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

### 3，事件绑定相关的指令

```html
- v-on 用于给视图节点绑定各种JS事件，比如click、mouseenter、blur、keyup等
- v-on:click
- v-on:dblclick
- v-on:mouseover，
- v-on:mouseout，
- v-on:change
- v-on:focus
- ...
- v-on 用得非常多, 所以简写成 @ 基本语法: div @事件名. 事件修饰符='事件处理器'
- v-on 上可以使用事件修饰符: .stop阻止冒泡 .prevent阻止默认事件 .enter绑定键盘Enter键盘....
```

直接上代码：

![1697079951910](./assets/1697079951910.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .outer {
            width: 200px;
            height: 200px;
            background-color: gold;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .inner {
            width: 100px;
            height: 100px;
            background-color: skyblue;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <button v-on:click="handle">点我</button>
        <button @click="handle">点我</button>

        <!-- 事件相关的修饰符  stop 阻止事件冒泡 -->
        <!-- prevent 阻止默认事件 -->
        <!-- once 只绑定一次 -->
        <!-- 事件修饰符可以连用 -->
        <div class="outer" @click="outerClick">
            <div class="inner" @click.stop.once="innerClick"></div>
        </div>

        <button @click="fn">点我</button>
        <button @click="gn(1,2)">点我</button>
        <!-- 手动的把事件对象传递下面，在模板中有一个$event表示事件对象 -->
        <button @click="kn(1,2,$event)">点我</button>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    // 方法写在data中，也行，不建议
                }
            },
            methods: {
                handle() {
                    console.log("handle...");
                },
                outerClick() {
                    console.log("outerClick...");
                },
                innerClick() {
                    console.log("innerClick...");
                },
                fn(e) {
                    console.log("e:", e);
                },
                gn(a, b) {
                    console.log(a, b);
                },
                kn(a, b, e) {
                    console.log(a, b, e);
                }
            }
        });
    </script>
</body>

</html>
```

### 4，表单相关的指令(v-model)

```html
一般用于在交互的表中中使用，例如：input、select、textarea等。【双向绑定】

- v-model 用于表单取值(表单双向绑定), 比如input/select/textarea等
- 基本语法: input type="text" v-model. 表单修饰符='变量'
- 三个修饰符: .trim自动去除文本首尾空格 .number隐式类型转换变成Number类型 .lazy用于性能, 当表单失焦时再进行双向绑定
- v-model 还有更深的理解, 在组件化中进一步去理解
```

先简单的使用一个v-mdole，如下：

![1697081069123](./assets/1697081069123.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- 姓名：<input type="text" :value="name" @input="fn"> <br> -->

        <!-- 如果方法中只有一行代码，可以把代码直接写在模板中 -->
        <!-- 姓名：<input type="text" :value="name" @input="name = $event.target.value"> <br> -->

        <!-- v-model写在标签上，等价于:value + @input -->
        <!-- 姓名：<input type="text" v-model="name"> <br> -->

        <!-- v-model都有哪些修饰符？答：number trim lazy -->
        <input type="text" v-model.trim="name" @keyup.enter="submit">
        <input type="text" v-model.number="age" @keyup.enter="submit">
        <h1>{{age}}</h1>
        <!-- v-model是双向绑定 默认情况下，v-model等价于： :value+@input-->
        <input type="text" v-model="age" @keyup.enter="submit">
        <!-- lazy 就可以把input事件，变成change事件 -->
        <input type="text" v-model.lazy="age" @keyup.enter="submit">
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    age: 18
                }
            },
            methods: {
                submit(e) {
                    // console.log(this.name);
                    console.log(this.age);
                    // console.log(e.target.value);
                },
                fn(e) {
                    // console.log(e.target.value);
                    this.name = e.target.value;
                }
            }
        });
    </script>
</body>

</html>
```

回顾一下上午的v-model，如下：

![1697090955674](./assets/1697090955674.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <div>
            用户名：<input type="text" v-model="user">
        </div>
        <div>
            密码：<input type="password" v-model="pwd">
        </div>
        <input type="button" value="登录" v-on:click="clickMe" />
        <input type="button" value="重置" v-on:click="resetForm" />
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    user: "",
                    pwd: ""
                }
            },
            methods: {
                clickMe() {
                    console.log(this.user, this.pwd);
                },
                resetForm() {
                    this.user = "";
                    this.pwd = "";
                }
            }
        });
    </script>
</body>

</html>
```

v-model收集其它数据，如下：

![1697091573012](./assets/1697091573012.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <div>
            用户名：<input type="text" v-model="user">
        </div>
        <div>
            密码：<input type="password" v-model="pwd">
        </div>
        <div>
            性别：
            <input type="radio" name="s" v-model="sex" value="1" /> 男
            <input type="radio" name="s" v-model="sex" value="2" /> 女
        </div>
        <div>
            爱好：
            <input type="checkbox" value="11" v-model="hobby"> 篮球1
            <input type="checkbox" value="22" v-model="hobby"> 篮球2
            <input type="checkbox" value="33" v-model="hobby"> 篮球3
        </div>
        <div>
            城市：
            <select v-model="city">
                <option value="sh">上海</option>
                <option value="bj">北京</option>
                <option value="sz">深圳</option>
            </select>
        </div>
        <div>
            部门：
            <select v-model="dept" multiple>
                <option value="js">技术</option>
                <option value="xs">销售</option>
                <option value="yy">运营</option>
            </select>
        </div>
        <div>
            其他：<textarea v-model="more"></textarea>
        </div>
        <input type="button" value="登录" v-on:click="clickMe" />
        <input type="button" value="重置" v-on:click="resetForm" />
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    user: "",
                    pwd: "",
                    sex: "1",
                    hobby: [],
                    city: "sz",
                    dept: [],
                    more: "..."
                }
            },
            methods: {
                clickMe() {
                    console.log(this.user, this.pwd, this.sex, this.hobby, this.city, this.dept, this.more);
                },
                resetForm() {
                    this.user = "";
                    this.pwd = "";
                }
            }
        });
    </script>
</body>

</html>
```

上面每一个响应式数据，都是独立的，可以把这些响应式数据放到对象，如下：

![1697091760790](./assets/1697091760790.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <div>
            用户名：<input type="text" v-model="info.user">
        </div>
        <div>
            密码：<input type="password" v-model="info.pwd">
        </div>
        <div>
            性别：
            <input type="radio" name="s" v-model="info.sex" value="1" /> 男
            <input type="radio" name="s" v-model="info.sex" value="2" /> 女
        </div>
        <div>
            爱好：
            <input type="checkbox" value="11" v-model="info.hobby"> 篮球1
            <input type="checkbox" value="22" v-model="info.hobby"> 篮球2
            <input type="checkbox" value="33" v-model="info.hobby"> 篮球3
        </div>
        <div>
            城市：
            <select v-model="info.city">
                <option value="sh">上海</option>
                <option value="bj">北京</option>
                <option value="sz">深圳</option>
            </select>
        </div>
        <div>
            部门：
            <select v-model="info.dept" multiple>
                <option value="js">技术</option>
                <option value="xs">销售</option>
                <option value="yy">运营</option>
            </select>
        </div>
        <div>
            其他：<textarea v-model="info.more"></textarea>
        </div>
        <input type="button" value="登录" v-on:click="clickMe" />
        <input type="button" value="重置" v-on:click="resetForm" />
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    info: {
                        user: "",
                        pwd: "",
                        sex: "1",
                        hobby: [],
                        city: "sz",
                        dept: [],
                        more: "..."
                    }
                }
            },
            methods: {
                clickMe() {
                    console.log(this.info.user, this.info.pwd, this.info.sex, this.info.hobby, this.info.city, this.info.dept, this.info.more);
                },
                resetForm() {
                    this.user = "";
                    this.pwd = "";
                }
            }
        });
    </script>
</body>

</html>
```

### 5，列表渲染相关的指令

```html
* v-for 用于渲染数月、对象、Number变量等等
* 当 v-for 渲染列表时, 语法是这样的 <div v-for='(item, index) in array'></div>
* 当 v-for 渲染对象时, 语法是这样的 <div v-for='(value, key, index) in obj'></div>
* 当 v-for 渲染Number变量时, 语法是这样的 <div v-for='(num, index) in 5'></div>
* 注意: v-for在循环渲染时要求加key, 为什么呢? 在响应式原理时再解释
```

上代码演示，循环数组，如下：

![1697092402425](./assets/1697092402425.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- v-for循环一个数组 -->
        <div v-for="(item,index) in todolist" :style="{background:(item.done ? 'red':'transparent')}">
            <input type="checkbox" :checked="item.done" @click="fn(item,index)">
            <span>{{item.text}}</span>
            <span>x</span>
        </div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    todolist: [{
                            id: 1,
                            text: "学习vue1",
                            done: true
                        },
                        {
                            id: 2,
                            text: "学习vue2",
                            done: false
                        },
                        {
                            id: 3,
                            text: "学习vue3",
                            done: false
                        },
                    ],
                }
            },
            methods: {
                fn(item, index) {
                    this.todolist[index].done = !this.todolist[index].done
                }
            }
        });
    </script>
</body>

</html>
```

v-for也可以循环一个对象，如下：

![1697092516483](./assets/1697092516483.png)

也可以循环一个数字，如下：

![1697092572248](./assets/1697092572248.png)

### 6，案例：数据管理案例

数据的管理包括对数据：展示、动态添加、删除、修改。  

先实现展示：

![1697092768942](./assets/1697092768942.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .penal {
            border: 1px solid #dddddd;
            margin: 20px 0 0 0;
            padding: 10px;
            border-bottom: 0;
            background-color: #d9d9d9;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
        }

        .table>tbody>tr>td,
        .table>tbody>tr>th,
        .table>tfoot>tr>td,
        .table>tfoot>tr>th,
        .table>thead>tr>td,
        .table>thead>tr>th {
            padding: 8px;
            vertical-align: top;
            border: 1px solid #ddd;
            text-align: left;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h3 class="penal">数据列表</h3>
        <table class="table">
            <thead>
                <tr>
                    <td>姓名</td>
                    <td>年龄</td>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(item,index) in dataList">
                    <td>{{item.name}}</td>
                    <td>{{item.age}}</td>
                </tr>
            </tbody>
        </table>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    dataList: [{
                            name: "malu",
                            age: 18
                        },
                        {
                            name: "wc",
                            age: 28
                        },
                    ]
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

要实现添加，要通过表单进行添加，就是收集表单中的数据，就要用到v-model，代码如下：

![1697093057087](./assets/1697093057087.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .penal {
            border: 1px solid #dddddd;
            margin: 20px 0 0 0;
            padding: 10px;
            border-bottom: 0;
            background-color: #d9d9d9;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
        }

        .table>tbody>tr>td,
        .table>tbody>tr>th,
        .table>tfoot>tr>td,
        .table>tfoot>tr>th,
        .table>thead>tr>td,
        .table>thead>tr>th {
            padding: 8px;
            vertical-align: top;
            border: 1px solid #ddd;
            text-align: left;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h3 class="penal">表单区域</h3>
        <div>
            <div>
                <label>姓名</label>
                <input type="text" v-model="user">
            </div>
            <div>
                <label>年龄</label>
                <input type="text" v-model="age">
                <input type="button" value="新增" @click="addUser">
            </div>
        </div>
        <h3 class="penal">数据列表</h3>
        <table class="table">
            <thead>
                <tr>
                    <td>姓名</td>
                    <td>年龄</td>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(item,index) in dataList">
                    <td>{{item.name}}</td>
                    <td>{{item.age}}</td>
                </tr>
            </tbody>
        </table>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    dataList: [{
                            name: "malu",
                            age: 18
                        },
                        {
                            name: "wc",
                            age: 28
                        },
                    ],
                    user: "",
                    age: ""
                }
            },
            methods: {
                addUser() {
                    let row = {
                        name: this.user,
                        age: this.age
                    };
                    console.log(row);
                    this.dataList.push(row);
                    this.user = "";
                    this.age = "";
                }
            }
        });
    </script>
</body>

</html>
```

要实现删除，如下：

![1697093409974](./assets/1697093409974.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .penal {
            border: 1px solid #dddddd;
            margin: 20px 0 0 0;
            padding: 10px;
            border-bottom: 0;
            background-color: #d9d9d9;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
        }

        .table>tbody>tr>td,
        .table>tbody>tr>th,
        .table>tfoot>tr>td,
        .table>tfoot>tr>th,
        .table>thead>tr>td,
        .table>thead>tr>th {
            padding: 8px;
            vertical-align: top;
            border: 1px solid #ddd;
            text-align: left;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h3 class="penal">表单区域</h3>
        <div>
            <div>
                <label>姓名</label>
                <input type="text" v-model="user">
            </div>
            <div>
                <label>年龄</label>
                <input type="text" v-model="age">
                <input type="button" value="新增" @click="addUser">
            </div>
        </div>
        <h3 class="penal">数据列表</h3>
        <table class="table">
            <thead>
                <tr>
                    <td>姓名</td>
                    <td>年龄</td>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(item,index) in dataList">
                    <td>{{item.name}}</td>
                    <td>{{item.age}}</td>
                    <td>
                        <!-- <input type="button" value="删除" @click="delRow(index)"> -->
                        <input type="button" value="删除" @click="delRow" :data-idx="index">
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    dataList: [{
                            name: "malu",
                            age: 18
                        },
                        {
                            name: "wc",
                            age: 28
                        },
                    ],
                    user: "",
                    age: ""
                }
            },
            methods: {
                addUser() {
                    let row = {
                        name: this.user,
                        age: this.age
                    };
                    console.log(row);
                    this.dataList.push(row);
                    this.user = "";
                    this.age = "";
                },
                // delRow(index){
                delRow(e) {
                    // this.dataList.splice(index,1)

                    console.log(e.target.dataset.idx);
                    let idx = e.target.dataset.idx
                    this.dataList.splice(idx, 1)
                }
            }
        });
    </script>
</body>

</html>
```

最后，要实现编辑（修改），如下：

![1697093951389](./assets/1697093951389.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .penal {
            border: 1px solid #dddddd;
            margin: 20px 0 0 0;
            padding: 10px;
            border-bottom: 0;
            background-color: #d9d9d9;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            border-spacing: 0;
        }

        .table>tbody>tr>td,
        .table>tbody>tr>th,
        .table>tfoot>tr>td,
        .table>tfoot>tr>th,
        .table>thead>tr>td,
        .table>thead>tr>th {
            padding: 8px;
            vertical-align: top;
            border: 1px solid #ddd;
            text-align: left;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h3 class="penal">表单区域</h3>
        <div>
            <div>
                <label>姓名</label>
                <input type="text" v-model="user">
            </div>
            <div>
                <label>年龄</label>
                <input type="text" v-model="age">
                <input type="button" :value="title" @click="addUser">
            </div>
        </div>
        <h3 class="penal">数据列表</h3>
        <table class="table">
            <thead>
                <tr>
                    <td>姓名</td>
                    <td>年龄</td>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(item,index) in dataList">
                    <td>{{item.name}}</td>
                    <td>{{item.age}}</td>
                    <td>
                        <!-- <input type="button" value="删除" @click="delRow(index)"> -->
                        <input type="button" value="删除" @click="delRow" :data-idx="index">
                        <input type="button" value="编辑" @click="editRow" :data-idx="index">
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    dataList: [{
                            name: "malu",
                            age: 18
                        },
                        {
                            name: "wc",
                            age: 28
                        },
                    ],
                    user: "",
                    age: "",
                    title: "新增",
                    editIndex: undefined
                }
            },
            methods: {
                addUser() {
                    if (this.editIndex) {
                        // 编辑
                        this.dataList[this.editIndex].name = this.user;
                        this.dataList[this.editIndex].age = this.age;
                    } else {
                        // 新增
                        let row = {
                            name: this.user,
                            age: this.age
                        };
                        console.log(row);
                        this.dataList.push(row);
                    }
                    this.editIndex = undefined;
                    this.title = "新增"
                    this.user = "";
                    this.age = "";

                },
                // delRow(index){
                delRow(e) {
                    // this.dataList.splice(index,1)

                    console.log(e.target.dataset.idx);
                    let idx = e.target.dataset.idx
                    this.dataList.splice(idx, 1)
                },
                editRow(e) {
                    let idx = e.target.dataset.idx;
                    let {
                        name,
                        age
                    } = this.dataList[idx];
                    this.user = name;
                    this.age = age;

                    this.title = "编辑";
                    this.editIndex = idx;
                }
            }
        });
    </script>
</body>

</html>
```

### 7，条件渲染相关的指令

```text
* v-show 用于显示或隐藏视图节点, 背后使用的 display: 原本的显示模式 / display:none 来实现的
* v-if / v-else-if / v-else 用于显示或隐藏视图节点, 背后是真正地移除或插入视图节点
* v-if 因为是节点插入或移除, 比较耗费性能; v-show只是通过样式来实现显示与隐藏, 性能开销更小.
* v-if, 不建议和 v-for 一起使用; 如果一定要在同一个节点上使用v-if和v-for, v-for优先级更好
```

对于v-if，直接上代码：

![1697094899822](./assets/1697094899822.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- v-if 控制元素的创建或销毁-->
        <div v-if="isShow">我是一个孤独的DIV</div>

        <hr>

        <h1 v-if="row == 1">我是第一行</h1>
        <h2 v-else-if="row==2">我是第二行</h2>
        <h3 v-else-if="row==3">我是第三行</h3>
        <h4 v-else>我是第四行</h4>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    isShow: true,
                    row: 1
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

做一个小案例，如下：

![1697095201525](./assets/1697095201525.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <input type="button" value="密码登录" @click="isSms = false" />
        <input type="button" value="短信登录" @click="isSms = true" />

        <div v-if="isSms">
            <p>
                <label>手机号</label>
                <input type="text" placeholder="手机号">
            </p>
            <p>
                <label>验证码</label>
                <input type="text" placeholder="验证码">
            </p>
        </div>
        <div v-else>
            <p>
                <label>用户名</label>
                <input type="text" placeholder="用户名">
            </p>
            <p>
                <label>密码</label>
                <input type="password" placeholder="密码">
            </p>
        </div>

    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    isSms: false
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

对于条件渲染，还有一个指令，叫v-show，它也可以控制元素的显示与隐藏，前面讲的v-if是控制元素的创建或销毁。v-show是控制元素的显示与隐藏，是通过样式来控制，元素是已经创建，代码：

![1697095354853](./assets/1697095354853.png)

### 8，案例：小练习

练习一：

![1697095528869](./assets/1697095528869.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        ul {
            width: 150px;
            list-style-type: none;
            background-color: gold;
        }

        li {
            width: 100%;
            height: 50px;
            text-align: center;
            line-height: 50px;
            border-bottom: 1px solid white;
            color: red;
        }

        .active {
            background-color: skyblue;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ul>
            <li v-for="(item,index) in list" @click="fn(index)" :class="{active:currentIndex == index}">
                {{item.title}} -- {{index}}
            </li>
        </ul>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    currentIndex: -1,
                    list: [{
                            id: 1001,
                            title: '母婴'
                        },
                        {
                            id: 1002,
                            title: '家电'
                        },
                        {
                            id: 1003,
                            title: '医用'
                        },
                        {
                            id: 1004,
                            title: '手机'
                        },
                        {
                            id: 1005,
                            title: '直播'
                        },
                        {
                            id: 1006,
                            title: '游戏'
                        },
                        {
                            id: 1007,
                            title: '酒水'
                        },
                        {
                            id: 1008,
                            title: '娱乐'
                        },
                        {
                            id: 1009,
                            title: '美食'
                        },
                        {
                            id: 1010,
                            title: '财经'
                        }
                    ],
                }
            },
            methods: {
                fn(idx) {
                    console.log(idx);
                    this.currentIndex = idx;
                }
            }
        })
    </script>
</body>

</html>
```

练习二：

![1697095598808](./assets/1697095598808.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <button @click="fs+=5">点击放大P标签中的字体大小</button>
        <p :style="{fontSize:fs+'px'}">任何人都应当有自尊心，自信心，独立性，不然就是奴才</p>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    fs: 16
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

练习三：

![1697095660020](./assets/1697095660020.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            width: 400px;
            height: 200px;
            background-color: #000;
        }

        input {
            margin: 10px 0px;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <div class="box" :style="{background:`rgb(${r},${g},${b})`}"></div>
        <p>
            R: <input type="range" v-model.number="r" min="0" max="255"> <span>{{r}}</span>
        </p>
        <p>
            G: <input type="range" min="0" max="255" v-model.number="g"><span>{{g}}</span>
        </p>
        <p>
            B: <input type="range" min="0" max="255" v-model.number="b"><span>{{b}}</span>
        </p>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    r: 0,
                    g: 0,
                    b: 0
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

练习四：

![1697095726443](./assets/1697095726443.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .tab-box {
            /* background-color: pink; */
            width: 300px;
            margin: 20px auto;
            box-sizing: border-box;
        }

        .tab-box .tab {
            display: flex;
            position: relative;
            top: 1px;
        }

        .tab-box .tab li {
            list-style: none;
            border: 1px solid #ddd;
            padding: 5px 10px;
            margin-right: 10px;
            background: #eee;
        }

        .tab-box .tab li.active {
            color: lightcoral;
            background-color: #fff;
            border-bottom-color: #fff;
        }

        .tab-box .con {
            display: none;
            box-sizing: border-box;
            padding: 10px;
            height: 100px;
            border: 1px solid #ddd;
        }

        .tab-box .con.active {
            display: block;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app' class="tab-box">
        <ul class="tab">
            <li v-for="(item,index) in list" :class="{active:selected == index}" @click="change(index)">
                {{item.title}}
            </li>
        </ul>
        <div v-for="(item,index) in list" class="con" :class="{active:selected == index}">
            {{item.content}}
        </div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    list: [{
                            id: 1,
                            title: "音乐",
                            content: "成都-赵雷"
                        },
                        {
                            id: 2,
                            title: "电影",
                            content: "新蝙蝠侠"
                        },
                        {
                            id: 3,
                            title: "电视剧",
                            content: "甄嬛传"
                        },
                    ],
                    selected: 0
                }
            },
            methods: {
                change(idx) {
                    if (idx == this.selected) return;
                    this.selected = idx;
                }
            }
        });
    </script>
</body>

</html>
```

### 9，面试题

* vue核心思想是？
  
  + 数据驱动视图
  + 基于选项式API
  + 组件化开发（自定义属性，自定义事件，自定义插槽）
* 常用的vue指令都有些？你是怎么理解指令？
  + 文本节点处理的指令   v-text  v-html  {{}}  v-cloak
  
  + 动态属性绑定指令   v-bind  简写成冒号   动态绑定class  动态绑定style    单向绑定
  
  + 事件绑定指令   v-on  v-once  简写成@  事件冒泡  事件对象  事件修饰符  按键修饰符  
  
  + 表单相关的指令  v-model   目的是为了收集表单数据  收集完毕，发ajax请求，把数据扔给服务器
  
  + 列表渲染  v-for 写在哪个标签上，就循环出多少个这样的标签。可以循环数组，对象，整数。
  
  + 条件渲染  v-if   v-else-if  v-else     v-show 
  
  + 其它：v-slot  插槽，后面讲     v-pre 用于调试的.....
  
  + 自定义指令：上面的指令是内置的指令，除了内置指令，我们也可以自定义指令。后面讲。
  
  + 指令本质上是对dom的操作，vue封装这些指令就是为了我们更为合理符合规范的操作dom，避免DOM滥操作。我们也可以自定义指令，自定义指令也是对DOM操作的封装，我之前工作中封装过一些自定义指令，如：xxxx
  
* 什么是单向数据绑定，什么是双向数据绑定？
  + 单向绑定，修改响应式数据，模板会发生更新。  或者修改了JS，更新了HTML。
  + 双向绑定，一向是修改了响应式数据，模板会发生更新。另一向是修改了模板，响应式数据也会更新。
  + 单向绑定：v-bind   v-text  v-html  {{}}
  + 双向绑定：v-model    也可以使用:value + @input
* v-if和v-show有什么区别？
  + v-if是控制元素（标签，也可以是组件）的创建或销毁，消耗性能大一点。
  
  + v-show是控制样式，来实现元素的显示或隐藏。通过display属性。消耗性能小一点。
  
  + v-show不支持template
  
  + 如果看过源码，可以从源码角度去分析。v-if最终编译成了什么，v-show最终编译成了什么...

  
  + 当需要频繁控制元素的显示或隐藏，使用v-show。在vue2中，v-if不能和v-for连用。因为在vue2中v-for的优先级更高。
  
  + 其它....
* 文本插值有“{{}}一闪而过”问题，怎么处理？
  + 使用v-text
  + 使用v-cloak，还需要配合css
* v-for 可以循环哪些数据类型？v-for列表渲染时为什么加key？
  + 可以循环数组，在项目中最重要就是循环数组，数组这个数据来自ajax请求。
  + 可以循环对象，循环对象，可以对象键，值，索引
  + 可以循环整数
  + v-for，需要加一个key，为什么，后面讲。
* v-model 有哪些修饰符？
  + .trim  收集数据时，去掉左右的空格
  + .number 收集数据时，数据是123abc，收集到的是123
  + .lazy  当失去焦点时，再去收集数据
* vue 中怎么阻止冒泡？怎么阻止默认事件？怎么监听键盘enter键？
  + 通过事件修饰符，或事件对象可以阻止冒泡，也可以阻止默认事件。
  + @keyup.enter = ""  .enter叫按键修饰符，还可以通过事件对象。

### 10，案例：登录

![1697162634192](./assets/1697162634192.png)

这个案例，需要调用接口，接口，我下去，找一个登录接口。我们需要用axios发请求了。

### 11，一些免费的API接口

* https://jsonplaceholder.typicode.com/
* https://reqres.in/
* https://picsum.photos/
* https://dog.ceo/dog-api/
* https://thecatapi.com/

## 三，计算属性

### 1，什么是计算属性

vue2是基于选项式API开发项目，前面我们学习了3个选项：el，data，methods。其实还非常多的选项，再去学习一个选项，叫computed。计算属性是对已有数据再加工，得到一个新的数据，在模板中可以直接使用计算属性。在方法中，也可以通过this来获取计算属性，作用：

* 作用1：当指令的表达式比较复杂时，我们建议使用计算属性来优化，提升视图模板中代码的可阅读性、可维护性。
* 作用2：用于缓存一个复杂的运算，避免组件更新时产生没有必要的性能损耗。计算属性本质上是一个函数，Vue会分析函数体中使用到了哪些声明式变量，有且仅有这些声明式变量发生变化时，计算属性才会重新执行。

直接上代码：

![1697165536020](./assets/1697165536020.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- 在胡子中做了复杂计算 -->
        <h2>{{ "总价$:"+ (num*price).toFixed(2) }}</h2>
        <!-- 虽然在定义时，把计算属性定义成函数，但是在模板中使用时，当成了普通的数据 -->
        <h2 v-text="total"></h2>
        <h2 v-text="total2"></h2>
        <h2 v-text="total3"></h2>
        <button @click="btnClick">修改</button>
        <hr>
        firstName: <input type="text" v-model="firstname">
        lastname: <input type="text" v-model="lastname"> <br>
        全名：<input type="text" disabled :value="firstname+lastname"> <br>
        全名：<input type="text" :value="fullname" @change="fn"> <br>
        <!--  v-model后面可以跟一个计算属性 -->
        <!-- 为什么v-model后面可以跟一个计算属性? -->
        <!-- 答: 原因是计算属性有setter -->
        <!-- 计算属性中不能写异步代码 -->
        全名：<input type="text" v-model.lazy="fullname"> <br>

    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    num: 10,
                    price: 100,
                    msg: "hello vue",
                    firstname: "",
                    lastname: ""
                }
            },
            computed: {
                // 一般情况下，计算属性会写成函数的形式
                // 函数返回值，计算属性的值就是什么
                // 此时，tatal这个计算属性有data有关系，计算属性是由data中的状态计算而来的
                total() {
                    let t = (this.num * this.price).toFixed(2);
                    return '总价:$' + t
                },
                // 计算属性也可以和data没有任何关系
                total2() {
                    return "666"
                },
                // 计算属性还可以写在对象的形式
                // 在模板中使用计算属性时，会自动调用get
                // get的返回值就是计算属性的值
                total3: {
                    get() {
                        console.log("get...");
                        return this.msg
                    },
                    // 当修改计算属性时，就会走set
                    // 在修改时，会把新值传递给val
                    set(val) {
                        console.log("set...");
                        this.msg = val;
                    }
                },
                fullname: {
                    get() {
                        return this.firstname + "." + this.lastname
                    },
                    set(val) {
                        console.log("val:", val);
                        let arr = val.split(".")
                        this.firstname = arr[0]
                        this.lastname = arr[1]
                    }
                }
            },

            methods: {
                btnClick() {
                    this.total3 = "hi vue"
                },
                fn(e) {
                    let arr = e.target.value.split(".");
                    console.log(arr);
                    this.firstname = arr[0]
                    this.lastname = arr[1]
                }
            }
        });
    </script>
</body>

</html>
```

计算属性还有缓存的功能，代码如下：

![1697166011257](./assets/1697166011257.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <div>
            <h2>全名(胡子中计算)：{{firstname+lastname}}</h2>
            firstName: <input type="text" v-model="firstname">
            lastname: <input type="text" v-model="lastname">
        </div>
        <hr>
        <div>
            <h2>全名(函数调用)：{{fullname()}}</h2>
            <h2>全名(函数调用)：{{fullname()}}</h2>
            <h2>全名(函数调用)：{{fullname()}}</h2>
            firstName: <input type="text" v-model="firstname">
            lastname: <input type="text" v-model="lastname">
        </div>
        <hr>
        <div>
            <!-- 第一个肯定要计算，计算的结果会缓存起来 -->
            <!-- 后面如果依赖的数据没有变化，直接从缓存中获取结果，不会重新计算，性能高 -->
            <!-- 在项目中，能使用计算属性的，尽可能使用计算属性，使用计算属性能使用的，使用方法也可以使用 -->
            <h2>全名(计算属性)：{{fullname2}}</h2>
            <h2>全名(计算属性)：{{fullname2}}</h2>
            <h2>全名(计算属性)：{{fullname2}}</h2>
            firstName: <input type="text" v-model="firstname">
            lastname: <input type="text" v-model="lastname">
        </div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    firstname: "",
                    lastname: ""
                }
            },
            computed: {
                fullname2() {
                    console.log("计算属性...");
                    return this.firstname + this.lastname;
                }
            },
            methods: {
                fullname() {
                    console.log("函数调用了...");
                    return this.firstname + this.lastname
                }
            }
        });
    </script>
</body>

</html>
```

### 2，面试题

* 计算属性有什么作用？（两大作用）
  + 作用1：把胡子语法中复杂的计算逻辑，封装到一个计算属性中。
  + 作用2：第1次计算的缓存，会被缓存起来，如果依赖的数据没有发生变化，直接从缓存中获取结果。
* 计算属性能不能绑定在v-model上？
  + 可以，因为计算属性不只有get，还有set。
* 怎么理解计算属性的缓存功能？
  + 有且仅有被关联的声明式变量变化时，计算属性才会重新计算。

### 3，案例：购物车

![1697166874439](./assets/1697166874439.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        table,
        tr,
        td {
            border: 1px solid skyblue;
            border-collapse: collapse;
        }

        td {
            width: 150px;
            height: 50px;
            text-align: center;
            line-height: 50px;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <table>
            <tr>
                <th>商品名称</th>
                <th>单价</th>
                <th>数量</th>
                <th>总价</th>
            </tr>
            <tr v-for="(item,index) in cart">
                <td>{{item.title}}</td>
                <td>{{item.price}}</td>
                <td>
                    <button @click="minus(item)">减一</button>
                    {{item.count}}
                    <button @click="add(item)">加一</button>
                </td>
                <td>{{ item.price * item.count }}</td>
            </tr>
        </table>
        <h2>所有商品总价：{{total}}</h2>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    cart: [{
                            id: 1,
                            title: "手机",
                            price: 1999,
                            count: 1
                        },
                        {
                            id: 2,
                            title: "电脑",
                            price: 9992,
                            count: 1
                        },
                        {
                            id: 3,
                            title: "衣服",
                            price: 29,
                            count: 1
                        },
                        {
                            id: 4,
                            title: "洗衣机",
                            price: 5321,
                            count: 1
                        },
                        {
                            id: 5,
                            title: "篮球",
                            price: 19,
                            count: 1
                        },
                        {
                            id: 6,
                            title: "球杆",
                            price: 2999,
                            count: 1
                        },
                    ]
                }
            },
            computed: {
                // 计算属性普通写成函数的形式
                total() {
                    // 得到购物车中所有商品的单价 * 数量
                    // 第一种方式
                    // 遍历
                    // let sum = 0;
                    // for (let i = 0; i < this.cart.length; i++) {
                    //   sum += this.cart[i].price * this.cart[i].count;
                    // }
                    // return sum;

                    // 第二种方式
                    // let sum = 0;
                    // this.cart.forEach(item => {
                    //   sum += item.price * item.count;
                    // })
                    // return sum;

                    // 第三种方式
                    return this.cart.reduce((prev, next) => prev + next.price * next.count, 0)
                }
            },
            methods: {
                add(item) {
                    item.count += 1
                },
                minux(item) {
                    if (item.count > 1) {
                        item.count -= 1;
                    }
                }
            }
        });
    </script>
</body>

</html>
```

## 四，侦听器

### 1，什么是侦听器 watch

*  作用：用于监听一个变量的变化，然后去做另一件事儿。
*  特点：当侦听器监听引用数据类型时，默认只能监听引用数据类型的第一层。为什么要这样？监听深度越深，Vue在背后要做的事儿越多，这是一种性能损耗，所以一般不要对一个引用类型的变量进行深度监听。
* 如何监听引用数据类型的每一层（深度监听）？侦听器语法这样写  info: { deep: true, handler() {} }为了避免deep:true深度监听导致性能损耗，我们推荐这种写 'info.child.age' () {}
* 在Vue中，侦听器能够监听哪些性质的变量变化呢？能够监听data、计算属性、vuex数据、$route等，凡是那些带有 _ _ _ob_ _ _ 变量都能被监听到。

直接上代码演示：

![1697181942236](./assets/1697181942236.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h2>{{name}}</h2>
        <h2>{{num}}</h2>
        <button @click="num++">+1</button>
        <hr>
        <h2>{{info.age}}</h2>
        <button @click="info.age++">+1</button>
        <hr>
        <h2>{{info.child.age}}</h2>
        <button @click="info.child.age++">+1</button>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    num: 100,
                    info: {
                        name: "ml",
                        age: 18,
                        child: {
                            name: "wc",
                            age: 20
                        }
                    }
                }
            },
            // vue2思想：数据驱动视图
            // vue2是选项式API   optionsAPI
            // vue3是组合式API
            // 在watch中可以写异步代码，在computed中不能写异步代码
            watch: {
                // 监听器（侦听器） 写法一：写在函数的形式
                num(newNum, oldNum) {
                    console.log(newNum, oldNum);
                },
                // info整体是一个对象，
                // info.child.age是info这个对象中的属性
                // 当改变info.child.age，info这个地址没有变
                // 什么叫改变info?
                //    vm.info = {a:111}
                // 这个是用来监听整体info是否变化
                // info(newInfo,oldInfo){
                //   console.log("info变化~");
                //   // console.log(newInfo,oldInfo);
                // },

                // 要监听info中属性的变化，监听器就需要写成对象的形式
                // info: {
                //   deep: true,  // 默认情况下，不会深度监听，侦听的层级越深,vue背后做的事情越多,也是一种性能消耗
                //   // 如果是深度监听，获取到的都是新值
                //   handler(newInfo, oldInfo) {
                //     // console.log(newInfo.child.age, oldInfo.child.age);
                //     console.log(newInfo.child.age);
                //     console.log(oldInfo.child.age);
                //   }
                // }

                // 可以直接对某个对象中的某个属性进行监听
                "info.child.age"(newAge, oldAge) {
                    console.log(newAge, oldAge);
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

当深度监听时，如何获取旧值，代码如下：

![1697182330269](./assets/1697182330269.png)

### 2，案例：百度联想搜索

直接上代码，如下：

![1697183081563](./assets/1697183081563.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        请你输入搜索的关键字: <input type="text" v-model="keyword.a.b">
        <ul>
            <li v-for="(item,index) in arr">
                {{item.q}}
            </li>
        </ul>
    </div>
    <script>
        // https://www.baidu.com/sugrec?pre=1&p=3&ie=utf-8&json=1&prod=pc&from=pc_web&wd=nba&req=2&csor=1&cb=cb&_=1648605785333

        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    keyword: {
                        a: {
                            b: "vue"
                        }
                    },
                    arr: []
                }
            },
            watch: {
                keyword: {
                    deep: true,
                    immediate: true,
                    handler() {
                        // console.log("xxxxxx");
                        let that = this;

                        window.cb = function(data) {
                            console.log("data:", data.g);
                            console.log(this);
                            that.arr = data.g;
                        }

                        let script = document.createElement("script");
                        script.src = `https://www.baidu.com/sugrec?pre=1&p=3&ie=utf-8&json=1&prod=pc&from=pc_web&wd=${this.keyword.a.b}&req=2&csor=1&cb=cb&_=1648605785333`;
                        document.body.prepend(script);
                    }
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

### 3，面试题

* 什么是侦听器？有什么用？
  + 就是vue2中的选项，用于监听一个变量的变化，然后去做另一件事儿。
* 侦听器能不能监听数组/对象的变化？（可以，但默认不监听深层）deep:true
  + 可以的，需要尝试侦听，如果是对象，获取不到旧值，要想获取旧值，需要配合计算属性。
* 侦听器为什么默认不支持深度监听？（性能优化）
  + 监听深度越深，Vue在背后要做的事儿越多，这是一种性能损耗，所以一般不要对一个引用类型的变量进行深度监听。
* 如何监听一个对象中的某个属性变化？（deep:true, 推荐 'obj.key'这种监听写法）
  + “info.child.age”(){}
* 侦听器能监听哪些变量变化？（data、computed、vuex、$route等）
  + data中的数据
  + computed计算属性
  + vuex中的数据
  + $route
  + 其它....

## 五，组件与v-model

### 1，什么是组件化

**Vue核心：**

* 思路：数据驱动视力
* Vue2是选项式API，el，data，methods，computed，watch
* vue是组件化的，一个项目是由N个组件组成的。

**如何理解组件化？**

* 组件是HTML的扩展，使用粒度较小的HTML元素封装成粒度更大的标签（Vue组件）。
* 自定义组件，是前端框架的最重要的技术之一，可以实现快速开发、代码复用、提升可维护性。

**如何自定义组件？**

* 之前new Vue得到的vm，本质也是一个组件，叫根组件，这个组件由一堆选项组件。
* 一个组件，你可以理解成是由一组选项构成的。在封装自定义组件时，你可以使用大多数的Vue选项属性，比如data、template、methods等。
* 对一个组件来讲，最重要的选项是 template选项，用于指定组件的视图结构，在视图结构中你可以使用任意指令。

**如何进行组件注册？**

* 局部注册：components: { 注册名：组件实例 }  局部注册的组件，只能在当前组件作用域中使用。
* 全局注册：Vue.component( 注册名：组件实例)   全局注册的组件，一次注册，在任何其它组件中都可以使用。
* 要注意的是，注册组件时，组件名称名称必须由多个单词用中划线连接。

代码演示：

![1697506107387](./assets/1697506107387.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h1> =======引入子组件(局部注册)======= </h1>
        <!-- 使用组件时，使用的是注册名，使用组件时，当成html标签来用 -->
        <Demo></Demo>
        <Demo></Demo>
        <Demo></Demo>
        <h1> =======引入子组件(全部注册)======= </h1>
        <!-- 如果注册名是大驼峰，使用时，需要变成中划线命名 -->
        <my-son></my-son>
        <my-son></my-son>
        <my-son></my-son>
    </div>
    <script>
        // 创建一个子组件，是一个对象
        const Demo = {
            // 一个组件通常都是有模板的
            template: `
        <div>
          <h1>{{msg}}</h1>
        </div>
      `,
            // 一个普通的组件，它的data必须是一个函数
            data() {
                return {
                    msg: 'malu 666'
                }
            },
        }

        // 全局注册一个组件
        Vue.component("MySon", {
            template: `
        <div>
            <h1>数据列表</h1>
            <table border="1">
                <thead>
                <tr>
                    <th>ID</th>
                    <th>标题</th>
                </tr>
                </thead>
                <tbody>
                <tr v-for="item in dataList">
                    <td>{{item.id}}</td>
                    <td>{{item.title}}</td>
                </tr>
                </tbody>
            </table>
        </div>
      `,
            data() {
                return {
                    dataList: [{
                            id: "1",
                            title: "xxxxxxxxx"
                        },
                        {
                            id: "2",
                            title: "yyyyyyyyy"
                        },
                    ]
                }
            }
        });

        // vm是一个根组件  el是用来指定根组件对应的模板的
        let vm = new Vue({
            el: '#app',
            // 根组件中的data可以是一个对象，也可以是一个函数，函数要求返回一个对象
            data() {
                return {}
            },
            methods: {},
            // components是用来局部注册组件
            // 前面的Demo叫注册名，后面Demo是组件实例
            // 在根组件中注册的，只能在根组件对应的模板中使用
            components: {
                // Demo: Demo
                Demo
            }
        });
    </script>
</body>

</html>
```

### 2，案例：评分组件（体验一下组件化）

**组件化的三大技术：**

* 自定义属性：把父组件中的数据传递给子组件，子组件通过props选项进行接收，也可以通过this来访问。
* 自定义事件：把子中的数据传递给父组件。
* 自定义插槽：把一片html代码，传递给子组件，决定你的子组件的视图长什么样子。
* 组件封装：使用自定义属性、自定义事件、自定义插槽这三大技术实现组件化。

代码如下：

![1697508082810](./assets/1697508082810.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .rate {
            display: flex;
        }

        .rate>span {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: url("./imgs/score.png") center center / 16px 16px;
        }

        .rate>span.on {
            background: url("./imgs/score-on.png") center center / 16px 16px;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- :value="xx" 自定义属性 子组件中接收到数据-->
        <!-- <button @click="fn">点我<button>  在button上绑定click事件  vue中的事件绑定 -->
        <!-- <button onclick="fn">点我<button>  原生的DOM的事件绑定 -->
        <!-- <ml-rate @xxx="fn">点我<button>   ml-rate是组件   @xxx叫自定义事件-->
        <!-- click事件，需要手动点击触发。自定义事件，需要写代码触发（this.$emit('xxx')） -->
        <!-- <ml-rate @click="fn">点我<button>   ml-rate是组件   @click叫自定义事件-->
        <!-- @click="fn"  当click事件发生了，会触发fn函数 -->
        <ml-rate :value="num" @click="num=$event"><strong>配送速度：</strong></ml-rate>
        <ml-rate :value="num2" @click="num2=$event">服务态度：</ml-rate>
    </div>

    <script type="x-template" id="rate">
        <div class="rate">
      <!-- slot叫插槽，预留出来的位置,name是用来指定插槽的名字 -->
      <slot name="default"></slot>
      <span v-for="i in 5" :class="{on:value>=i}" @click="kn(i)"></span>
    </div>
  </script>

    <script>
        let rate = {
            template: "#rate",
            // data是给模板提供数据的，props也是给模板提供数据
            // data叫响应式数据，是可以修改的
            // props是接收到的父组件的数据，是不能直接修改
            props: {
                value: {
                    type: Number, // 期望传递的数据类型
                    default: 0 // 没有传递的话，默认值是0
                }
            },
            methods: {
                kn(i) {
                    // console.log("i=",i);
                    // 触发自定义事件，事件名input
                    this.$emit("click", i)
                }
            }
        };

        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    num: 1,
                    num2: 1
                }
            },
            methods: {
                // fn(i){
                //   // console.log("父接收到子的数据：",i);
                //   this.num = i;
                //   // this.num2 = i;
                // }
            },
            components: {
                'ml-rate': rate
            }
        });
    </script>
</body>

</html>
```

### 3，组件化之自定义属性

vue的核心（特点）：

* 数据驱动视图（无需操作DOM，操作数据）
* 基于选项式API，要学习一堆的选项，后期我带大家看vue2的官方文档
* 组件化开发（自定义属性，自定义事件，自定义插槽）

不管是自定义属性，还是自定义事件，还是自定义插槽，都是解决组件通信问题的。现在我们先讲一下自定义属性，它是实现父中的数据传递给子组件的。当然，通过自定义事件，也可以把子组件中的数据传送给父组件，如下：

![1697509633519](./assets/1697509633519.png)

**父组件传递给子组件**

* 父组件有一些数据，需要子组件来进行展示，可以通过props来完成组件之间的通信
* Props是你可以在组件上注册一些自定义的attribute
* 父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值

直接上代码：

![1697510913960](./assets/1697510913960.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h1>父组件 --- 王健林</h1>
        <hr>
        <!-- :money="money" 自定义属性，值不是字符串，是data中的状态 -->
        <!-- :changeAppMoney="changeAppMoney"  这里的changeAppMoney是一个方法 -->
        <!-- 换句话，我们可以把data中的状态传递给子组件，也可以把methods中的方法传递给子组件 -->
        <!-- 如果传递方法，在脚手架中是没有问题的 -->
        <my-component1 :money="money" :car="car" :changeAppMoney="changeAppMoney"></my-component1>
    </div>

    <script>
        let MyComponent1 = {
            name: "MyComponent1",
            template: `
        <div>
          <h1>王思聪组件</h1>
           <p>收到父的money ---- {{money}}</p>
           <p>收到父的car ---- {{car}}</p>
           <button @click="updateMoney">修改钱</button>
        </div>
      `,
            // props的写法一：写一个数组，数组中放接收到的状态和方法
            // 接收过来的状态或方法，都会挂载到this上
            // props: ["money", "car", "changeAppMoney"],

            // props的写法一：对象写法
            // type的类型可以是：
            // String
            // Number
            // Boolean
            // Array
            // Object
            // Date
            // Function
            // Symbol
            props: {
                money: {
                    // type:String, // 期望父传递的是字符串类型，如果不是，会发出警告
                    type: Number, // 期望父传递的是数字类型，如果不是，会发出警告
                },
                car: {
                    type: String,
                    required: true, // car是必传项，当你在使用这个组件时，必须给我传递一个car,不传递的话，也是会报警告
                },
                changeAppMoney: {
                    type: Function
                }
            },
            methods: {
                updateMoney() {
                    // 调用父组件传递过来的方法
                    // this 表示当前组件实例
                    // this.changeAppMoney();

                    console.log(this.money);
                    console.log(this.car);
                    // console.log(this.changeAppMoney);
                }
            }
        };

        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    money: 10000000,
                    car: "二八大杠",
                    msg: "hello vue"
                }
            },
            methods: {
                changeAppMoney() {
                    console.log("xxxxxxxxxxxx");
                    this.money = "1个小目标"
                },
            },
            components: {
                MyComponent1
            }
        });
    </script>
</body>

</html>
```

### 4，先说一下脚手架

在真实开发，我们都是使用脚手架的，在脚手架中，会采用单文件组件，也就是一个文件，就是一个组件，这个文件的后缀是.vue。单文件组件的特点：

* 代码的高亮（安装必要插件，安装此插件：Vetur）
* ES6、CommonJS的模块化能力
* 组件作用域的CSS
* 可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等

脚手架就是一人工具，要使用这个工具，需要安装，如下：

```shell
npm i @vue/cli -g     # 全局安装脚手工具
npm update @vue/cli -g   # 升级Vue CLI(如果是比较旧的版本，可以通过下面的命令来升级)
vue create 项目名  # 通过Vue的命令来创建项目
```

我先升级一下脚手架工具，如下：

![1697511244798](./assets/1697511244798.png)

有了脚手架，就可以创建项目了，过程如下：

![1697511508197](./assets/1697511508197.png)

![1697511569507](./assets/1697511569507.png)

![1697511647380](./assets/1697511647380.png)

![1697511710735](./assets/1697511710735.png)

![1697511750108](./assets/1697511750108.png)

![1697511797065](./assets/1697511797065.png)

![1697511838683](./assets/1697511838683.png)

使用vscode打开这个文件夹，如下：

![1697512114008](./assets/1697512114008.png)

分析main.js，main.js是项目的入口，如下：

![1697512370133](./assets/1697512370133.png)

分析一下App.vue，如下：

![1697512504930](./assets/1697512504930.png)

删除一些代码如下：

![1697512548057](./assets/1697512548057.png)

目前项目中有两个组件：

* new Vue  得到的根组件   
* App.vue  App组件

如何把项目运行起来呢？

![1697512638110](./assets/1697512638110.png)

运行项目，如下：

![1697512691226](./assets/1697512691226.png)

运行起来后，它内置了一个服务器，托管项目，如下：

![1697512719499](./assets/1697512719499.png)

浏览器访问之，如下：

![1697512752962](./assets/1697512752962.png)

### 5，通过脚手架演示父传子

再通过脚手架项目，演示一下父传子，如下：

![1697513784204](./assets/1697513784204.png)

代码如下：

![1697514508546](./assets/1697514508546.png)

App.vue，如下：

```vue
<template>
  <div id="app">
    <h1>父组件 --- 王健林</h1>
    <hr />
    <my-component-1
      :money="money"
      :car="car"
      :changeAppMoney="changeAppMoney"
    ></my-component-1>
  </div>
</template>

<script>
import MyComponent1 from "./components/MyComponent1.vue";

export default {
  name: "App",
  data() {
    return {
      money: 10000000,
      car: "二八大杠",
    };
  },
  methods: {
    // 定义修改状态的方法
    changeAppMoney(m) {
      // this.money = "1个小目标";
      this.money = m;
    },
  },
  components: {
    MyComponent1,
  },
};
</script>

<style>
</style>

```

MyComponent1.vue，如下：

```vue
<template>
  <!-- 在vue2中，组件的模板，需要一个唯一的根标签 -->
  <div>
    <h1>王思聪组件</h1>
    <p>收到父的money ---- {{ money }}</p>
    <p>收到父的car ---- {{ car }}</p>
    <!-- <button @click="changeAppMoney">修改钱</button> -->
    <button @click="updateMoney">修改钱</button>
  </div>
</template>

<script>
export default {
  name: "MyComponent1",
  // props的第1种写法：
  // props: ["car", "money", "changeAppMoney"],
  // props的第2种写法：
  props: {
    car: {
      type: String,
      default: "xx",
    },
    money: {
      type: Number,
      required: true,
    },
    changeAppMoney: {
      type: Function,
    },
  },
  data() {
    return {
      wscMoney: "2个小目标",
    };
  },
  methods: {
    updateMoney() {
      // this.changeAppMoney();
      this.changeAppMoney(this.wscMoney);
    },
  },
};
</script>

<style>
</style>

```

总结一把：

* 一般情况下，我们是通过自定义属性实现父传子，也就是把父中的数据传递给子。
* 但是也可以通过自定义属性实现子传父，此时传递就是一个函数，在子中调用函数，把子中的数据传递给父。

### 6，案例：TodoMVC(自定义属性)

参考：https://todomvc.com/examples/vue/

#### 1）分析

需要准备两个状态：

* todos：[{text:"学习vuex, So easy~", done:false}, {text:"学习React, So easy~", done:false}]
* visibilty:，筛选的条件 :all completed active

功能：

* 显示todos数据
* 添加一条todos数据
* 删除todos数据
* 编辑todos的内容
* 修改某一项的状态：完成，没有完成之间切换
* 批量修改状态: 全部完成，全部未完成
* 统计没有完成的数量
* 删除已完成的todo
* 三种状态的筛选
* 本地存储(数据的持久化)

页面（静态资源）：

![1697523398840](./assets/1697523398840.png)

拆分组件：

![1697523442100](./assets/1697523442100.png)

把静态资源放到项目中，如下：

![1697523566071](./assets/1697523566071.png)

#### 2）显示todo

把html代码copy到App组件中，如下：

![1697523652613](./assets/1697523652613.png)

浏览器中看效果：

![1697523674642](./assets/1697523674642.png)

引入CSS，如下：

![1697523715676](./assets/1697523715676.png)

浏览器效果如下：

![1697523729609](./assets/1697523729609.png)

开始拆组件，如下：

![1697523925358](./assets/1697523925358.png)

ListTodo.vue对应的代码如下：

```vue
<template>
  <li class="todo completed">
    <div class="view">
      <input type="checkbox" class="toggle" />
      <label>react</label>
      <button class="destroy"></button>
    </div>
    <input type="text" class="edit" style="display: none" />
  </li>
</template>

<script>
export default {
  name: "MyComponent2",
  props: [],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

AddTodo.vue对应的代码如下：

```vue
<template>
  <header class="header">
    <h1>todos</h1>
    <input type="text" placeholder="what need to be done?" class="new-todo" />
  </header>
</template>

<script>
export default {
  name: "AddTodo",
  props: [],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

在App.vue中引入上面的两个组件，如下：

![1697524118369](./assets/1697524118369.png)

浏览器效果如下：

![1697524132975](./assets/1697524132975.png)

把状态定义在App组件中，叫状态提升，如下：

![1697524244023](./assets/1697524244023.png)

有丙个数据（todo），就需要循环出两个ListTodo组件，如下：

![1697524291929](./assets/1697524291929.png)

浏览器效果：

![1697524304938](./assets/1697524304938.png)

把todo传递给子，如下：

![1697524392936](./assets/1697524392936.png)

子接收之，使用之，如下：

![1697524551409](./assets/1697524551409.png)

浏览器效果如下：

![1697524568672](./assets/1697524568672.png)

到此，就实现了显示todo。

#### 3）添加todo

上面已经把添加todo的组件抽离好了，如下：

![1697524641321](./assets/1697524641321.png)

分析：

![1697524774772](./assets/1697524774772.png)

现在todos状态是在App组件中，需要把输入框中输入的todo添加到todos，就是子传父，先收集输入框中的数据，如下：

![1697524906808](./assets/1697524906808.png)

需要把数据传递给父，在父中定义一个方法，把方法先传给子，如下：

![1697524999726](./assets/1697524999726.png)

儿子接收之，并调用之，如下：

![1697525079892](./assets/1697525079892.png)

父中接收数据，拼装todo，把todo放到todos中，如下：

![1697525191102](./assets/1697525191102.png)

到此，把添加todo就实现了。

#### 4）删除todo

需求：

![1697525299199](./assets/1697525299199.png)

小X中子组件中，如下：

![1697525343744](./assets/1697525343744.png)

说白了，就是点击小x，把父中的数据删除掉，子不能直接删除父中的数据，套路和之前一样，在父定义一个方法，子中调用之。在父中定义方法，传给子，子中是有完整的todo，如下：

![1697525527549](./assets/1697525527549.png)

![1697525552061](./assets/1697525552061.png)

子去接收之，并调用之，如下：

![1697525624318](./assets/1697525624318.png)

浏览器测试之，如下：

![1697525649618](./assets/1697525649618.png)

#### 5）切换单个todo的状态

需求：

![1697529659205](./assets/1697529659205.png)

把握住：

* 状态在App组件中，也就是状态在父组件中
* 点击子组件中的checkbox，要去修改父组件中的状态，不能直接修改
* 在父组件中定义一个方法，这个方法中修改状态，把这个方法传递给子组件，让子组件调用

需要在定义中定义一个修改状态的方法，然后把方法传递给子，子去调用之，先在父中定义方法，如下：

![1697529853284](./assets/1697529853284.png)

![1697529884218](./assets/1697529884218.png)

子组件接收之，如下：

![1697529921682](./assets/1697529921682.png)

给子组件中的复选框绑定一个change事件，如下：

![1697530016281](./assets/1697530016281.png)

在调用父的方法时，把todo传递给了父，父就可以得到子传递的数据，数据是todo，在父中就可以修改todo的状态，如下：

![1697530079138](./assets/1697530079138.png)

浏览器测试之，如下：

![1697530134200](./assets/1697530134200.png)

#### 6）全选和反选

状态都在App组件，点击全选时，需要把App组件中的所有的todo都变成true或都变成false。全选按钮在App，如下：

![1697530238492](./assets/1697530238492.png)

当下面每一个todo都选中了，全选按钮也需要选中，如下：

![1697530298516](./assets/1697530298516.png)

使用计算属性，如下：

![1697530476317](./assets/1697530476317.png)

浏览器测试之，如下：

![1697530505411](./assets/1697530505411.png)

然后我们就需要实现全选和反选了，给全选输入框上绑定chagne事件，如下：

![1697531002804](./assets/1697531002804.png)

对于传参问题，分析如下：

![1697531019871](./assets/1697531019871.png)

实现对应的方法，如下：

![1697531041498](./assets/1697531041498.png)

浏览器测试之，如下：

![1697531054606](./assets/1697531054606.png)

#### 7）统计没有完成的数量

需求：

![1697531105047](./assets/1697531105047.png)

统计没有完成的任务的数量，说白了，就是数一数，todos中的任务为false的数量。使用计算属性，代码如下：

![1697531264882](./assets/1697531264882.png)

浏览器测试之，如下：

![1697531285478](./assets/1697531285478.png)

统计没有完成的数量，还有其它的写法，如下：

![1697531383550](./assets/1697531383550.png)

#### 8）删除已完成的todo

需求：

![1697531440471](./assets/1697531440471.png)

如果所有的todo都没有完成，清除的按钮是不能显示的，如下：

![1697531483115](./assets/1697531483115.png)

分析：

* this.todos.length   表示所有todo的数量
* unDoneNumber  表示没有完成的todo的数量
* this.todos.length-unDoneNumber   表示已完成的todo的数量
* this.todos.length-unDoneNumber>0  已完成的todo数量是大于0的，需要清除按钮显示
* this.todos.length>unDoneNumber  已完成的todo数量是大于0的，需要清除按钮显示

经过上面的分析，书写代码如下：

![1697531706941](./assets/1697531706941.png)

浏览器测试之，如下：

![1697531727965](./assets/1697531727965.png)

如果有todo完成了，需要清除已完成，如下：

![1697531899123](./assets/1697531899123.png)

浏览器测试之，如下：

![1697531930540](./assets/1697531930540.png)

#### 9）三种状态的切换

分析：

![1697532177090](./assets/1697532177090.png)

之前已经定义过了visibility，如下：

![1697532209558](./assets/1697532209558.png)

点击下面的三个按钮，就需要改变状态：

![1697532240153](./assets/1697532240153.png)

给上面的三个按钮绑定点击事件，如下：

![1697532298191](./assets/1697532298191.png)

实现方法，如下：

![1697532346291](./assets/1697532346291.png)

浏览器测试之，如下：

![1697532398399](./assets/1697532398399.png)

处理一下样式，如下：

![1697532468933](./assets/1697532468933.png)

浏览器测试之，如下：

![1697532488638](./assets/1697532488638.png)

现在页面上显示什么todo，就需要根据这个visibility来确定了，如下：

![1697532610872](./assets/1697532610872.png)

在模板中，就不能直接遍历所有的todos，要遍历上面的filterTodos，如下：

![1697532657635](./assets/1697532657635.png)

浏览器测试之，如下：

![1697532676537](./assets/1697532676537.png)

#### 10）编辑todo(难度)

双击某个todo时，就需要实现编辑功能，如下：

![1697532763329](./assets/1697532763329.png)

给ListTodo这个组件加一个isEdit数据项，用它来表示当前是否处于编辑状态，如下：

![1697532964644](./assets/1697532964644.png)

当双击todo时，就需要改变状态，如下：

![1697532878612](./assets/1697532878612.png)

浏览器测试之，如下：

![1697532992008](./assets/1697532992008.png)

根据isEdit状态，给li身上添加一个类，叫editing，如下：

![1697533038972](./assets/1697533038972.png)

浏览器测试之，如下：

![1697533086851](./assets/1697533086851.png)

要显示一个输入框，用于编辑，如下：

![1697533126771](./assets/1697533126771.png)

浏览器测试之，如下：

![1697533146168](./assets/1697533146168.png)

输入框，还需要有之前todo的内容，如下：

![1697533236386](./assets/1697533236386.png)

浏览器测试之，如下：

![1697533249259](./assets/1697533249259.png)

在输入框中，可以编辑内容，当按了回车，或失去焦点时，完成编辑，绑定两个事件，如下：

![1697533328931](./assets/1697533328931.png)

然后实现FinishEdit方法，如下：

![1697533478018](./assets/1697533478018.png)

可以得到输入框中的内容，如下：

![1697533499611](./assets/1697533499611.png)

你的目的是改变App组件中的状态，所以还需要把数据传递父，在父中定义方法如下：

![1697533554875](./assets/1697533554875.png)

![1697533576126](./assets/1697533576126.png)

子接收之，如下：

![1697533620853](./assets/1697533620853.png)

子去调用之，调用时，把数据再传递给父，如下：

![1697533702183](./assets/1697533702183.png)

父可以接收到数据，如下：

![1697533751183](./assets/1697533751183.png)

浏览器测试之，如下：

![1697533782921](./assets/1697533782921.png)

到此，编辑就实现了。

#### 11）本地存储

定义一个工具函数，如下：

![1697533965790](./assets/1697533965790.png)

当todos中的数据变化了，就需要存储了，设置一个监听器，如下：

![1697534058723](./assets/1697534058723.png)

存：

![1697534422860](./assets/1697534422860.png)

取：

![1697534211083](./assets/1697534211083.png)

浏览器测试之，如下：

![1697534473530](./assets/1697534473530.png)

### 7，组件化之自定义事件

vue的特点：

* 数组驱动视图
* 基于选项式API  el  data  methods  computed  watch  components  template....
* 组件化开发
  + 自定义属性（父传子，子传父）
  + 自定义事件（子传父）
  + 自定义插槽（父传子（html），子传父）

还可以通过自定义事件实现子传父。操作步骤：

* 在父组件模板中，绑定自定义事件，绑定的自定义事件，都对应了一个回调函数。
* 在子组件中，需要写代码触发自定义事件，在触发自定义事件时，可以把数据传递给父组件。
* 父组件在回调函数中，就可以接收数据，使用数据。

App.vue中的代码如下：

```vue
<template>
  <div class="app">
    <h1>我是父组件 王健林 -- {{ fatherMoney }}</h1>
    <hr />
    <!-- @wc="handler"   @wc表示自定义事件 -->
    <!-- @click="handler"  写在组件上了   @click表示自定义事件 -->
    <!-- 事件源：MySon   事件类型：wc   监听器：handler -->
    <!-- <button @click="fn">xxx</button> 需要鼠标点击button，才能触发-->
    <!--    fn(e){} 点击了button,触发了click事件，浏览器把事件对象传给fn的形参-->
    <!-- wc事件如何触发？答：你需要写代码触发：$emit("wc",110) -->
    <!--    handler(a){}    $emit("wc",110)写在子组件中 -->
    <MySon @wc="handler"></MySon>
  </div>
</template>

<script>
import MySon from "./components/MySon.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {
      fatherMoney: 0,
    };
  },
  methods: {
    handler(a) {
      console.log("收到子传递过来的数据：", a);
      this.fatherMoney = a;
    },
  },
  components: {
    MySon,
  },
};
</script>

<style>
* {
  margin: 0;
  padding: 0;
}
html,
body {
  width: 100%;
  height: 100%;
}
.app {
  width: 100%;
  height: 100%;
  background-color: pink;
}
</style>
```

MySon.vue中的代码如下：

```vue
<template>
  <div class="son">
    <h1>我是子组件 王思聪</h1>
    <!-- @click="clickHandler" 不叫自定义事件 -->
    <button @click="clickHandler">触发自定义事件</button>
  </div>
</template>

<script>
export default {
  name: "MySon",
  props: [],
  data() {
    return {
      money: 500,
    };
  },
  methods: {
    clickHandler() {
      // console.log("clickHandler....");

      this.$emit("wc", this.money);
    },
  },
};
</script>

<style scoped>
div.son {
  width: 300px;
  height: 200px;
  background-color: gold;
  margin: 50px;
}
</style>
```

浏览器效果如下：

![1697593027479](./assets/1697593027479.png)

如何是在哪里绑定自定义事件的？

![1697593072299](./assets/1697593072299.png)

除上面的绑定自定义事件之外，还可以在另一个地方绑定，如下：

![1697593454762](./assets/1697593454762.png)

![1697593467522](./assets/1697593467522.png)

总结一下，自定义事件是为了实现子传父，把子中的数据传递给父，我们就可以改造一下昨天的TodoMVC。昨天的TodoMVC中也有子传父，昨天是通过自定义属性实现，今天你就可以把自定义属性实现的子传父，通过自定义事件改造一下。

### 8，案例：TodoMVC(自定义事件)

### 9，组件化之自定义插槽

自定义插槽也是为了实现父子间通信，插槽分三类：

* 匿名插槽
* 具名插槽
* 作用域插槽

#### 1）案例：Pannel(匿名插槽)

直接上代码：

![1697594668739](./assets/1697594668739.png)

App.vue代码如下 ：

```vue
<template>
  <div>
    <div>App</div>
    <UserSlot></UserSlot>
  </div>
</template>

<script>
import UserSlot from "./views/UserSlot.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {};
  },
  methods: {},
  components: {
    UserSlot,
  },
};
</script>

<style lang="less" scoped>
</style>
```

UserSlot.vue代码如下：

```vue
<template>
  <div>
    <h2>UserSlot</h2>
    <!-- 码路666 传给子组件的插槽 -->
    <!-- 换句话说，在我们使用Pannel组件时，可以给Pannel组件传递一片html结构 -->
    <Pannel><span>码路666</span></Pannel>
    <hr>
    <!-- 在使用Pannel组件时没有给插槽插入html结构 -->
    <Pannel></Pannel>
  </div>
</template>

<script>
import Pannel from "@/components/Pannel.vue";
export default {
  name: "UserSlot",
  props: [],
  data() {
    return {};
  },
  methods: {},
  components: {
    Pannel,
  },
};
</script>

<style lang="less" scoped>
</style>
```

Pannel.vue代码如下：

```vue
<template>
  <div>
    <!-- 标题 -->
    <div class="title">
      <h4>欢迎来到码路学习</h4>
      <span class="btn" @click="isShow = !isShow">
        {{ isShow ? "收起" : "展开" }}
      </span>
    </div>
    <div class="container" v-show="isShow">
      <!-- slot就是一个插槽， 插槽没有名字，叫匿名插槽-->
      <!-- 当没有人给插槽插入内容时，就显示默认内容 -->
      <slot>我是默认值</slot>

      <!-- 插槽可以有多个，你插入的内容分别都会向这些插槽中插入内容  -->
      <slot>我是默认值</slot>
      <slot>我是默认值</slot>
      <slot>我是默认值</slot>
    </div>
  </div>
</template>

<script>
export default {
  name: "Pannel",
  props: [],
  data() {
    return {
      isShow: false,
    };
  },
  methods: {},
};
</script>

<style scoped>
h3 {
  text-align: center;
}

.title {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid #ccc;
  padding: 0 1em;
}

.title h4 {
  line-height: 2;
  margin: 0;
}

.container {
  border: 1px solid #ccc;
  padding: 0 1em;
}

.btn {
  /* 鼠标改成手的形状 */
  cursor: pointer;
}

img {
  width: 50%;
}
</style>
```

#### 2）案例：Pannel(具名插槽)

UserSlot.vue代码如下：

```vue
<template>
  <div>
    <h2>UserSlot</h2>
    <Pannel>
      <template v-slot:title>
        <h4>欢迎大家来码路学习</h4>
      </template>

      <template v-slot:content>
        <img src="../assets/logo.png" alt="" />
      </template>

      <template v-slot:footer>
        <p>我是底部内容</p>
      </template>
    </Pannel>

    <hr />

    <Pannel>
      <template v-slot:title>
        <h4>xxxxxxxxx</h4>
      </template>

      <template v-slot:content>
        yyyyyyyyyyyyyyyy
      </template>

      <template v-slot:footer>
        <p>zzzzzzzzzzzzzz</p>
      </template>
    </Pannel>
  </div>
</template>

<script>
import Pannel from "@/components/Pannel.vue";
export default {
  name: "UserSlot",
  props: [],
  data() {
    return {};
  },
  methods: {},
  components: {
    Pannel,
  },
};
</script>

<style lang="less" scoped>
</style>
```

Pannel.vue代码如下：

```vue
<template>
  <div>
    <div class="title">
      <!-- <h4>欢迎来到码路学习</h4> -->
      <!-- name="title" 给插槽起名字 -->
      <slot name="title">我是title默认值</slot>
      <span class="btn" @click="isShow = !isShow">
        {{ isShow ? "收起" : "展开" }}
      </span>
    </div>
    <div class="container" v-show="isShow">
      <slot name="content">我是content默认值</slot>
      <slot name="footer">我是footer默认值</slot>
    </div>
  </div>
</template>

<script>
export default {
  name: "Pannel",
  props: [],
  data() {
    return {
      isShow: false,
    };
  },
  methods: {},
};
</script>

<style scoped>
h3 {
  text-align: center;
}

.title {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid #ccc;
  padding: 0 1em;
}

.title h4 {
  line-height: 2;
  margin: 0;
}

.container {
  border: 1px solid #ccc;
  padding: 0 1em;
}

.btn {
  /* 鼠标改成手的形状 */
  cursor: pointer;
}

img {
  width: 50%;
}
</style>
```

浏览器效果如下：

![1697595246967](./assets/1697595246967.png)

#### 3）案例：Pannel(作用域插槽)

匿名插槽和具名插槽的作用也是父传子，只不过传递的是一片html代码。接下来我们讲的作用域插槽，它是为了实现子传父的。作用域插槽使用场景：使用组件时，组件中定义了数据，向插槽中插入的数据，来自于子组件。

使用步骤：

* 在slot标签上，使用自定义属性和组件内数据进行关联
* 使用组件时，在template标签上使用v-slot="scope"

UserSlot.vue 代码：

```vue
<template>
  <div>
    <h2>UserSlot</h2>
    <Pannel>
      <template v-slot="scoped">
        <p>{{ scoped.row.name2 }}</p>
      </template>
    </Pannel>
  </div>
</template>

<script>
import Pannel from "@/components/Pannel.vue";
export default {
  name: "UserSlot",
  props: [],
  data() {
    return {};
  },
  methods: {},
  components: {
    Pannel,
  },
};
</script>

<style lang="less" scoped>
</style>
```

Pannel.vue的代码：

```vue
<template>
  <div>
    <div class="title">
      <h4>欢迎来到码路学习</h4>
      <span class="btn" @click="isShow = !isShow">
        {{ isShow ? "收起" : "展开" }}
      </span>
    </div>
    <div class="container" v-show="isShow">
      <slot :row="obj">我是默认值</slot>
    </div>
  </div>
</template>

<script>
export default {
  name: "Pannel",
  props: [],
  data() {
    return {
      isShow: false,
      obj: {
        name1: "码路",
        name2: "漫漫",
      },
    };
  },
  methods: {},
};
</script>

<style scoped>
h3 {
  text-align: center;
}

.title {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid #ccc;
  padding: 0 1em;
}

.title h4 {
  line-height: 2;
  margin: 0;
}

.container {
  border: 1px solid #ccc;
  padding: 0 1em;
}

.btn {
  /* 鼠标改成手的形状 */
  cursor: pointer;
}

img {
  width: 50%;
}
</style>
```

效果如下：

![1697596981898](./assets/1697596981898.png)

### 10，案例：ML-Table

直接上代码，MlTable.vue，如下：

```vue
<template>
  <div>
    <table border="1">
      <thead>
        <tr>
          <th>序号</th>
          <th>姓名</th>
          <th>年龄</th>
          <th>头像</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="(item, index) in userList" :key="index">
          <td>{{ index + 1 }}</td>
          <td>{{ item.name }}</td>
          <td>{{ item.age }}</td>
          <td>
            <!-- <img :src="item.headImgUrl" alt="" /> -->
            <slot :row="item">默认头像</slot>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script>
export default {
  name: "MlTable",
  props: ["userList"],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style scoped>
img {
  width: 60px;
  height: 60px;
}
</style>
```

UserSlot.vue，如下：

```vue
<template>
  <div>
    <!-- 后面写项目，会使用到elementui，里面就使用到了作用域插槽  -->
    <h2>作用域插槽</h2>
    <MlTable :userList="userList">
      <template v-slot="scope">
        <img style="width: 100px" :src="scope.row.headImgUrl" alt="" />
      </template>
    </MlTable>

    <hr />

    <h2>匿名插槽</h2>
    <!-- 
      作用域插槽：向子组件插入的内容来自于子组件
     -->
    <MlTable :userList="userList">
      <template>
        <img
          style="width: 100px"
          src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png"
          alt=""
        />
      </template>
    </MlTable>
    <hr />

    <h2>通过自定义属性实现父传子</h2>
    <MlTable :userList="userList"></MlTable>
  </div>
</template>

<script>
import MlTable from "@/components/MlTable.vue";
export default {
  name: "UserSlot",
  props: [],
  data() {
    return {
      userList: [
        {
          name: "码路1",
          age: 18,
          headImgUrl:
            "https://img2.baidu.com/it/u=3382280178,2686574621&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=750",
        },
        {
          name: "码路2",
          age: 18,
          headImgUrl:
            "https://img2.baidu.com/it/u=3382280178,2686574621&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=750",
        },
        {
          name: "码路3",
          age: 18,
          headImgUrl:
            "https://img2.baidu.com/it/u=3382280178,2686574621&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=750",
        },
        {
          name: "码路4",
          age: 18,
          headImgUrl:
            "https://img2.baidu.com/it/u=3382280178,2686574621&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=750",
        },
        {
          name: "码路5",
          age: 18,
          headImgUrl:
            "https://img2.baidu.com/it/u=3382280178,2686574621&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=750",
        },
      ],
    };
  },
  methods: {},
  components: {
    MlTable,
  },
};
</script>

<style lang="less" scoped>
</style>
```

效果如下：

![1697597835270](./assets/1697597835270.png)

### 11，再次体验那个评分组件

MlRate.vue:

```vue
<template>
  <div class="rate">
    <slot name="default"></slot>
    <span
      v-for="i in 5"
      :key="i"
      :class="{ on: value >= i }"
      @click="$emit('input', i)"
    ></span>
  </div>
</template>

<script>
export default {
  name: "MyComponent2",
  props: ["value"],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style scoped>
.rate {
  display: flex;
  line-height: 30px;
  align-items: center;
  font-size: 14px;
}
.rate > span {
  display: inline-block;
  width: 16px;
  height: 16px;
  background: url("../assets/score.png") center center / 16px 16px;
}
.rate > span.on {
  display: inline-block;
  width: 16px;
  height: 16px;
  background: url("../assets/score-on.png") center center / 16px 16px;
}
</style>
```

App.vue:

```vue
<template>
  <div>
    <div>App</div>
    <hr />
    <MlRate :value="num1" @input="num1 = $event">配送速度：</MlRate>
    <MlRate :value="num2" @input="num2 = $event">服务态度：</MlRate>
  </div>
</template>

<script>
import MlRate from "./components/MlRate.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {
      num1: 1,
      num2: 1,
    };
  },
  methods: {},
  components: {
    MlRate,
  },
};
</script>

<style lang="less" scoped>
</style>
```

效果如下：

![1697598520253](./assets/1697598520253.png)

### 12，v-model写在组件

之前讲过v-model就是一个语法糖，是:value+@input的语法糖。看如下的代码：

![1697599030836](./assets/1697599030836.png)

### 13，v-model写在标签上

直接上代码：

![1697599799405](./assets/1697599799405.png)

参考代码：

```vue
<template>
  <div>
    <div>App</div>

    <input type="text" v-model="name" />
    <input type="text" :value="name" @input="name=$event.target.value"/>  <br>

    <!-- radio:  收集radio时，也是需要手动指定value，收集的也是value  -->
    <input type="radio" v-model="gender" value="0">   男
    <input type="radio" v-model="gender" value="1">   女
    <hr>
    <!-- v-model: :checked +  @change -->
    <input type="radio" value="0" :checked="gender=='0'" @change="gender=$event.target.value">   男
    <input type="radio" value="1" :checked="gender==1" @change="gender=$event.target.value">   女

    <!-- checkbox -->
    <input type="checkbox" value="001" v-model="hobbiey" />  001
    <input type="checkbox" value="002" v-model="hobbiey" />  002
    <input type="checkbox" value="003" v-model="hobbiey" />  003
    <!-- 在checkbox 上，不使用v-model，达到v-model的效果，怎么办？ -->

    <!-- select 下拉菜单 -->
    <!-- v-model: :selected +  @change -->
    <select v-model="level">
        <option value="001">AAA</option>
        <option value="002">BBB</option>
        <option value="003">CCC</option>
    </select>
    <select :selected="level" @change="level=$event.target.value">
        <option value="001">AAA</option>
        <option value="002">BBB</option>
        <option value="003">CCC</option>
    </select>
  </div>
</template>

<script>
import MlRate from "./components/MlRate.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {
      name: "码路",
      gender:"1",
       hobbiey: ['001'],
       level: "001"
    };
  },
  methods: {},
  components: {
    MlRate,
  },
};
</script>

<style lang="less" scoped>
</style>
```

如果v-model写在checkbox上，如果不使用v-model，达到v-model的效果：

![1697599861886](./assets/1697599861886.png)

### 12，面试题

* 为什么组件中的data必须是一个函数？
  
  + 因为组件是可以复用的，如果不是一个函数，是一个对象的话，多个组件实例的data是指向同一个堆空间，数据相互影响。
  
* 为什么是根组件的data可以是一个对象？
  
  + 因为它不需要复用。
  
* 什么是组件化？你是如何理解组件？
  + 现在主流的开发框，都是基于组件化的，组件的作用就是为了实现UI和逻辑的复用，在vue组件中，提供了很多的选项，如data, computed, watch, method, components, filter... 可以方便我们实现业务逻辑，组件化的好处就是可以复用UI和逻辑，在业务开发中，一般都会合理的划分组件，在vue中组件化的核心就是**自定义属性**，**自定义事件**，**自定义插槽**。组件与组件通信常见的有8种方案，比如：... 展开讲   如果看过源码，可以从源码角度分析组件的实现过程。

* 你工作中有没有封装过比较好的组件？

  + 面试之前，需要封装几个组件，真实开发中，不会自己封装，都是用第三方封装好的，或公司自己的组件库。

## 六，组件的生命周期

**vue的核心：**

* 数据驱动视图（响应式原理）
* 基于选项式API，学习Vue2，要学习一堆的选项，业务逻辑就写在选项中
* 组件化开发（自定义属性，自定义事件，自定义插槽），组件通信，生命周期。new Vue得到一个组件，叫根组件。xxx.vue，这个也是一个组件，它不需要new。

### 1，生命周期

**生命周期（组件从“生”到“死”的全过程）**‘

* 创建阶段：beforeCreate、created
* 挂载阶段：beforeMount、mounted
* 更新阶段：beforeUpdate、updated
* 销毁阶段：beforeDestroy、destroyed

上代码Test.vue，如下：

```vue
<template>
  <div>
    <h1>Test组件</h1>
    <p ref="cur">{{ count }}</p>
    <button @click="add">+1</button>
  </div>
</template>

<script>
export default {
  name: "Test",
  props: [],
  // 生命周期函数，在项目中基本上没有用
  // 声明methods中的方法 和 声明生命周期钩子函数
  beforeCreate() {
    // 组件实例刚开始创建，实例还没有创建完毕，
    // 在这个函数中，不能获取data和methods
    console.log("初始化阶段(beforeCreate)：", this.count);
  },
  // 注入一些数据，初始化响应式系统（data中的数据和methods可以访问了）
  // 作用：1）在项目中，发ajax（调接口）  2）获取路由参数
  //   在created中发请求，获取到真实数据，修改状态，模板会自动更新，浏览器呈现出内容
  created() {
    console.log("初始化阶段(created)：", this.count);
  },
  // 通过el template $mount找模板
  //   会把模板变成render函数  内部调用render函数生成虚拟DOM（使用JS对象模拟真实DOM）
  //   一个真实DOM的中的属性非常多，操作真实DOM性能就差一点，如何采用JS对象模拟真实DOM
  //   它的属性就可以少很多，浏览器运行JS的速度肯定比操作DOM的性能。
  //    虚拟DOM要转人成真实DOM，进行挂载，只有挂载到DOM树上，页面才会显示
  beforeMount() {
    // 在这个钩子中，你不能操作DOM，因为DOM还没有挂载完毕
    // 在项目中，用的也不多
    console.log("挂载阶段(beforeMount)：", this.$refs.cur);
  },
  // 已经转化成了真实DOM。挂载完毕，页面显示出来
  // 可以获取DOM元素，有人喜欢在这里发送ajax请求
  // 能做什么？1）调接口  2）操作DOM  3）开定时   4）建立webscoket连接  5）实例化echarts
  mounted() {
    console.log("挂载阶段(mounted)：", this.$refs.cur);
  },
  // 状态发生变化了，进入更新阶段
  // 只有响应式数据发生变化了，才会触发这个钩子函数
  beforeUpdate() {
    console.log("更新阶段(beforeUpdate)：", this.count);
  },
  // 更新完毕
  // 更新完毕之前做什么？
  //   要生成新的虚拟DOM，新的虚拟DOM和老的虚拟DOM进行对比，找到差异
  //   会执行patch运算，diff算法，找到两个虚拟DOM的最小差异，找到后，进行异步更新
  //   这样，就尽可以少的操作DOM，提升性能   key的作用，让我们尽可能快的找到差异
  // 也是只有数据发生变化了，才会执行，有点类似于watch侦听器，还有点类似$nextTick();
  //  不要是这里更新数据，会导致死循环
  updated() {
    console.log("更新阶段(updated)：", this.count);
  },
  // 什么时候组件会死？
  //   1）v-if  切换时
  //   2）手动调用$destory()
  //   3）路由切换
  //   4）动态组件
  //    ....
  beforeDestroy() {
    // 在这里一般做一些收尾工作
    //    1）关闭定时器   2）DOM事件的解绑  3）优化项目性能  4）清缓存...
    console.log("销毁阶段(beforeDestroy)：");
  },
  // 移除当前组件的watcher，DOM就无法再更新
  // 移除所有子组件
  // 移除事件监听器
  // 此时，响应式系统就失效了
  // 组件销毁了，并不是说界面看不见了，组件实例还在的，只是它不工作。
  destroyed() {
    // 这个钩子函数没用
    console.log("销毁阶段(destroyed)：");
  },
  data() {
    return {
      count: 1,
      newsList: [],
    };
  },
  methods: {
    add() {
      this.count++;
    },
  },
};
</script>

<style lang="less" scoped>
</style>
```

App.vue，如下：

```vue
<template>
  <div>
    <h1>App</h1>
    <hr />
    <Test v-if="isShow"></Test>
    <button @click="isShow = !isShow">组件销毁与创建</button>
  </div>
</template>

<script>
import Test from "./components/Test.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {
      isShow: true,
    };
  },
  methods: {},
  components: {
    Test,
  },
};
</script>

<style lang="less" scoped>
</style>
```

浏览器效果如下：

![1697681562908](./assets/1697681562908.png)

**与动态组件有关的两个特殊的钩**

* activated(激活)、deactivated(休眠)
* 与组件异常捕获有关的一个钩子：errorCaptured

### 2，生命周期图

<img src="https://tubie.gitee.io/fe-blog/assets/img/image-20210224084130350.50ebca2b.png" style="zoom: 80%; ">

### 3，面试题

* Vue常用的生命周期有哪些？
* 在创建/挂载/更新/销毁阶段，Vue在背后分别做了些什么事儿？
* 哪些生命周期钩子可以执行多次？哪些执行一次？
* 响应式原理，发生在Vue哪些生命周期阶段？
* 虚拟DOM，在哪些阶段生成的？
* 什么虚拟DOM？（是一个很大的JSON数据，用于描述视图模板的，保存在内存中）
* 虚拟DOM存在的价值点在哪里？（更新，把DOM更新粒度降到最低，规避人为DOM滥操作）
* 什么diff运算？（在更新阶段，patch对新旧虚拟DOM进行对比，找出脏节点，提交更新）
* 还有很多与生命周期有关的面试题

## 七，动态组件

### 1，什么是动态组件

* 作用：有种v-if的感觉，根据指定条件渲染目标组件，它的is属性等于哪个组件，就显示哪个组件。

* 场景：它经常配合keep-alive一起使用。被keep-alive包裹的组件不会销毁，你可以理解成是对组件的一种缓存。
* 两个生命周期函数：被动态组件包裹过的组件多了两个生命周期钩子：activated(激活)、deactivated(休眠)
* keep-alive属性之include，包含在include数组中的组件不会“死”
* keep-alive属性之exclude，不包含在exclude数组中的组件不会“死”

代码：

![1697684297901](./assets/1697684297901.png)

App.vue代码：

```vue
<template>
  <div>
    <!-- <Home></Home>
    <About></About>
    <User></User> -->

    <!-- component 和 slot一样，是vue内置的组件 -->
    <!-- <component :is="comp"></component> -->

    <!-- keep-alive 缓存组件，不让组件死   computed是缓存数据 -->
    <!-- 默认是缓存所有的组件，include可以指定缓存哪些组件 -->
    <!-- <keep-alive :include="['Home','About']"> -->
    <keep-alive :exclude="['Home']">
      <component :is="comp"></component>
    </keep-alive>

    <!-- <Tabbar :value="comp" @input="comp = $event"></Tabbar> -->
    <Tabbar v-model="comp"></Tabbar>
  </div>
</template>

<script>
import Home from "./components/Home.vue";
import About from "./components/About.vue";
import User from "./components/User.vue";
import Tabbar from "./components/Tabbar.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {
      comp: "Home",
    };
  },
  methods: {},
  components: {
    Home,
    About,
    User,
    Tabbar,
  },
};
</script>

<style lang="less" scoped>
</style>
```

Home.vue代码：

```vue
<template>
  <div>
    <h1>首页</h1>
    <input type="text" v-model="a" />
  </div>
</template>

<script>
export default {
  name: "Home",
  props: [],
  created() {
    console.log("Home 创建完毕~");
  },
  beforeDestroy() {
    console.log("Home 销毁了~");
  },
  activated() {
    console.log("Home 激活了");
  },
  deactivated() {
    console.log("Home 睡觉了");
  },
  data() {
    return {
      a: 1,
    };
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

About.vue代码：

```vue
<template>
  <div>
    <h1>关于</h1>
    <input type="text" v-model="a"/>
  </div>
</template>

<script>
export default {
  name: "About",
  props: [],
   created(){
    console.log("About 创建完毕~");
  },
  beforeDestroy(){
    console.log("About 销毁了~");
  },
  data() {
    return {
      a:2
    };
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

User.vue代码：

```vue
<template>
  <div>
    <h1>我的</h1>
    <input type="text" v-model="a"/>
  </div>
</template>

</template>

<script>
export default {
  name: "User",
  props: [],
  created() {
    console.log("User 创建完毕~");
  },
  beforeDestroy() {
    console.log("User 销毁了~");
  },
  data() {
    return {
      a:3
    };
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

Tabbar.vue代码：

```vue
<template>
  <div class="tabbar">
    <span
      v-for="item in list"
      :key="item.id"
      :class="{ on: item.tab == value }"
      @click="$emit('input',item.tab)"
      >{{ item.label }}</span
    >
  </div>
</template>

<script>
export default {
  name: "Tabbar",
  props: ["value"],
  data() {
    return {
      list: [
        { id: 1, tab: "Home", label: "首页" },
        { id: 2, tab: "About", label: "关于" },
        { id: 3, tab: "User", label: "我的" },
      ],
    };
  },
  methods: {},
};
</script>

<style scoped>
.tabbar {
  height: 60px;
  line-height: 60px;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
}

.tabbar > span {
  flex: 1;
  border: 1px solid #ccc;
  text-align: center;
  cursor: pointer;
}

.tabbar > span.on {
  color: red;
}
</style>
```

### 2，案例：Tabbar

![1697682424674](./assets/1697682424674.png)

拆组件：

![1697685116779](./assets/1697685116779.png)

创建出这五个组件，并绘制，如下：

![1697685967150](./assets/1697685967150.png)

App.vue:

```vue
<template>
  <div>
    <MyHeader
      background="skyblue"
      fontColor="red"
      title="TabBar案例"
    ></MyHeader>

    <div class="main">
      <component :is="comName"></component>
    </div>

    <MyTabbar :arr="tabList" @changeCom="changeCom"></MyTabbar>
  </div>
</template>

<script>
import MyHeader from "./components/MyHeader.vue";
import MyTabbar from "./components/MyTabbar.vue";

import GoodsList from "./views/GoodsList.vue";
import GoodsSearch from "./views/GoodsSearch.vue";
import UserInfo from "./views/UserInfo.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {
      comName: "GoodsList",
      tabList: [
        {
          iconText: "icon-shangpinliebiao",
          text: "商品列表",
          componentName: "GoodsList",
        },
        {
          iconText: "icon-sousuo",
          text: "商品搜索",
          componentName: "GoodsSearch",
        },
        {
          iconText: "icon-user",
          text: "我的信息",
          componentName: "UserInfo",
        },
      ],
    };
  },
  methods: {
    changeCom(comName) {
      this.comName = comName;
    },
  },
  components: {
    GoodsList,
    GoodsSearch,
    UserInfo,

    MyHeader,
    MyTabbar,
  },
};
</script>

<style scoped>
.main {
  padding-top: 45px;
  padding-bottom: 50px;
}
</style>
```

MyHeader.vue:

```vue
<template>
  <div
    class="my-header"
    :style="{ backgroundColor: background, color: fontColor }"
  >
    {{ title }}
  </div>
</template>

<script>
export default {
  name: "MyHeader",
  props: ["background", "fontColor", "title"],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style scoped>
.my-header {
  height: 45px;
  line-height: 45px;
  text-align: center;
  position: fixed;
  font-weight: bold;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 10;
}
</style>
```

MyTabbar.vue:

```vue
<template>
  <div class="tab-bar">
    <div
      :class="{ current: index === selIndex }"
      @click="clickBtn(index, obj)"
      v-for="(obj, index) in arr"
      :key="index"
      class="tab-item"
    >
      <span class="iconfont" :class="obj.iconText"></span>
      <span>{{ obj.text }}</span>
    </div>
  </div>
</template>

<script>
export default {
  name: "MyTabbar",
  props: ["arr"],
  data() {
    return {
      selIndex: 0, // 默认就第1个变亮
    };
  },
  methods: {
    clickBtn(index, obj) {
      this.selIndex = index;
      this.$emit("changeCom", obj.componentName);
    },
  },
};
</script>

<style scoped>
.tab-bar {
  position: fixed;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 50px;
  border-top: 1px solid red;
  display: flex;
  justify-content: space-around;
  background-color: #fff;
}
.tab-bar .tab-item {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.current {
  color: red;
}
</style>
```

GoodsList.vue:

```vue
<template>
  <div>
      <h2>GoodsList</h2>
  </div>
</template>

<script>
export default {
  name: "GoodsList",
  props:[],
  data() {
    return {

    };
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

GoodsSearch.vue:

```vue
<template>
  <div>
      <h2>GoodsSearch</h2>
  </div>
</template>

<script>
export default {
  name: "GoodsSearch",
  props:[],
  data() {
    return {

    };
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

UserInfo.vue:

```vue
<template>
  <div>
    <h2>UserInfo</h2>
  </div>
</template>

<script>
export default {
  name: "UserInfo",
  props: [],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

准备一个假数据，模拟是ajax请求回来的，如下：

![1697686261188](./assets/1697686261188.png)

在商品列表页面中，引入数据，如下 ：

![1697686351249](./assets/1697686351249.png)

昨天我们封装了一个MlTable组件，使用之，如下：

![1697687027709](./assets/1697687027709.png)

参考代码：

```vue
<template>
  <table class="table table-bordered table-striped">
    <thead>
      <tr>
        <!-- <th>#</th>
        <th>商品名称</th>
        <th>价格</th>
        <th>标签</th>
        <th>操作</th> -->
        <slot name="header"></slot>
      </tr>
    </thead>
    <tbody>
      <tr v-for="obj in data" :key="obj.id">
        <!-- <td>111</td>
        <td>222</td>
        <td>333</td>
        <td>444</td>
        <td>555</td> -->

        <!-- name 说明是具名插槽  :row="obj" 作用域插槽  -->
        <slot name="body" :row="obj"></slot>
      </tr>
    </tbody>
  </table>
</template>

<script>
export default {
  name: "MyTable",
  props: ["data"],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style lang="less" scoped>
</style>
```

安装bootstrap，使用之，如下：

```shell
npm i boostrap@4.6.0
```

![1697687098808](./assets/1697687098808.png)

使用MyTable组件，如下：

![1697687114796](./assets/1697687114796.png)

参考代码如下：

```vue
<template>
  <div>
    <MyTable :data="list">
      <!-- <template v-slot:header> -->
      <template #header>
        <th>#</th>
        <th>商品名称</th>
        <th>价格</th>
        <th>标签</th>
        <th>操作</th>
      </template>
      <template #body="scope">
        <td>{{ scope.row.id }}</td>
        <td>{{ scope.row.goods_name }}</td>
        <td>{{ scope.row.goods_price }}</td>
        <td>
          <button class="btn btn-primary btn-sm add-tag">+Tag</button>
          <span v-for="(str, idx) in scope.row.tags" :key="idx">
            {{ str }}
          </span>
        </td>
        <td>
          <button class="btn btn-danger btn-sm">删除</button>
        </td>
      </template>
    </MyTable>
  </div>
</template>

<script>
import MyTable from "../components/MyTable.vue";
import data from "../assets/data.json";
export default {
  name: "GoodsList",
  props: [],
  data() {
    return {
      list: data.data,
    };
  },
  methods: {},
  components: {
    MyTable,
  },
};
</script>

<style lang="less" scoped>
</style>
```

浏览器效果如下：

![1697687154719](./assets/1697687154719.png)

到此，我们就绘制了商品列表页。下午我们实现对应的功能。

下午把Tabbar的功能实现了，如下：

```vue
<template>
  <div>
    <MyTable :data="list" v-if="list.length > 0">
      <!-- <template v-slot:header> -->
      <template #header>
        <th>#</th>
        <th>商品名称</th>
        <th>价格</th>
        <th>标签</th>
        <th>操作</th>
      </template>
      <template #body="scope">
        <td>{{ scope.row.id }}</td>
        <td>{{ scope.row.goods_name }}</td>
        <td>{{ scope.row.goods_price }}</td>
        <td>
          <input
            type="text"
            class="form-control"
            style="width: 90px"
            v-if="scope.row.inputVisible"
            v-model="scope.row.inputValue"
            @keydown.enter="enterFn(scope.row)"
            @keydown.esc="scope.row.inputValue = ''"
            @blur="blurFn(scope.row)"
          />
          <button
            class="btn btn-primary btn-sm add-tag"
            @click="scope.row.inputVisible = true"
          >
            +Tag
          </button>
          <span v-for="(str, idx) in scope.row.tags" :key="idx">
            {{ str }}
          </span>
        </td>
        <td>
          <button class="btn btn-danger btn-sm" @click="remove(scope.row.id)">
            删除
          </button>
        </td>
      </template>
    </MyTable>

    <div v-else>购物车空空如也~</div>
  </div>
</template>

<script>
import MyTable from "../components/MyTable.vue";
import data from "../assets/data.json";
export default {
  name: "GoodsList",
  props: [],
  data() {
    return {
      list: data.data,
      // list: [],
    };
  },
  methods: {
    remove(id) {
      // console.log(id);
      let idx = this.list.findIndex((obj) => obj.id === id);
      this.list.splice(idx, 1);
    },
    enterFn(obj) {
      if (obj.inputValue.trim() == "") {
        alert("内容不能为空~");
        return; // 结束函数
      }
      obj.tags.push(obj.inputValue);
      obj.inputValue = "";
      obj.inputVisible = false;
    },
    blurFn(obj) {
      obj.inputValue = "";
      obj.inputVisible = false;
    },
  },
  components: {
    MyTable,
  },
};
</script>

<style lang="less" scoped>
</style>
```

浏览器效果：

![1697700270847](./assets/1697700270847.png)

### 3，面试题

* 在Vue中实现条件渲染渲染有哪些办法？v-if / v-show / component is

  + v-if
  + v-show
  + 动态组件
* 什么是动态组件？keep-alive include exclude 还有两个新的生命周期钩子

  + 就是vue中内置的一个组件，叫component 通过它的is属性，可以决定显示什么样的组件
  + 通过情况下，会配置keep-alive进行使用，keep-alive是用来缓存一个组件
  + keep-alive中有两个属性，叫include和exclude
  + 和动态组件相关的还有两个生命周期函数，叫activated和deactivated
* mounted和activated有什么区别？deactivated和beforeDestroy有什么区别？（执行次数、使用场景）

  + 自己去总结一下
* Vue有哪些内置组件？（插槽、动态组件、过渡动画、component）

  + slot
  + component
  + transition
  + keep-alive
  + transition-group
* 哪些场景下你会用到动态组件？

  + 当要缓存一些组件时，会使用动态组件，要缓存的组件，它里面的数据通常是静态

## 八，过渡动画

### 1，CSS3中的过渡动画

要产生过渡动画，必须要先有突变，写一点代码，如下：

![1697700605758](./assets/1697700605758.png)

### 2，Vue2中的过渡动画

动画的作用：本质是一种用户体验的优化。在Vue中，把过渡动画，抽象成了两个过程（Enter进入动画、Leave离开动画）如下：

![1697700800654](./assets/1697700800654.png)

要使用vue中的动画，就需要定义一些类名：

* 进入(可以给动画起名叫ml)
  + v-enter / .ml-enter
  + v-enter-active / .ml-enter-active
  + v-enter-to / .ml-enter-to
* 离开
  + v-leave / .ml-leaver
  + v-leave-active / .ml-leave-active
  + v-leave-to / .ml-leave-to

上代码演示：

![1697701368527](./assets/1697701368527.png)

参考代码：

```vue
<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8'>
  <title>Document</title>
  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: gold;
      text-align: center;
      line-height: 100px;
    }

    .ml-enter {
      opacity: 0;
      color: red;
      font-size: 12px;
    }

    .ml-enter-active {
      transition: all ease 2s;
    }

    .ml-enter-to {
      opacity: 1;
      color: blue;
      font-size: 22px;
    }

    .ml-leave {
      opacity: 1;
      color: blue;
      font-size: 22px;
    }

    .ml-leave-active {
      transition: all ease 2s;
    }

    .ml-leave-to {
      opacity: 0;
      color: red;
      font-size: 12px;
    }
  </style>
  <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
  <div id='app'>
    <button @click="isShow=!isShow">显示或隐藏</button>
    <!-- 要对谁使用动画，先使用transition包起来，transition是vue中的内置组件 -->
    <transition name="ml">
      <h2 v-if="isShow" class="box">{{name}}</h2>
    </transition>
  </div>
  <script>
    let vm = new Vue({
      el: '#app',
      data() {
        return {
          name: "码路",
          isShow: false
        }
      },
      methods: {
      }
    });
  </script>
</body>

</html>
```

在vue2中，如果有多个节点，需要加Key, v3中不需要，如下：

![1697701534993](./assets/1697701534993.png)

也可以使用第三方的动画库：

* https://animate.style/
* 用法：安装或引入第三方css动画库，使用enter-active-class指定进入动画，使用enter-active-class指定离开动画。

代码演示：

![1697701883093](./assets/1697701883093.png)

参考代码：

```vue
<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8'>
  <title>Document</title>
  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: gold;
      text-align: center;
      line-height: 100px;
    }
  </style>
  <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" />
</head>

<body>
  <div id='app'>
    <button @click="isShow=!isShow">显示或隐藏</button>
    <!-- 使用mode指定多个元素显示与隐藏的先后顺序，通常mode='out-in'离开动画先执行，进入动画后执行。 -->
    <transition enter-active-class="animate__animated animate__fadeOutRight"
      leave-active-class="animate__animated animate__lightSpeedOutLeft" mode="out-in">
      <h2 v-if="isShow" class="box" key="a">{{name}}</h2>
      <h2 v-else key="b">66666666</h2>
    </transition>
  </div>
  <script>
    let vm = new Vue({
      el: '#app',
      data() {
        return {
          name: "码路",
          isShow: false
        }
      },
      methods: {
      }
    });
  </script>
</body>

</html>
```

除了transition这个内置组件之外，还有一个叫transition-group组件，作用：一般用于给列表添加分组动画，参见Vue官网。工作中一般很少自己写列表动画。

### 3，案例：遮罩层实现

效果如下：

![1697702698741](./assets/1697702698741.png)

代码：

![1697702721470](./assets/1697702721470.png)

App.vue

```vue
<template>
  <div>
    <button @click="visible = !visible">我是按钮需要遮罩层组件</button>
    <ElDialog :visible="visible"></ElDialog>
  </div>
</template>

<script>
import ElDialog from "./components/ElDialog";
export default {
  name: "",
  data() {
    return {
      visible: false,
    };
  },
  components: {
    ElDialog,
  },
};
</script>

<style scoped>
</style>
```

ElDialog.vue

```vue
<template>
  <div>
    <transition>
      <div class="mask" v-show="visible"></div>
    </transition>
  </div>
</template>

<script>
export default {
  name: "",
  props: ["visible"],
};
</script>

<style scoped>
.mask {
  position: fixed;
  left: 20%;
  top: 20%;
  right: 20%;
  bottom: 20%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
}

.v-enter {
  transform: scale(0);
}

.v-enter-active {
  transition: all 2s;
}

.v-enter-to {
  transform: scale(1);
}

.v-leave {
  transform: scale(1);
  border-radius: 0px;
}
.v-leave-active {
  transition: all 2s;
}
.v-leave-to {
  transform: scale(0);
  border-radius: 50%;
}
</style>
```

### 3，面试题

* vue中如何做动画
  + 使用内置组件（transition / transition-group）+ CSS类名（可以使用animate.css第三方动画）
  + vue中也可以使用JS做动画，只不过一般不用，如果使用JS做动画，它有6个钩子函数。
* transition对多个元素执行动画时有什么要注意的？(加key、使用mode)
  + 要加key，不加的话，动画没效果
  + 加mode

## 九，混入

vue的特点：

* 数据驱动视图（响应式原理）
* 选项式API，混入的是选项。
* 组件化开发（自定义属性，自定义事件，自定义插槽）

一个vue项目，是由N个组件堆起来的，如果这些组件有相同的逻辑，怎么处理？

答：就可以使用混入了，把相同的逻辑放到混入中，混入到组件。

### 1，什么是混入

我们都知道vue组件是由若干选项组成的，混入用于向组件中混入可复用的选项。混入的目的都解决的是选项的复用问题。混入分类：

* 全局混入：使用 Vue.mixin({选项})进行全局混入，所有组件都拥有了这些被混入的选项。
* 局部混入：使用mixins:[{}, {}]选项进行局部混入，只有当前组件才有这些被混入的选项。

混入的优先级：
* 当一个组件同时有全局混入、局部混入、自有选项时，它们的优先级满足：自有选项 > 局部混入 > 全局混入。
* 混入的生命周期函数都会执行

混入的缺点：
* 当混入用得多了，选项“来历不明”，代码不易维护。

代码演示：

```vue
<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='UTF-8'>
  <title>Document</title>
  <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
  <!-- // 混入导致数据方法来源不明 -->
  <div id='app'>
    <h2>{{name}} -- {{a}} -- {{b}} -- {{fn()}}</h2>
    <hr>
    <ml-home></ml-home>
  </div>
  <script>

    // 全局混入
    Vue.mixin({
      data() {
        return {
          // 数据同名时，也有优先级
          a: 1,
          b: 2
        }
      },
      methods: {
        // 方法同名时，有优先级
        fn() {
          console.log("全局混入的fn....");
          return "fn方法"
        }
      },
      // 混入进来的生命周期函数和组件自己的生命周期函数都会执行
      created() {
        console.log("全局混入的created..");
        // this.gg();
      },
    })

    let kk = {
      data() {
        return {
          x: 110,
          y: 120,
          a: 111,
          b: 222
        }
      },
      methods: {
        gg() {
          console.log("gg1...");
        }
      }
    }
    let gg = {
      data() {
        return {
          m: 110,
          n: 120
        }
      },
      methods: {
        gg() {
          console.log("gg2...");
        }
      }
    }

    // 全局注册组件
    Vue.component("ml-home", {
      template: `
        <div>首页--{{a}}--{{b}} --{{x}} ---{{y}}--{{m}} ---{{n}}  -- {{fn()}}</div>
      `,
      // 局部混入
      mixins: [gg, kk],
      created() {
        console.log("home的created..");
        this.gg();
      },
      data() {
        return {
          a: 11,
          b: 22
        }
      },
    })

    let vm = new Vue({
      el: '#app',
      data() {
        return {
          name: "码路",
        }
      },
      methods: {
      }
    });
  </script>
</body>

</html>
```

混入在vue项目中是一个高级技术，如果项目比较大，多个组件中有相同的逻辑，使用混入可以大大的降低代码量，你也可以去网上找一些混入的案例看。

### 2，面试题

* 什么是混入？有什么用？（Vue.mixin()全局混入   mixins:[]局部混入）（对选项进行复用）
  + 把一些相同逻辑封装到一些选项中，然后混入到不同的组件，达到代码复用的目的
  + 分全局混入和局部混入
* 你用混入解决过什么问题？（注入埋点方法、Echarts图表封装）
  + 大家可以先在网上找找，找一个混入的案例。混入是一个高级技巧。
* 全局混入（data、methods、生命周期钩子）
  + 混入的生命周期钩子，和组件的生命周期钩子都会执行。
  + data和methods如果重名了，会有优先级。
* 混入有什么缺点？
  + 造成数据来源不明

## 十，过滤器

### 1，什么 是过滤器

在vue2中有过滤器，在vue3没有了，使用计算属性和方法也可以达到过滤器的目的。过滤器的作用：用于数据处理的，对数据进行格式化或对数据进行加工处理。分类：

* 全局过滤器：在所有的组件中都可以使用，使用Vue.filter('名称', val=>{return newVal})定义全局过滤器
* 局部过滤器：在哪个组件中定义的，只能在哪个组件中使用，使用filters这个选项实现局部过滤器

直接上代码演示：

![1697764719739](./assets/1697764719739.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h2>{{name}}</h2>
        <h2>{{price | rmb}}</h2>
        <h2>{{date | dateFormat}}</h2>

    </div>
    <script>
        // 定义全局过滤器  rmb是过滤器的名字
        Vue.filter('rmb', val => {
            console.log("val:", val);
            return "￥" + Number(val).toFixed(2)
        });

        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    price: 188.1,
                    date: "20220908"
                }
            },
            methods: {},
            filters: {
                "dateFormat"(val) {
                    console.log("-->val:", val);
                    // 使用第三方模块，可以对val进行格式
                    // moment dayjs
                    return "2022-09-08"
                },
                "timeFormat"() {

                }
            }
        });
    </script>
</body>

</html>
```

### 2，面试题

* 什么过滤器？你在工作中用它解决什么问题？（数据统一处理）
  + 过滤器是vue2中用于对数据进行格式化或处理的选项，分全局过滤器和局部过滤器
* 使用过滤器有什么要注意的？（只能在{{}}或者v-bind中使用）
  + 只能在{{}} 和 v-bind:title="x | y"中使用，其它地方，是用不了过滤器

## 十一，自定义指令

### 1，什么是自定义指令

指令本质上是对dom的操作，vue封装这些指令就是为了我们更为合理符合规范的操作dom，避免DOM滥操作。我们也可以自定义指令，自定义指令也是对DOM操作的封装，我之前工作中封装过一些自定义指令，如：xxxx。自定义指令最终的目的也是为了复用，所以在文档中提到了复用技巧这个词，vue中都有哪些复用技巧，如下：

* 混入
* 过滤器
* 自定义指令
* 插件
* 渲染函数（render函数）
* JSX
* 组件

在项目中，有一些常用的DOM功能复用时，建议封装成指令，这就是自定义指令，分类：

* 全局指令：所有的组件中都可以使用。Vue.directive('指令名', fn/{})定义全局指令
* 局部指令：在哪个组件中封装指令，只能在哪个组件中使用，通过directives这个选项定义局部指令

封装一个v-color的指令，代码如下：

![1697766111525](./assets/1697766111525.png)

参考代码如下：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- color是指令，v-仅仅是前缀 -->
        <h2 v-color="'red'">{{name}}</h2>
        <div v-color="c">我是一个孤独的DIV</div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    c: "blue"
                }
            },
            methods: {},
            directives: {
                // 指令的底层都是操作DOM
                // 自定义指令，通常有两种写法
                // color:fn(){}
                // color:{}
                "color": function(el, binding, vnode) {
                    // el表示指令所在的DOM元素
                    console.log("el:", el);
                    // binging是一个对象，包含指令名，指令对应值
                    console.log("binding:", binding);
                    // vnode本质就是一个JS对象，模拟真实DOM
                    // vnode中有一个上下文，在封装自定义指令时，会使用到上下文
                    console.log("vnode:", vnode);
                    // 这一行代码就是DOM操作
                    el.style.color = binding.value;
                }
            }
        });
    </script>
</body>

</html>
```

自定义指令还有一种写法，如下：

![1697766315493](./assets/1697766315493.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- color是指令，v-仅仅是前缀 -->
        <h2 v-color="'red'">{{name}}</h2>
        <div v-color="c">我是一个孤独的DIV</div>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    c: "blue"
                }
            },
            methods: {},
            directives: {
                // {}中放自定义指令对应的钩子函数
                "color": {
                    // 绑定
                    bind(el, binding, vnode) {
                        console.log("bind....");
                        el.style.color = binding.value
                    },
                    update(el, binding, vnode) {
                        console.log("upadte....");
                        console.log("el:", el);
                        console.log("binding:", binding);
                        console.log("vnode:", vnode);
                    }
                }
            }
        });
    </script>
</body>

</html>
```

### 2，案例：通过自定义指令模拟v-model

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h1>{{name}}</h1>
        <input type="text" v-mlmodel="name">
        <input type="text" v-mlmodel.lazy="name">
        <input type="text" v-mlmodel.trim="name">
        <input type="text" v-mlmodel.number="name">
        <input type="text" v-mlmodel.upper="name">
    </div>
    <script>
        Vue.directive("mlmodel", {
            bind(el, binding, vnode) {
                // console.log("el:",el);
                // console.log("binding:", binding);
                // console.log("vnode",vnode);

                let {
                    expression,
                    modifiers
                } = binding;
                let {
                    context
                } = vnode;

                let {
                    lazy,
                    trim,
                    upper,
                    number
                } = modifiers;

                el.value = context[expression]
                console.log(lazy);
                el.addEventListener(lazy ? 'change' : 'input', function(e) {
                    let val = e.target.value;
                    if (trim) val = val.trim();
                    if (upper) val = val.toUpperCase();
                    if (number) val = parseFloat(val)

                    context[expression] = val;
                })
            },
            update(el, binding, vnode) {}
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "ok"
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

### 3，面试题

* 常用指令有哪些？你怎么理解指令？你工作是否自已封装过指令？
* 举一个你封装自定义指令的例子（权限指令、拖拽指令）
* 推荐8个常用指令（项目经验）：
  + https://zhuanlan.zhihu.com/p/337659611
  + https://juejin.cn/post/6906028995133833230
* 复用真的好吗？
  + 对新手不太友好，复用太多，改bug，一个出问题，其它地方也会出问题，容易造成项目瘫痪。

## 十二，插件

### 1，什么是插件

在Vue生态中，除了Vue本身，其它所有与Vue相关的第三方包，都是插件，都得以插件的方式进行集成。插件是一种更加高级的代码复用技术，可以以插件的方式为我们提供可复用的组件、混入、指令、过滤器、原型链API。公司真实项目、优秀开源项目，你只要发现里面有好用的组件或指令，插件，都收集到你的代码库中，以后可以复用。插件的写法有两种：

* 第一种写法： const Plugin = { install (Vue) { } }
* 第二种写法： const Plugin = function (Vue) {}

代码演示：

![1697770092608](./assets/1697770092608.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h2 v-color="'red'">{{name}} --- {{a}}</h2>
        <h2>{{price | rmb}}</h2>
        <button @click="fn">点我</button>
        <ml-button></ml-button>
    </div>
    <script>
        // 之前学习过的复用技巧，都可以封装到插件中
        // 复用技巧：组件，指令，过滤器，原型链，混入...
        let MyPlugin1 = {
            install(Vue) {
                Vue.mixin({
                    data() {
                        return {
                            a: 666
                        }
                    }
                });
                Vue.component('ml-button', {
                    template: `
                <div>我是一个小button</div>
            `
                });
                Vue.filter("rmb", val => ("￥" + val.toFixed(2)));
                Vue.directive("color", function(el, binding) {
                    el.style.color = binding.value;
                });
                Vue.prototype.$ml = function() {
                    console.log("ml....");
                }
            }
        };

        let MyPlugin2 = function(Vue) {
            Vue.prototype.eat = 123456789
        }

        // 上面定义好了插件，使用插件时，需要通过Vue.use()来使用
        Vue.use(MyPlugin1);
        Vue.use(MyPlugin2);

        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    price: 111
                }
            },
            methods: {
                fn() {
                    this.$ml();
                }
            }
        });
    </script>
</body>

</html>
```

### 2，面试题

* 你是如何理解vue的？

  + vue是数据驱动视图（核心是响应式原理）

  + 十几个内置指令（指令本质都是对DOM的抽象封装）

  + vue2是基于选项式API的（里面有很多的选项，20个左右）

  + 组件化开发（自定义属性，自定义事件，自定义插槽），组件是由选项组件，组件9大通信方法

  + 五大内置组件（slot, component, keep-alive, transiton, transition-group）

  + 逻辑复用技术（自定义组件，混入，过滤器，自定义指令，插件，渲染函数，JSX，原型链...
  
* 你有封装过Vue插件？怎么封装的？封装过什么？
	

  + 有，老项目中封装的好用东西，以插件的方式搬到新项目中去
  + 大家可以去网上，找一些插件，分析分析它的源码
	

* 请问 Vue.use() 有什么用？讲一讲它背后做了什么？（调用插件函数或install方法，并传入Vue实参）
  
  + 如果插件是一个函数，当Vue.use时，就会去调用此函数，并Vue类传递进入
  + 如果插件是一个对象，当Vue.use时，就会调用对象中的install方法，并Vue类传递进入
  
  
  
  

## 十三，数组更新检测和两个API

### 1，数组更新检测

数组中有很多的方法，其中有些方法会改变原数组，如下：

![1697770604133](./assets/1697770604133.png)

上面的7个方法，会改变原数组，如下：

* push()
* pop()
* shift()
* unshift()
* splice()
* sort()
* reverse()

在vue中有一个状态，是一个数组，对于这个数组，调用上面的7个方法，也会改变数组，数组变了，也会触发视图更新。但是有的方法，不会改变原数组，生成一个新数组，如：

* concat
* slice
* filter
* ....

我们去调用不会改变原数组的方法，视图不会更新，因为状态没有发生变化。代码测试之，如下：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ul>
            <li>{{name}}</li>
            <li>{{age}}</li>
            <li>{{sex}}</li>
            <li>{{hobby}}</li>
        </ul>
        <button @click="updateHobby">修改睡觉为打代码</button>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "wc",
                    age: 18,
                    sex: "man",
                    hobby: ["睡觉", "吃饭", "打豆豆"]
                }
            },
            methods: {
                updateHobby() {
                    // 这样修改，数据已经变了，但是模板没有刷新
                    // 这个修改数据，并非是响应式的
                    // 如果数组中的数据是基本数据类型，通过索引去修改它，界面并不会更新
                    // this.hobby[0] = "打代码"

                    // 数据变了，界面也没有刷新
                    // 通过数组的length修改数据，并排是响应式的
                    // this.hobby.length = 0;

                    // 调用数组的push,pop方法，也是响应式的
                    // 下面的7个方法，会引起界面更新
                    // push()
                    // pop()
                    // shift()
                    // unshift()
                    // splice()
                    // sort()
                    // reverse()
                    // this.hobby.push("写代码")
                    // this.hobby.pop();
                    // this.hobby.splice(0,1,"打代码")

                    // map返回一个加工后的新数组
                    this.hobby = this.hobby.map(item => item == "睡觉" ? "打代码" : item);
                }
            }
        });
    </script>
</body>

</html>
```

对于响应式数据，可以是一个对象，这个对象嵌套的比较深，也可以是一个数组，数据中包含一个对象，代码如下：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <p>a==>{{a}}</p>
        <p>a.b==>{{a.b}}</p>
        <p>a.b.c==>{{a.b.c}}</p>
        <hr>
        <p>{{arr}}</p>
        <button @click="handle">修改data中的数据</button>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    // a是响应式数据   b也是响应式数据    c也是响应式数据
                    // 在data中，一个对象不管嵌套多深，所有数据都是响应式数据
                    a: {
                        b: {
                            c: 100
                        }
                    },
                    arr: ["xq", 123, {
                        name: 'wangcai'
                    }, true]
                }
            },
            methods: {
                handle() {
                    // this.arr[0] = "6666666666666"

                    // 如果数组中的元素是一个对象的话，通过索引去修改对象中的属性，也会引起界面的更新
                    this.arr[2].name = "malu";
                }
            }
        });
    </script>
</body>

</html>
```

 总结数组更新检测：

* 在data中定义的数据都是响应式数据，有特殊情况：
  + 如果是数组，通过索引和length操作时，数组元素是基本类型，不会引起界面更新。
  + 调用数组那7个方法，是会引起界面更新。

### 2，两个API

**Vue.nextTick() / this.$nextTick()**

* 数据发生变化了，要更新视图，数据变化的代码是同步的，它背后的更新逻辑是异步的，nextTick表示等待异步更新完毕后，执行nextTick中的回调函数。

**this.$forceUpdate()**

* 事实：Vue响应式是有缺陷的，什么缺陷？在复杂的Vue应用中，如果声明式变量是引用数据类型，当你set操作这些复杂的引用数据类型时，视图不更新。解决方案，set操作完成后，立即调用 this.$forceUpdate()强调更新（强制re-render）有时候，this.$forceUpdate()也无法解决上述问题，对set操作的变量进行一行深复制。

直接上代码：

![1697785444734](./assets/1697785444734.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h2>{{name}}</h2>
        <h1 v-text='num' id='h1'></h1>
        <button @click='add'>+1</button>
        <hr>
        <h1 v-text="info.user.child[0]"></h1>
        <button @click="change">改变</button>
    </div>
    <script>
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    num: 1,
                    msg: "",
                    info: {
                        user: {
                            child: [
                                18
                            ]
                        }
                    }
                }
            },
            methods: {
                add() {
                    // 你写了一行代码：this.num++  它的背后会发生很多事
                    //    1）响应式数据变了，就会刷新模板，肯定要生成新的虚拟DOM
                    //    2）新旧虚拟DOM对比，找到差异，更新的仅仅是差异
                    // 这一行代码 this.num++ 是同步的，它背后的更新逻辑是异步的
                    // 至于如何更新的，是vue框架帮我们做的
                    this.num++

                    // const res = document.getElementById('h1').innerText
                    // console.log(res)

                    // nextTick  next是下一个的意思    Tick是记录
                    // 当响应式数据发生变化，模板要异步更新，模板更新完毕后，就会调用$nextTick中的回调函数
                    // 之前讲完一个生命周期函数，叫updated，它和$nextTick类似。
                    // 面试题：updated和nextTick有什么区别？
                    //     ？？？？？
                    this.$nextTick(() => {
                        const res = document.getElementById('h1').innerText
                        console.log(res)
                    })
                },
                change() {
                    // 如果数组中放的是基本数据类型
                    // 通过索引操作数据，并不是响应式的
                    // 通过length操作也不是响应式
                    // 下面的代码导致数据发生变化，但是模板没有刷新
                    this.info.user.child[0]++

                    // 强制更新
                    this.$forceUpdate();
                }
            }
        });
    </script>
</body>

</html>
```

### 3，面试题

* 谈一谈你对 Vue.nextTick() 的理解？有什么用？（在nextTick访问最新的DOM）

  + 在nextTick访问最新的DOM

* nextTick() 和 updated() 的区别 （前者只是表示一个更新单元已完成，后者是生命周期钩子表示整个页面更新完成）

  + 前者只是表示一个更新单元已完成
  + 后者是生命周期钩子表示整个页面更新完成

* Vue响应式有没有缺陷呢？有什么缺陷？遇到这种问题你会怎么办？

  + 如果组件嵌套的非常深，数据结构也非常深，可以会导致响应式失效。如何解决？
  
    - A）$forceUpdate()  可能解决不了
  
    - B）需要对数据实现深copy
  

    * 

```js
      this.info.user.child[0].age++ // 没有让模板更新

      this.info.user.child[0].age++ // 这两行代码可以让模板更新
      this.info = JSON.parse(JSON.stringfy(this.info))
```

  

​      

  

## 十四，UI组件库

面试题：

你是如何理解vue？

* vue是数据驱动视图（响应式原理）
* vue2是选项式API（一堆的选项）
* 组件化开发（自定义属性，自定义事件，自定义插槽，选项式API，组件通信）
* 十几个指令（内置指令），指令的本质是对DOM操作的封装......
* 五大内置组件（slot, transition, component, keep-alive, transition-group）
* 复用技巧（组件，混入，过滤器，自定义指令，插件，原型链....）
* 图：组件的生命周期图，MVVM图，Vuex图

### 1，什么是UI组件库

UI组件库，就是很多NB的公司，自己研发出来的一堆组件，基于这些组件库，可以快速构建项目。今天先使用一个ElementUI，是ELM公司出品，地址：https://element.eleme.io/#/zh-CN

![1697786189469](./assets/1697786189469.png)

使用UI组件库，核心就是死磕文档，copy代码，直接点到组件链接，如下 ：

![1697786303164](./assets/1697786303164.png)

要使用UI组件库，在项目中，就需要安装之，如下：

![1697786379573](./assets/1697786379573.png)

至于如何使用，就死磕文档，如下：

![1697786624118](./assets/1697786624118.png)

一般桌面端的项目，都是完整引入，如下：

![1697786688462](./assets/1697786688462.png)

然后就可以使用它提供的组件了，如下：

![1697786934717](./assets/1697786934717.png)

浏览器效果如下：

![1697786960133](./assets/1697786960133.png)

### 2，案例：TodoMVC(接口版)

效果图：

![1697787105316](./assets/1697787105316.png)

![1697787146108](./assets/1697787146108.png)

![1697787211960](./assets/1697787211960.png)

![1697787251807](./assets/1697787251807.png)

![1697787280339](./assets/1697787280339.png)

后端代码：

![1697787324807](./assets/1697787324807.png)

得到后端代码后，要解压，安装依赖，安装完后，要把后端接口运行起来：

![1697787408617](./assets/1697787408617.png)

接口文档：

```text
//完整 http://127.0.0.1:9000/getTaskList?limit=100&page=1&state=0

1. 获取任务列表信息
  URL：/getTaskList
    limit:每一页展示的数量(默认100条)
    page:当前展示第几页(默认第1页)
    state:任务状态(0全部[默认] 1未完成 2已完成)
  METHOD：GET
  RESULT：{
    code:0,  返回数据的状态码   0->正常  1->非正常
    codeText:'',  数据状态的描述信息
    limit:8, 每页展示数量
    page:1,  当前页码
    pageNum:10,  总页数
    total:98,  总数据量
    list:[                                                    
      {
        id:1, 编号
        task:'xxx', 任务信息
        state:1, 任务状态  1未完成  2已完成
        time:'2019-06-15 04:39:00'  预完成时间
        complete:'2019-06-15 04:39:00' 真实完成时间
      },
      ...
    ]
  }

2、增加新任务
  URL：/addTask
  METHOD：POST
  DATA:{ //请求主体格式要求：urlencoded格式字符串
    task:'',
    time:''
  }
  RESULT：{
    code:0,   0->注册成功  1->注册失败
    codeText:''
  }

3、删除任务
  URL: /removeTask?id=1
  METHOD：GET
  RESULT：{
     code:0,  0->删除成功  1->删除失败
     codeText:''
  }

4、完成任务
  URL: /completeTask?id=1
  METHOD：GET
  RESULT：{
     code:0,  0->操作成功  1->操作失败
     codeText:''
  }
```

开始写代码：

App.vue：

```vue
<template>
  <div>
    <TodoList />
  </div>
</template>

<script>
import TodoList from "./views/TodoList.vue";
export default {
  name: "App",
  props: [],
  data() {
    return {};
  },
  methods: {},
  components: {
    TodoList,
  },
};
</script>

<style>
.el-button,
.el-input,
.el-input__inner {
  border-radius: 0 !important;
}
</style>
```

TodoList.vue

```vue
<template>
  <div class="todoBox">
    <div class="handle">
      <el-input v-model="text" placeholder="请输入内容"></el-input>
      <!-- @click="submit" 自定义事件   type="primary" 自定义属性 -->
      <el-button type="primary" @click="submit">新增TODO</el-button>
    </div>
    <div v-if="list.length">
      <ListItem
        @removeTodo="removeTodo"
        @updateTodo="updateTodo"
        :info="item"
        v-for="item in list"
        :key="item.id"
      ></ListItem>
    </div>
    <div v-else>没有todo啦~</div>
  </div>
</template>

<script>
import ListItem from "../components/ListItem.vue";
const store = {
  get() {
    let data = localStorage.getItem("todolist");
    let value = [];
    if (data) {
      data = JSON.parse(data);
      if (+new Date() - data.time <= 1000 * 60 * 60 * 24) {
        // if (+new Date() - data.time <= 1000 * 10) {
        value = data.list;
      } else {
        localStorage.removeItem("todolist");
      }
      return list;
    }
    return value;
  },
  set(list) {
    let data = {
      time: +new Date(),
      list,
    };
    localStorage.setItem("todolist", JSON.stringify(data));
  },
};
export default {
  name: "TodoList",
  props: [],
  data() {
    return {
      text: "",
      list: store.get(),
      // list: [
      //   {
      //     id: "01",
      //     todo: "学习vue2",
      //   },
      //   {
      //     id: "02",
      //     todo: "学习vue3",
      //   },
      // ],
    };
  },
  components: {
    ListItem,
  },
  methods: {
    submit() {
      if (this.text === "") {
        // alert();
        // this  表示当前组件实例
        this.$message.warning("请您先输入todo内容");
        return;
      }
      // 对于数组来说，有7个API可以实现视图更新
      // push pop shift unshift splice sort reverse
      this.list.push({
        id: +new Date(),
        todo: this.text,
      });
      this.text = "";
      this.$message.success("恭喜您，新增成功啦~");

      store.set(this.list);
    },
    removeTodo(id) {
      this.list = this.list.filter((item) => {
        return +item.id !== +id;
      });
      store.set(this.list);
    },
    updateTodo(id, newTodo) {
      // console.log(id, newTodo);
      this.list = this.list.map((item) => {
        if (+item.id == +id) {
          item.todo = newTodo;
        }
        return item;
      });
      store.set(this.list);
    },
  },
};
</script>

<style scoped>
.todoBox {
  width: 400px;
  box-sizing: border-box;
  margin: 20px auto;
  border: 1px solid red;
}
.handle {
  display: flex;
  border-bottom: 1px dashed #eee;
  padding-bottom: 20px;
  align-items: center;
  justify-content: space-between;
  margin: 20px;
}
.el-input {
  width: 280px;
}
.el-button {
  margin-left: 20px;
}
</style>
```

ListItem.vue

```vue
<template>
  <div class="itemBox">
    <div class="content">
      <el-input size="mini" v-show="isUpdate" v-model.trim="todo" />
      <span class="textCon" v-show="!isUpdate">{{ todo }}</span>
    </div>
    <div>
      <el-popconfirm
        title="你确定要删除吗？"
        @confirm="$emit('removeTodo', info.id)"
      >
        <el-button type="danger" size="mini" slot="reference">删除</el-button>
      </el-popconfirm>

      <el-button type="success" size="mini" @click="handle">
        {{ isUpdate ? "保存" : "修改" }}
      </el-button>

      <el-button type="info" size="mini" v-show="isUpdate" @click="cancel"
        >取消</el-button
      >
    </div>
  </div>
</template>

<script>
export default {
  name: "ListItem",
  props: {
    info: {
      type: Object,
      required: true,
    },
  },
  data() {
    return {
      todo: this.info.todo,
      isUpdate: false,
    };
  },
  methods: {
    handle() {
      if (this.isUpdate) {
        // 处于修改状态
        if (this.todo === "") {
          this.$message.warning("todo不能是空");
          return;
        }

        this.$emit("updateTodo", this.info.id, this.todo);

        this.isUpdate = false;
        return;
      }

      this.isUpdate = true;
    },
    cancel() {
      this.isUpdate = false;
      this.todo = this.info.todo;
    },
  },
};
</script>

<style scoped>
.itemBox {
  margin: 15px 10px;
}
.itemBox .content {
  margin-bottom: 5px;
}

.textCon {
  line-height: 30px;
  font-size: 14px;
}
.el-input {
  width: 200px;
}
.el-button {
  margin-right: 10px;
}
</style>
```

浏览器效果：

![1698029527852](./assets/1698029527852.png)

## 十四，组件通信（9种）

### 1，父子组件通信

* 自定义属性（父传子，子传父）
* 自定义事件（子传父）
* 自定义插槽（父传子（传的html结构），子传父（作用域插槽））

状态提升：当兄弟组件之间需要共享数据时，我们通常的做法是把这个数据定义它们的共同的父组件中，再通过自定义属性实现数据共享。

上代码：

![1698031222423](./assets/1698031222423.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ml-a :couter="couter"></ml-a>
        <ml-b :couter="couter"></ml-b>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div>
              <div>我是ml-a组件 -- {{couter}}</div>
          </div>
      `,
            props: {
                couter: {
                    type: Number,
                    default: 0
                }
            }
        })
        Vue.component("ml-b", {
            template: `
          <div>
              <div>我是ml-b组件 -- {{couter}}</div>
          </div>
      `,
            props: {
                couter: {
                    type: Number,
                    default: 0
                }
            }
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    couter: 0
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

![1698031402664](./assets/1698031402664.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ml-a :couter="couter" @add="couter += $event"></ml-a>
        <ml-b :couter="couter" @add="couter += $event"></ml-b>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div>
              <div>我是ml-a组件 -- {{couter}}</div>
              <button @click="$emit('add',1)">+1</button>
          </div>
      `,
            props: {
                couter: {
                    type: Number,
                    default: 0
                }
            }
        })
        Vue.component("ml-b", {
            template: `
          <div>
              <div>我是ml-b组件 -- {{couter}}</div>
              <button @click="$emit('add',1)">+1</button>
          </div>
      `,
            props: {
                couter: {
                    type: Number,
                    default: 0
                }
            }
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    couter: 0
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

### 2，provide+inject祖先后代通信

这是在组件树中，自上而下的一种数据通信方案，也就是说只能父级组件中向后代组件传递。需要注意的是，当provide提供动态数据（声明式变量）时，动态数据发生变化，后代组件们不会自动更新。这是为什么呢？你自己从生命周期流程的角度去思考。

上代码：

![1698031838865](./assets/1698031838865.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ml-a></ml-a>
        <hr>
        <h1>{{num}}</h1>
        <button @click="num++">+1</button>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div>
              <div>我是ml-a组件 -- {{msg}}</div>
              <span v-for="i in list">{{i}}</span>
              <div>{{num}}</div>
          </div>
      `,
            inject: ["msg", "list", "num"]
        })
        //  provide + inject是自上而下的通信方案
        // 提供数据变了，后代不会自动刷新，提供的数据并不是响应式的，为什么？
        // 答：从生命周期角度分析，注入数据发生在第个阶段,是发生在初始化响应式系统之前。
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    num: 110
                }
            },
            provide() {
                return {
                    msg: "hello",
                    list: ["a,b,c,d"],
                    num: this.num
                }
            },
            methods: {}
        });
    </script>
</body>

</html>
```

### 3，ref通信

ref是Vue内置的一个属性，每一个HTML元素或组件都有这个属性；ref作用在HTML元素上得到DOM实例，ref作用在组件上得到组件实例。使用ref访问组件实例，进一步可以访问组件中的数据和方法。（说明：ref是一种快速的DOM的访问方式，当然ref也可作用在组件上得到组件实例。这些ref得到的DOM实例或组件实例，使用this.$refs来访问它们。ref尽量少用，除非某些难搞的需求。）

上代码：

![1698032220492](./assets/1698032220492.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <!-- ref写在组件上了，目的是为了获取组件实例，组件实例你能得到了，实例中的数据和方法都可以得到 -->
        <ml-a ref="mla"></ml-a>
        <button @click="fn">访问a组件</button>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div>
              <div>我是ml-a组件</div>
          </div>
      `,
            data() {
                return {
                    a: 1,
                    b: 2
                }
            },
            methods: {
                fn() {
                    console.log("fn...");
                }
            },
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    num: 110
                }
            },
            methods: {
                fn() {
                    // VueComponent  叫组件类   new VueComponent 得到组件实例  你没有去new，Vue框架会帮你去new
                    // Vue  叫根组件的类  new Vue得到根组件实例
                    console.log(this.$refs.mla);
                    console.log(this.$refs.mla.a);
                    console.log(this.$refs.mla.b);
                    this.$refs.mla.fn()
                }
            }
        });
    </script>
</body>

</html>
```

### 4，插槽通信

借助slot组件实现从子组件向父组件传递数据，借助this.$slots访问父组件中的插槽实例。(在自定义组件中使用this.$slots访问父组件给的插槽实例；在父组件插槽中使用#default='scoped'访问子组件slot回传的数据。这种通信在组件库中、工作中，非常常见！)

直接上代码：

![1698042005867](./assets/1698042005867.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ml-a>
            <template #default>
                <div>我是插入的内容1 -- {{a}}</div>
            </template>
            <template #aaa>
                <div>我是插入的内容2 -- {{a}}</div>
            </template>
            <template #bbb="scoped">
                <div>我是插入的内容2 -- {{scoped.car}}</div>
            </template>
            <template #ccc="{car}">
                <div>我是插入的内容2 -- {{car}}</div>
            </template>
        </ml-a>
        <hr>
        <ml-a></ml-a>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div>
              <div>我是ml-a组件</div>
              <slot name="default"><div>我是默认值</div></slot>
              <slot name="aaa"><div>我是默认值</div></slot>
              <slot name='bbb' :car='car'><div>我是默认值</div></slot>
              <slot name='ccc' :car='car'><div>我是默认值</div></slot>
          </div>
      `,
            data() {
                return {
                    car: "benchi"
                }
            },
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    a: 1,
                    b: 2
                }
            },
        });
    </script>
</body>

</html>
```

### 5，$parent / $children

借助$parent/$children可以实现，在任一组件中访问组件树中的其它任意组件实例，可以做到在组件中随意穿梭。($parent表示的是当前组件的父组件实例，$children表示的是当前组件的子组件们。)

直接上代码：

![1698042413584](./assets/1698042413584.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <ml-a></ml-a>
        <hr>
        <button @click="fn">获取子组件中的数据</button>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div>
              <div>我是ml-a组件</div>
          </div>
      `,
            mounted() {
                // $parent得到父组件实例
                // 父组件实例只有一个
                console.log(this.$parent.a);
            },
            data() {
                return {
                    b: 1
                }
            },
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    a: 1,
                }
            },
            methods: {
                fn() {
                    // [VueComponent]   
                    // VueComponent是普通组件对应的类  new VueComponent()得到普通组件实例
                    // Vue 是根组件对应的类   new Vue() 得到根组件实例
                    console.log(this.$children);

                    // 得到VC实例
                    console.log(this.$children[0].b);
                }
            },
        });
    </script>
</body>

</html>
```

### 6，$attrs / $listeners

借助$attrs可访问父组件传递过来的自定义属性（除了class和style外），借助$listenrs可以访问父组件给的自定义事件。在某些场景下，$attrs/$listeners可以替代props/$emit()这种通用的通信方案。

直接上代码：

![1698043154807](./assets/1698043154807.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .page span {
            display: inline-block;
            padding: 0 10px;
            cursor: pointer;
        }

        .page span.on {
            color: red;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <div id='app'>
        <h2>{{name}}</h2>
        <ml-a :page="page" @change="changePage"></ml-a>
    </div>
    <script>
        Vue.component("ml-a", {
            template: `
          <div class="page">
              <div>我是ml-a组件</div>
              <span @click="$listeners.change(i)" :class="{on:$attrs.page === i}" v-for="i in pageArr">{{i}}</span>
          </div>
      `,
            mounted() {
                // {page: 1}
                console.log("$attrs:", this.$attrs);
                console.log("$listeners:", this.$listeners);
            },
            computed: {
                pageArr() {
                    let p = this.$attrs.page;
                    if (p <= 3) {
                        return [1, 2, 3, 4, 5]
                    } else {
                        return [p - 2, p - 1, p, p + 1, p + 2]
                    }
                }
            }
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                    page: 1
                }
            },
            methods: {
                changePage(val) {
                    this.page = val || 1;
                }
            },
        });
    </script>
</body>

</html>
```

### 7，事件总线

借助于Vue内置的事件系统（$on/$emit/$off/$once）实现“订阅-发布”式的通信，这种通信方式是一种与组件层级无关的“一对多”的通信。（工作中很少用，一些特殊的Vue项目才用得到事件总线。）

直接上代码：

![1698043894480](./assets/1698043894480.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
</head>

<body>
    <!-- 
    事件总线：
      1）现在：let bus = new Vue();  // 事件总线
        之前：let vm = new Vue(); // vm叫根组件

        和之前讲的自定义事件类似
        bus.$on("eat",callback)  订阅  监听
        bus.$emit("eat",'hello')  发布  可以传递数据
        bus.$off("eat")  取消订阅  取消监听
        bus.$once("eat")  只监听一次，或只订阅一次

   -->
    <div id='app'>
        <h2>{{name}}</h2>
        <ml-wc></ml-wc>
        <hr>
        <ml-xq></ml-xq>
    </div>
    <script>
        let bus = new Vue(); // 事件总线

        Vue.component("ml-wc", {
            template: `
          <div>
               <h2>wc在线</h2>
                <input type="text" v-model="msg" @keyup.enter="send" />
                <button @click="send">发送</button>
                <div v-html="content"></div>
          </div>
      `,
            mounted() {
                bus.$on("wc", msg => {
                    this.content += `<div class='row'>xq说：${msg}</div>`
                })
            },
            data() {
                return {
                    msg: "",
                    content: ""
                }
            },
            methods: {
                send() {
                    bus.$emit("xq", this.msg);
                    this.msg = "";
                }
            }
        })
        Vue.component("ml-xq", {
            template: `
          <div>
               <h2>xq在线</h2>
                <input type="text" v-model="msg" @keyup.enter="send" />
                <button @click="send">发送</button>
                <div v-html="content"></div>
          </div>
      `,
            mounted() {
                bus.$on("xq", msg => {
                    // console.log('xq收集到数据:', msg);
                    this.content += `<div class='row'>wc说：${msg}</div>`
                })
            },
            data() {
                return {
                    msg: "",
                    content: ""
                }
            },
            methods: {
                send() {
                    bus.$emit("wc", this.msg);
                    this.msg = "";
                }
            }
        })
        let vm = new Vue({
            el: '#app',
            data() {
                return {
                    name: "码路",
                }
            },
            methods: {},
        });
    </script>
</body>

</html>
```

### 8，Vuex

后天讲vuex，比较强大。

### 9，面试题

* Vue中有哪些常用的通信方案？（父子、ref、provide、slot、$parent、事件总线、Vuex）
  + 自定义属性可以实现父传子，也可以实现子传父
  + 自定义事件可以实现子传父
  + 自定义插槽可以实现父传子，也可以实现子传父
  + provide+inject可以实现祖先给后代传递数据，只能自上而下的，不具备响应式
  + ref写在组件上，可以获取子组件实例，实例得到了，进而可以得到实例中的数据和方法
  + $parent得到父组件实例，$children得到子组件实例们
  + $attrs接收所有的自定义属性，$listeners接收所有的自定义方法，进而可以实例父传子，和子传子
  + 事件总线，是基于发布订阅，一个组件订阅，另一个组件发布，就可以实现组件间的通信。
  + vuex，叫集中状态管理，后面讲
* 谈一谈以上九种通信方案之间的区别？或者任意两种通信方案之间的区别？（语法区别、使用场景的区别）
* 父子组件之间怎么通信？（父传子、子传父）
* provide/inject有什么特点？（只能自上而下、没有响应式）
* $attrs能不能接收class和style？（不能）
* 谈一谈你对事件总线的理解（“订阅-发布”模式）的理解？
* 有没有读过vue源码？经常加班，没时间读，今年打算读一下

## 十五，响应式原理

### 1，什么是响应式原理

所谓的响应式（reactive）是指你get/set一个属性时，你可以“捕获”这个操作行为；就好比叫你一声，你会答应一样），下面的对应不具备响应式，如下：

![1698045476336](./assets/1698045476336.png)

要想让obj中的属性具备响应式，需要通过defineProperty来定义属性，代码如下：

![1698045863052](./assets/1698045863052.png)

参考代码：

```html
<script>
    // obj中的属性具备响应式
    let obj = {};
    let a = 1;
    let b = 2;

    Object.defineProperty(obj, "a", {
        // 当获取a时，就可以捕获到，感知到
        get() {
            console.log("有人访问a了~");
            return a;
        },
        set(val) {
            console.log("有人修改a了~");
            a = val;
        }
    })
    Object.defineProperty(obj, 'b', {
        get() {
            console.log("有人访问b了~");
            return b;
        },
        set(val) {
            console.log("有人修改b了~");
            b = val;
        }
    })

    console.log(obj.a, obj.b); // 1
    obj.a = 11;
    obj.b = 22;
    console.log(obj.a, obj.b); // 11
</script>
```

如果obj对象上的属性非常多，都使用defineProperty来定义，比较麻烦，可以这样做，如下：

![1698046323469](./assets/1698046323469.png)

参考代码：

```html
<script>
    let data = {
        name: "ml",
        age: 18,
        address: "bj",
    };

    let vm = {}; // 模拟vm实例

    Object.keys(data).forEach(k => {
        Object.defineProperty(vm, k, {
            get() {
                console.log(`getter ${k}`);
                return data[k]
            },
            set(val) {
                console.log(`setter ${k}`);
                data[k] = val;
            }
        })
    })
    console.log(vm.name);
    console.log(vm.age);
    vm.name = "ml 666";
    vm.age = 28;
    console.log(vm.name);
    console.log(vm.age);
</script>
```

到此，我们再去讲几个概念：

* touch: 当指令第一次与声明式变量绑定时，第一次会触发声明式变量中的get
* 劫持：使用Object.defineProperty对data中的所有数据（声明式变量）进行遍历并添加getter和setter钩子
* 依赖收集：当第1次touch时, 会把当前声明式变量的的更新方法(watcher) 添加到dep依赖数组中
* watcher : 与声明式变量对应的DOM操作
* re-render：当声明式变量变化，走setter，Vue会通知Watcher更新DOM，即重新渲染。

直接上代码：

![1698048179075](./assets/1698048179075.png)

参考代码：

```html
shuru: <input id="ipt" type="text">
shuchu: <h2 id="h2"></h2>
<hr>
<h1 id="h1"></h1>
<button id="btn">+1</button>
<script>
    // ------------- 第1阶段
    let data = {
        name: "ml",
        num: 1
    };
    let vm = {}; // Vue根实例

    Object.keys(data).forEach(k => {
        Object.defineProperty(vm, k, {
            get() {
                console.log(`getter ${k}`);
                return data[k]
            },
            set(val) {
                console.log(`setter ${k}`);
                data[k] = val;
                // 派发更新
                Watcher(k)
            }
        })
    })

    // 专门用来收集依赖
    let dep = {
        name: [], // 这数组中放watcher
        num: []
    };

    // ------------- 第2阶段（挂载阶段）
    function init() {
        // document.getElementById("ipt").value = vm.name; // getter
        // document.getElementById("ipt").addEventListener("input",e=>{  // setter
        //   vm.name = e.target.value;
        // })

        dep['name'].push(() => {
            document.getElementById("ipt").value = vm.name;
        })
        document.getElementById("ipt").addEventListener("input", e => { // setter
            vm.name = e.target.value;
        })
        // v-text="name"
        dep['name'].push(() => {
            document.getElementById("h2").innerText = vm.name;
        })
        // v-text="num"
        dep['num'].push(() => {
            document.getElementById("h1").innerText = vm.num;
        })
        // v-on:click
        document.getElementById("btn").addEventListener("click", () => {
            vm.num++; // 改变了num 走setter
        })

        // 第一次更新
        Object.keys(dep).forEach(k => Watcher(k))
    }

    function Watcher(k) {
        dep[k].forEach(fn => fn())
    }

    init();
</script>
```

官方响应式原理对应的图：

![1698048471630](./assets/1698048471630.png)

### 2，面试题

* 说一下Vue的响应式原理？
  + 当Vue组件被创建时，在生命周期的第1个阶段，Vue使用Object.defineProperty()，对 对data中的数据进行深度递归遍历劫持，添加get和set钩子。在生命周期的第二个阶段， 指令第一次与声明式变量touch时，开始进行依赖收集，就是收集Watcher，Watcher就是一个更新函数，然后进行第1次页面渲染（首次渲染），当数据发生变化时Vue再次通过Watcher更新视图，这就是Vue的响应式原理。

## 十六，Vue官方文档

vue官方文档，第一手资料，需要大家把vue2和vue3文档，多读几遍。

## 十七，路由

### 1，什么是前端路由

之前讲过ajax，ajax发送请求，需要指定一个url，这个url也叫后端提供的API接口，这个url也叫后端的路由，我们请求这个url，后端通常是给我们返回JSON数据，这个URL是后端路由。所谓的前端路由也是一个url，访问这个url，不是去请求服务器，是请求不同的url，切换不同的组件。在Vue中，官方提供了一个插件，叫vue-router，这个插件就是提供路由功能，在使用这个插件，先安装之，如下：

![1698110224998](./assets/1698110224998.png)

官方文档：https://v3.router.vuejs.org/zh/guide/#html

### 2，路由的基本使用

使用步骤：

* 第一步：创建路由需要映射的组件（打算显示的页面）
* 第二步：通过new VueRouter创建路由对象，并且传入routes和history模式
* 第三步：在main.js中，引入路由器对象挂载到根组件上，这样，它的子子孙孙，都可以访问这个路由器对象
* 第四步：使用这个插件提供的全局功能，先记住下面几个内容
  + 两个组件：《router-view》   《router-link》
  + 两个对象：$router(路由器对象)    $route(路由规则对象)

第一步：创建路由需要映射的组件（打算显示的页面），如下：

![1698110460082](./assets/1698110460082.png)

第二步：通过new VueRouter创建路由对象，并且传入routes和history模式

![1698110994356](./assets/1698110994356.png)

参考代码：

```js
import VueRouter from "vue-router";
import Vue from "vue"

// 安插插件
// 插件是更加高级的封装：
//   它里可以封装全局组件，全局过滤器，全局的指令，在原型对象上挂载一些内容
Vue.use(VueRouter)

// 引入路由对应的组件
import Home from "../components/Home.vue"
import About from "../components/About.vue"
import Malu from "../components/Malu.vue"

// VueRouter是一个类    router路由器对象
let router = new VueRouter({
    mode: "history", // 使用什么样的路由模块  一种是history，一种是hash
    routes: [ // routes中配置路由规则，所谓的路由规则，就是什么样的url对应什么样的组件
        { // 一个路由规则就是一个对象
            path: "/",
            // component: Home
            redirect: "/home", // // redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了
        },
        { // 一个路由规则就是一个对象
            path: "/home",
            component: Home
        },
        {
            path: "/about",
            component: About
        },
        {
            path: "/malu",
            component: Malu
        }
    ]
});

// 默认导出路由器对象，需要在main.js中导入，使用之
export default router;
```

第三步：在main.js中，引入路由器对象挂载到根组件上，这样，它的子子孙孙，都可以访问这个路由器对象

![1698111137514](./assets/1698111137514.png)

第四步：使用这个插件提供的全局功能，如下：

![1698111780254](./assets/1698111780254.png)

参考代码：

```vue
<template>
  <div>
    <div>App</div>
    <!-- router-link 当成a标签  -->
    <router-link to="/home" active-class="active">Home</router-link>&nbsp;&nbsp;
    <router-link to="/about" active-class="active">About</router-link>&nbsp;&nbsp;
    <router-link to="/malu" active-class="active">Malu</router-link>&nbsp;&nbsp;

    <!-- router-view是路由插件提供的全局组件 -->
    <!-- router-view是路由的出口，出口中放匹配到的组件 -->
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "App",
  props: [],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style scoped>
.active {
  color: red;
}
</style>
```

### 3，重定向，404组件，懒加载

直接上代码：

![1698113090551](./assets/1698113090551.png)

参考代码：

```js
import VueRouter from "vue-router";
import Vue from "vue"

Vue.use(VueRouter)

// 直接加载下面三个组件
// 首页面不会懒加载
import Home from "../components/Home.vue"
// import About from "../components/About.vue"
// import Malu from "../components/Malu.vue"

let router = new VueRouter({
    mode: "history",
    routes: [{
            path: "/",
            redirect: "/home",
        },
        {
            path: "/home",
            component: Home
        },
        {
            path: "/about",
            // 路由的懒加载：当匹配到url时，再去加载对应的组件
            // 如果没有匹配到，就不去加载
            component: () => import("../components/About.vue")
        },
        {
            path: "/malu",
            component: () => import("../components/Malu.vue")
        },
        {
            path: "*",
            component: () => import("../components/NotFount.vue")
        }
    ]
});

export default router;
```

### 4，路由的嵌套

准备二级路由对应的组件，如下：

![1698113275234](./assets/1698113275234.png)

开始配置，如下：

![1698113370513](./assets/1698113370513.png)

参考代码：

```js
import VueRouter from "vue-router";
import Vue from "vue"

Vue.use(VueRouter)

// 直接加载下面三个组件
// 首页面不会懒加载
import Home from "../components/Home.vue"
// import About from "../components/About.vue"
// import Malu from "../components/Malu.vue"

let router = new VueRouter({
    mode: "history",
    routes: [{
            path: "/",
            redirect: "/home",
        },
        {
            path: "/home",
            component: Home,
            children: [{
                    path: "/home/",
                    redirect: "/home/person"
                },
                {
                    path: "/home/person",
                    component: () => import("../components/Person")
                },
                {
                    path: "/home/setting",
                    component: () => import("../components/Setting")
                },
            ]
        },
        {
            path: "/about",
            // 路由的懒加载：当匹配到url时，再去加载对应的组件
            // 如果没有匹配到，就不去加载
            component: () => import("../components/About.vue")
        },
        {
            path: "/malu",
            component: () => import("../components/Malu.vue")
        },
        {
            path: "*",
            component: () => import("../components/NotFount.vue")
        }
    ]
});

export default router;
```

还需要指定出品，设置点击链接，如下：

![1698113513961](./assets/1698113513961.png)

参考代码：

```vue
<template>
  <div>
    <h2>Home组件</h2>
    <hr />
    <router-link to="/home/person">个人中心</router-link>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <router-link to="/home/setting">设置中心</router-link>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <router-view></router-view>
  </div>
</template>

<script>
export default {
  name: "Home",
  props: [],
  data() {
    return {};
  },
  methods: {},
};
</script>

<style scoped>
</style>
```

### 5，动态路由与路由传参

准备如下四个组件：

![1698113738134](./assets/1698113738134.png)

通过查询字符串传参，如下：

![1698113969654](./assets/1698113969654.png)

Home组件获取参数，如下：

![1698114128288](./assets/1698114128288.png)

![1698114219281](./assets/1698114219281.png)

还可以通过动态路由传参，如下：

![1698114436863](./assets/1698114436863.png)

在about组件中，如何获取参数，如下：

![1698114532712](./assets/1698114532712.png)

### 6，编程式路由并传参

前面我们使用《router-link》这个组件，点击进行跳转，这个导航或这个路由，叫声明式导航（路由）。除了声明式导航之外，还有一种导航，叫编程式导航。不是通过《router-link》实现的跳转，是通过点击按钮实现的跳转，直接上代码，代码如下：

router/index.js代码：

```js
import VueRouter from "vue-router";
import Vue from "vue"

Vue.use(VueRouter)

// 直接加载下面三个组件
// 首页面不会懒加载
import Home from "../components/Home.vue"
// import About from "../components/About.vue"
// import Malu from "../components/Malu.vue"

let router = new VueRouter({
    mode: "history",
    routes: [{
            path: "/",
            redirect: "/home",
        },
        // 前端路由通过查询字符串传参
        // http://localhost:8080/home?name=malu&age=18
        // ?name=malu&age=18  在ajax中，叫查询字符串，目的是给服务器传参
        // 现在 ?name=ma这lu&age=18 也叫查询字符串，这个参数是传递给Home组件
        {
            path: "/home",
            component: Home,
            name: "home", // name表示给这个规则起一个唯一的名字
        },
        {
            // :name  :age  :height 表示动态参数
            // http://localhost:8080/about/malu/18/188
            // path: "/about/:name/:age/:height",

            // http://localhost:8080/about 这样写可以匹配到
            // 参数可传，可不传，可以使用?
            path: "/about/:name?/:age?/:height?",
            // 路由的懒加载：当匹配到url时，再去加载对应的组件
            // 如果没有匹配到，就不去加载
            component: () => import("../components/About.vue"),
            name: "about" // ==============================================
        },
        {
            path: "/mine",
            component: () => import("../components/Mine.vue"),
            name: "mine"
        },
        {
            path: "*",
            component: () => import("../components/NotFount.vue")
        }
    ]
});

export default router;
```

Home.vue:

```vue
<template>
  <div>
    <h2>Home组件</h2>
    <button @click="toAbout">去About页面</button>
    <button @click="forward">前进</button>
  </div>
</template>

<script>
export default {
  name: "Home",
  props: [],
  created() {},
  data() {
    return {};
  },
  methods: {
    toAbout() {
      // 还有一个API，叫$router，带有r
      // 第一种写法：push后面可以跟一个字符串
      this.$router.push("/about"); // 没有传参
      // this.$router.push("/about/ml/18/188");  // 传参

      // 第二种写法
      // this.$router.push({ path: "/about" });  // 没有传参
      // this.$router.push({ path: "/about/ml/18/188" });  // 传参

      // 给动态路由传参的另一种写法
      // this.$router.push({
      //   // path: "/about",
      //   // 通过name来跳转，name是你给路由规则起的名字
      //   name: "about",
      //   params: { name: "ml", age: 18, height: 188 },
      // });

      // 通过查询字符串传参
      // this.$router.push("/about?name=ml&age=18&height=188");
      // this.$router.push({
      //   name: "about",
      //   query: {
      //     name: "ml",
      //     age: 18,
      //     height: 188,
      //   },
      // });
      // this.$router.push({
      //   path: "/about",
      //   query: {
      //     name: "ml",
      //     age: 18,
      //     height: 188,
      //   },
      // });

      // this.$router.replace("/about");
    },
    forward() {
      // this.$router.forward();
      this.$router.go(1);
    },
  },
};
</script>

<style scoped>
</style>
```

About.vue:

```vue
<template>
  <div>
    <h2>About组件</h2>
    <button @click="back">返回</button>
    <p>收到路由params参数：{{ $route.params.name }}</p>
    <p>收到路由params参数：{{ $route.params.age }}</p>
    <p>收到路由params参数：{{ $route.params.height }}</p>
    <hr />
    <p>收到路由query参数：{{ $route.query.name }}</p>
    <p>收到路由query参数：{{ $route.query.age }}</p>
    <p>收到路由query参数：{{ $route.query.height }}</p>
  </div>
</template>

<script>
export default {
  name: "About",
  props: [],
  created() {
    console.log(this);
  },
  data() {
    return {};
  },
  methods: {
    back() {
      // this.$router.back();
      this.$router.go(-1);
    },
  },
};
</script>

<style scoped>
</style>
```

### 7，盘点路由知识点

**两种路由模式：hash路由、history路由。**

* hash路由：有#，背后是监听onhashchange事件实现的，hash路由部署上线不会出现404
* history路由：没有#，背后是基于history api实现的，history路由部署上线会出现404问题。

代码如下：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
    <script src="https://unpkg.com/vue-router@3/dist/vue-router.js"></script>
</head>

<body>
    <div id='app'>
        <router-view></router-view>
    </div>
    <script>
        const Home = {
            template: '<div>首页内容...</div>'
        }
        const Course = {
            template: '<div>课程内容..</div>'
        }
        const News = {
            template: '<div>资讯内容..</div>'
        }

        const router = new VueRouter({
            // hash路由：带#，兼容性非常多，hash值不会传递给服务器 url格式：http://www.baidu.com/a/b/c?n=1&m=2#/abc
            // history路由：不带#  格式：http://127.0.0.1:5005/news 长的和后端路由一样的，它是会给后端发请求，后端没有这个接口，就会造成404，解决办法需要后端程序员处理。
            // 推荐使用hash路由，兼容性好，也不需要后端处理404问题，缺点就是多一个#
            // 至于这两种路由模式实现的原理：大家可以先自行百度
            mode: "history", // hash history  不写mode，默认也是hash路由
            routes: [{
                    path: '/',
                    component: Home
                },
                {
                    path: '/home',
                    component: Home
                },
                {
                    path: '/course',
                    component: Course
                },
                {
                    path: '/news',
                    component: News
                }
            ]
        });

        let vm = new Vue({
            el: '#app',
            router,
            data() {
                return {}
            },
            methods: {}
        });
    </script>
</body>

</html>
```

**两个全局组件：《router-view name》视图容器、《router-link to tag active-class》用于设计菜单导航的。**

* 《router-link》：to属性用于指定跳转的目标；tag用于指定最终渲染成什么标签，默认渲染成a标签；
* active-class/exact-active-class用于指定菜单的高亮样式。
* 《router-view》：name属性用于指定命令视图（给router-view加个名字，默认叫default）。

代码：

![1698118188611](./assets/1698118188611.png)

参考代码：

```html
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .on {
            color: red;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
    <script src="https://unpkg.com/vue-router@3/dist/vue-router.js"></script>
</head>

<body>
    <div id='app'>
        <router-link to="/" tag="li">Logo</router-link>
        <router-link to="/home" tag="li" active-class="on">首页</router-link>
        <router-link to="/course" tag="li" active-class="on">课程</router-link>
        <router-link to="/news" tag="li" active-class="on">资讯</router-link>
        <hr>
        <router-view></router-view>
        <router-view name="xxx"></router-view>
    </div>
    <script>
        const Home = {
            template: '<div>首页内容...</div>'
        }
        const Course = {
            template: '<div>课程内容..</div>'
        }
        const News = {
            template: '<div>资讯内容..</div>'
        }
        const Test01 = {
            template: '<div>Test01..</div>'
        }
        const Test02 = {
            template: '<div>Test02..</div>'
        }

        const router = new VueRouter({
            routes: [{
                    path: '/',
                    component: Home
                },
                {
                    path: '/home',
                    component: Home
                },
                {
                    path: '/course',
                    component: Course
                },
                {
                    path: '/news',
                    component: News
                },
                {
                    path: '/test',
                    components: {
                        default: Test01,
                        xxx: Test02
                    }
                },
            ]
        });

        let vm = new Vue({
            el: '#app',
            router,
            data() {
                return {}
            },
            methods: {}
        });
    </script>
</body>

</html>
```

**两种路由跳转：声明式跳转、编程式跳转。**

* 所谓的声明式路由跳转，就是使用 《router-link》做跳转，一般用于菜单设计。
* 所谓的编程式路由跳转，就是使用 $router 做跳转，一般用在事件中。

**两种路由传参：query传参、动态路由传参。**

* query传参：在跳转路由的url后面用?a=1&amp; b=2&amp; c=3这种方式传参，在另一个组件中使用this.$route.query接收。
* 动态路由传参：像这样 `{path: '/good/:id', component }`定义路由规则，在这条动态路由规则对应的组件中使用this.$route.params接收，或者开启props:true后使用 props选项来接收。

声明式跳转并传参：

```html
    <router-link to="/">首页</router-link>
    <router-link to="/course">课程</router-link>
    <!-- 01 02 03 叫params参数   path:"/detail/:id" 动态路由 -->
    <router-link to="/detail/03">课程</router-link>

    <!-- 不传参 -->
    <router-link :to="{path:'/course'}">课程</router-link>

    <!-- query传参 -->
    <router-link :to="{path:'/course?size=19&page=2'}">课程</router-link>
    <router-link :to="{path:'/course', query:{size:19,page:2}}">课程</router-link>

    <!-- 不传参 -->
    <router-link :to="{name:'Course'}">课程</router-link>

    <!-- query传参 -->
    <router-link :to="{name:'Course', query:{size:19,page:2} }">课程</router-link>

    <!-- params参数  query传参-->
    <router-link :to="{path:'/detail/03',query:{size:123}}">Linux</router-link>

    <!-- params参数  query传参-->
    <router-link :to="{name:'Detail',params:{id:3}, query:{size:29}}">网络安全</router-link>
```

编程式跳转并传参：

大家参考第6小节中的代码。

**两个内置API：$route表示路由信息，$router用于路由跳转的。**

* $route路由信息: this.$route.fullPath/query/params/meta。（watch可以监听$route的变化）
* $router路由实例：this.$router.push()向前跳转/replace()向前跳转/back()返回上一次。
* 带r的，里面有一堆方法，不带r，里面有一堆的属性

**两种命名：命名视图、命名路由。**

* 所谓的命名视图，意思是给《router-view》加一个name属性。
* 所谓的命名路由，意思是给{path, component}路由规则取一个名字。

```html
// 命名路由：

<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <title>Document</title>
    <style>
        .on {
            color: red;
        }
    </style>
    <script src='https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js'></script>
    <script src="https://unpkg.com/vue-router@3/dist/vue-router.js"></script>
</head>

<body>
    <div id='app'>
        <router-view></router-view>
        <!-- 命名视图 -->
        <router-view name="xxx"></router-view>
    </div>
    <script>
        const Home = {
            template: '<div>首页内容...</div>'
        }
        const Course = {
            template: '<div>课程内容..</div>'
        }
        const News = {
            template: '<div>资讯内容..</div>'
        }
        const Test01 = {
            template: '<div>Test01..</div>'
        }
        const Test02 = {
            template: '<div>Test02..</div>'
        }

        const router = new VueRouter({
            routes: [{
                    path: '/',
                    component: Home
                },
                {
                    path: '/home',
                    component: Home,
                    name: "home"
                }, // 命名路由
                {
                    path: '/course',
                    component: Course,
                    name: "course"
                }, // 命名路由
                {
                    path: '/news',
                    component: News,
                    name: "news"
                }, // 命名路由
                {
                    path: '/test',
                    components: {
                        default: Test01,
                        xxx: Test02
                    }
                },
            ]
        });

        let vm = new Vue({
            el: '#app',
            router,
        });
    </script>
</body>

</html>
```

**两个优化：路由懒加载、重定向与别名**

* 路由懒加载：当一个SPA应用程序中的页面足够多，我们需要根据路由系统进行按需加载组件（而不是一次性加载所有组件），该怎么实现呢？使用路由懒加载（背后原理是Webpack代码分割技术、Vue异步组件）。路由懒加载，是一种性能优化方案。
* 重定向与别名：当用户访问一个未定义的路由时，给一个重定向（跳转到另一个已定义的路由上），这是一种用户体验的优化。重定向规则，一般要放在路由规则的最后面。什么是别名？别名是path的简写，可以用于路由访问；什么时候需要用到别名？当path比较复杂时，需要给它设计一个别名。

**两个难点：嵌套视图（嵌套路由）、导航守卫（路由元信息）。**

* 嵌套视图（嵌套路由）：当我们设计类似知乎官网那样的一级菜单、二级菜单时，就要用到嵌套视图。所谓“嵌套视图”，从组件树的角度来讲，《router-view》所显示的组件的内部还有《router-view》；从路由规则的角度来讲，{path, component, children}带有children这个属性；从产品设计的角度来讲，一级菜单对应的页面中还有二级菜单。

* 导般守卫：在router实例对象上有三个重要的全局钩子（beforeEach、beforeResolve、afterEach），每次url发生变化时，都会触发这三个钩子按顺序执行。那么以后我可以在这些钩子编写验证逻辑，如果验证通过就放你过去，你就可以正常访问你想访问的页面；如果验证失败，就阻止你访问目标页面，这就实现“守卫”的效用了。在路由中，使用导航守卫和路由元信息，可以做鉴权、还可以做权限设计。

* 导航守卫，也叫路由守卫，后面项目中讲。

  

### 8，面试题

* 说一下history和hash路由有什么区别？
* 什么是命名视图、命名路由、别名？（《router-view name》、{path, component, name, alias}）
* 说一下路由怎么传参？什么是动态路由？（两种传参。所谓动态路由，就是定义路由规则时path字段串中有冒号）
* 什么是路由懒加载？它背后的原理是什么？（Webpack代码分割、使用动态导入语法的Vue异步组件）
* 什么是路由守卫（导航守卫）？你项目的鉴权怎么做的？你这个管理系统的权限怎么设计的？
* 在Vue中做组件的显示与隐藏，有哪些方案？（v-show/v-if、《component》、路由或嵌套路由）
* 在Vue中，怎么监听路由的变化？（watch监听$route）
* 什么是单页面应用程序（SPA）？你怎么理解单页面应用程序？

## 十八，Vuex

### 1，Vuex的基本使用

**版本问题：**

* 在Vue2技术栈中：Vue(2) + VueRouter(3) + Vuex(3)
* 在Vue3技术栈中：Vue(3) + VueRouter(4) + Vuex(4) / Pinia(2)

Vuex是做**集中状态管理**的，状态就是数据，状态管理就是数据管理，怎么学习Vuex？一个流程图（要求会画会说会写）、五个概念、四个map方法。Vuex两个作用：

* 组件之间数据共享
* 数组缓存

**一个流程图**

<img src="https://vuex.vuejs.org/vuex.png"/>

**五个概念：**

创建store时要用的五个概念（state/getters/mutations/actions/modules）
* state: {} 用于定义可被组件共享数据，是具有响应式的；在组件中使用this.$store.state来访问它们。
* getters: {fn} 用于计算state，相当于Vue的计算属性，当state发生变化时getters方法自动自动重新计算；在组件中使用this.$store.getters来访问它们。
* mutations: {fn} 专门用于修改state的，所以mutations方法是这样fn(state, payload)定义的；mutations方法在actions中或组件中使用，使用$store.commit('mutations方法', payload)
* actions: {fn} 专门用于调接口的，所以actions方法是这样fn(store, payload)定义的；在组件中使用this.$store.dispatch('actions方法', payload)。
* modules: {子store} 是一个Vuex架构层面的概念，用于拆分子store。大家在拆分子store务必在子store中使用namespaced:true开启命名空间。

使用vuex步骤：
* 第一步：安装vuex指定版本，并注册Vue.use(Vuex) ，npm i vuex@3.6.2 -S
* 第二步：创建store实例{五个概念}并抛出，在main.js挂载store
* 第三步：在组件中使用this.$store/四个map方法来使用store或走数据流程

第一步：安装vuex指定版本，并注册Vue.use(Vuex) ，npm i vuex@3.6.2 -S

![1698132578845](./assets/1698132578845.png)

第二步：创建store实例{五个概念}并抛出，在main.js挂载store

![1698132656779](./assets/1698132656779.png)

在仓库中，定义定义状态，定义mutation，如下：

![1698133258880](./assets/1698133258880.png)

参考代码：

```js
import Vuex from "vuex"
import Vue from "vue"

Vue.use(Vuex)

let store = new Vuex.Store({
    // state中定义状态，状态是多个组件用来共享
    state: {
        num: 1,
        list: []
    },
    // mutation是修改状态的唯一途径
    // 一个mutation就是一个方法，mutation的第一个参数是state
    // 第二个参数是你在组件中提交mutation时，传递过来的参数
    // this.$store.commit("addNum",1)
    mutations: {
        addNum(state, payload) {
            // 存储在仓库中的状态是响应式的，状态变化，组件模板会刷新
            state.num += payload;
        }
    }
});

export default store;
```

第三步：在组件中使用this.$store/四个map方法来使用store或走数据流程

![1698133322543](./assets/1698133322543.png)

能不能简单粗暴地去修改仓库中的状态呢？如下：

![1698133497696](./assets/1698133497696.png)

开启严格模式，如下：

![1698133555925](./assets/1698133555925.png)

### 2，Vuex中的计算属性

在vuex中，也有计算属性，不叫computed，叫getters，写如下代码：

![1698196608253](./assets/1698196608253.png)

在组件中使用计算属性，如下：

![1698196715824](./assets/1698196715824.png)

### 3，action写异步代码

mutation中不能写异步代码，如果有异步代码，需要把异步代码写在actions中，如下：<br/>

store/index.js

```js
import Vuex from "vuex"
import Vue from "vue"

Vue.use(Vuex)

let store = new Vuex.Store({
    strict: true,
    state: {
        num: 1,
        list: []
    },
    getters: {
        // 根据已有的状态，得到一个新的状态
        doubleNum(state) {
            return state.num * 2
        }
    },
    mutations: {
        // 同步+1
        addNum(state, payload) {
            state.num += payload;
        }
    },
    // actions中写异步代码的
    actions: {
        asyncAddNum({
            commit
        }, payload) {
            // 在action中就可以写异步代码了
            // action中是不能直接修改状态的，也必须通过mutaion来修改
            // 在组件中，提交mutation是通过组件来提交的
            // 在action中如何提交mutation呢？action的第一个形参是一个上下文对象
            // 这个上下文对象中一个属性，叫commit
            setTimeout(() => {
                commit("addNum", payload)
            }, 2000)
        }
    },
});

export default store;
```

在组件中，就可以派发action，如下：<br/>

App.vue

```vue
<template>
  <div>
    <p>使用仓库中的数据：{{ $store.state.num }}</p>
    <p>使用仓库中的计算属性：{{ $store.getters.doubleNum }}</p>
    <button @click="add">同步+1</button>
    <button @click="asyncAdd">异步+1</button>
  </div>
</template>

<script>
export default {
  name: "App",
  props: [],
  mounted() {
    console.log(this.$store.state);
  },
  data() {
    return {};
  },
  methods: {
    add() {
      // 标准流程：通过commit一个mutation去修改状态
      this.$store.commit("addNum", 1);

      // 简单粗暴去修改仓库中的状态,不标准的操作流程
      // this.$store.state.num += 1;
    },
    asyncAdd(){
      // mutation是需要commit的  commit是提交的意思
      // action是需要dispatch的  dispatch是派发的意思
      this.$store.dispatch("asyncAddNum",1)
    }
  },
};
</script>

<style lang="less" scoped>
</style>
```

浏览器效果如下：

![1698197235675](./assets/1698197235675.png)

### 4，案例：axios发请求获取数据存储Vuex

安装axios，如下：

![1698198389870](./assets/1698198389870.png)

定义一个仓库，在仓库中，定义状态，在action中发请求，获取数据放到state中，如下：

![1698198419087](./assets/1698198419087.png)

在组件中派发action，如下：

![1698198473167](./assets/1698198473167.png)

定义一个mutation，通过mutation修改list状态，如下：

![1698198608084](./assets/1698198608084.png)

在组件中使用之，如下：

![1698198776906](./assets/1698198776906.png)

参考代码，store/index.js，如下：

```js
import Vuex from "vuex"
import Vue from "vue"
import axios from "axios"

Vue.use(Vuex)

let store = new Vuex.Store({
    strict: true,
    state: {
        list: []
    },
    mutations: {
        changeList(state, payload) {
            state.list = payload;
        }
    },
    actions: {
        getList({
            commit
        }, payload) {
            axios.get("https://cnodejs.org/api/v1/topics", {
                params: payload
            }).then(res => {
                // console.log("res:", res);
                commit("changeList", res.data.data)
            })
        }
    },
});

export default store;
```

App.vue:

```vue
<template>
  <div>
    <ul>
      <li v-for="item in $store.state.list" :key="item.id">{{ item.title }}</li>
    </ul>
    <button @click="nextpage">下一页</button>
  </div>
</template>

<script>
export default {
  name: "App",
  props: [],
  mounted() {
    this.$store.dispatch("getList", {
      page: this.page,
      tab: this.tab,
      limit: this.limit,
    });
  },
  data() {
    return {
      page: 1,
      tab: "job",
      limit: 10,
    };
  },
  methods: {
    nextpage() {
      this.page++;
      this.$store.dispatch("getList", {
        page: this.page,
        tab: this.tab,
        limit: this.limit,
      });
    },
  },
};
</script>

<style lang="less" scoped>
</style>
```

### 5，四个map方法

state（仓库中状态）:

* 在组件中通过 this.$store.state.xxx

getters（仓库中的计算属性）：

* 在组件中通过 this.$store.getters.xxx

mutations（修改状态的唯一途径）：

* 在组件中通过 this.$store.commit("xxx", 123)

actions（写异步代码）：

* 在组件中通过 this.$store.dispatch("xxx", 123)

**四个map方法：**

* mapState/mapGetters，必须写在computed计算属性中，用于访问state/getters数据。映射进来后，就可以用this来访问这些数据了。
* mapActions/mapMutations 必须写在methods选项中，用于访问mutations/actions方法。映射进来后，可以用this调用这些方法。
* 它们的语法是相同的：mapXxx('命名空间', ['k1', 'k2'])

直接上代码，仓库准备如下：

```js
import Vuex from "vuex"
import Vue from "vue"
import axios from "axios"

Vue.use(Vuex);

let store = new Vuex.Store({
    state: {
        num: 1,
        list: [],
    },
    mutations: {
        addNum(state, payload) {
            state.num += payload
        },
        changeList(state, payload) {
            state.list = payload;
        }
    },
    actions: {
        asyncAddNum({
            commit
        }, params) {
            setTimeout(() => {
                commit("addNum", params)
            }, 2000)
        },
        getList({
            commit
        }, params) {
            axios.get("https://cnodejs.org/api/v1/topics", {
                params: params
            }).then(res => {
                commit("changeList", res.data.data)
            })
        }
    },
    getters: {
        doubleNum(state) {
            return state.num * 2
        }
    }
})

export default store;
```

在组件中先使用传统的方法使用状态，计算属性，mutation，action，如下：

```vue
<template>
  <div>
    <div>App</div>
    <hr />
    <div>
      <p>使用仓库中的数据：{{ $store.state.num }}</p>
      <p>使用仓库中的计算属性：{{ $store.getters.doubleNum }}</p>
      <button @click="add">同步+1</button>
      <button @click="asyncAdd">异步+1</button>
    </div>
    <hr />
    <ul>
      <li v-for="item in $store.state.list" :key="item.id">{{ item.title }}</li>
    </ul>
    <button @click="nextpage">下一页</button>
  </div>
</template>

<script>
export default {
  name: "App",
  props: [],
  data() {
    return {
      page: 1,
      tab: "job",
      limit: 10,
    };
  },
  mounted() {
    this.$store.dispatch("getList", {
      page: this.page,
      tab: this.tab,
      limit: this.limit,
    });
  },
  methods: {
    add() {
      this.$store.commit("addNum", 1);
    },
    asyncAdd() {
      this.$store.dispatch("asyncAddNum", 2);
    },
    nextpage() {
      this.page++;
      this.$store.dispatch("getList", {
        page: this.page,
        tab: this.tab,
        limit: this.limit,
      });
    },
  },
};
</script>
```

浏览器效果如下：

![1698200809552](./assets/1698200809552.png)

在vuex中提供了一些快捷方式，可以非常方便地获取vuex中的状态，计算属性，mutations，actions，如下：

![1698201167962](./assets/1698201167962.png)

参考代码如下：

```vue
<template>
  <div>
    <div>App</div>
    <hr />
    <div>
      <p>使用仓库中的数据：{{ num }}</p>
      <p>使用仓库中的计算属性：{{ doubleNum }}</p>
      <button @click="addNum(1)">同步+1</button>
      <button @click="asyncAddNum(1)">异步+1</button>
    </div>
    <hr />
    <ul>
      <li v-for="item in list" :key="item.id">{{ item.title }}</li>
    </ul>
    <button @click="nextpage">下一页</button>
  </div>
</template>

<script>
import { mapState, mapGetters, mapMutations, mapActions } from "vuex";
export default {
  name: "App",
  props: [],
  data() {
    return {
      page: 1,
      tab: "job",
      limit: 10,
    };
  },
  computed: {
    ...mapState(["num", "list"]),
    ...mapGetters(["doubleNum"]),
  },
  mounted() {
    this.getList({
      page: this.page,
      tab: this.tab,
      limit: this.limit,
    });
  },
  methods: {
    ...mapMutations(["addNum", "changeList"]),
    ...mapActions(["asyncAddNum", "getList"]),
    nextpage() {
      this.page++;
      this.getList({
        page: this.page,
        tab: this.tab,
        limit: this.limit,
      });
    },
  },
};
</script>
```

### 6，modules的使用

**三个原则：**

* 原则1：只要使用Vuex一定要拆分store，拆分store后在根store上不要再使用state/mutations/actions。
* 原则2：在子store务必开启命名空间namespaced:true。
* 原则3：在组件中尽可能不要使用$store，建议使用四个map*方法。

定义a.js这个小仓库，如下：

![1698201892550](./assets/1698201892550.png)

定义b.js小仓库，如下：

![1698201913056](./assets/1698201913056.png)

在index.js中，整合小仓库，如下：

![1698201555408](./assets/1698201555408.png)

在组件中使用之，如下：

![1698201945881](./assets/1698201945881.png)

### 7，案例：TodoMVC（Vuex）

#### 1）分析

![1698214372233](./assets/1698214372233.png)

存储在Vuex中的状态有：

* todos：[{text:"学习vuex, So easy~", done:false}, {text:"学习React, So easy~", done:false}]
* visibilty:，筛选的条件 :all completed active

功能：

* 显示todos数据
* 添加一条todos数据
* 删除todos数据
* 修改某一项的状态：完成，没有完成之间切换
* 批量修改状态: 全部完成，全部未完成
* 统计没有完成的数量
* 批量删除已经完成的
* 三种状态的筛选
* 编辑todos的内容
* 本地存储

组件：

![1698214499388](./assets/1698214499388.png)

#### 2）准备静态资源

第一步：准备静态资源，如下

![1698214614426](./assets/1698214614426.png)

第二步：把App.vue中的template的内容用todo.html的内容来代替

![1698214691252](./assets/1698214691252.png)

第三步：在App.vue中引入对应的css

![1698214746120](./assets/1698214746120.png)

#### 3）创建Vuex的仓库

我们这个脚手架中已经安装了vuex，如下：

![1698214803077](./assets/1698214803077.png)

创建仓库，如下：

![1698214973821](./assets/1698214973821.png)

#### 4）显示Todo(拆ListTodo.vue)

创建ListTodo.vue组件，如下：

![1698215080383](./assets/1698215080383.png)

在App.vue组件中，使用ListTodo.vue组件，如下：

![1698215188664](./assets/1698215188664.png)

把仓库中的todo数据，映射到app.vue组件中，如下：

![1698215267441](./assets/1698215267441.png)

有多少个todo数据, 就循环出多少个ListTodo组件，如下：

![1698215327190](./assets/1698215327190.png)

通App.vue这个父组件给ListTodo这个子组件进行数据传递，如下：

![1698215404116](./assets/1698215404116.png)

在子组件中，设置props接收之，如下：

![1698215527213](./assets/1698215527213.png)

#### 5）添加todo（拆AddTodo.vue）

抽离AddTodo组件，如下：

![1698215624328](./assets/1698215624328.png)

在App.vue中使用，如下：

![1698215704853](./assets/1698215704853.png)

浏览器效果如下：

![1698215753050](./assets/1698215753050.png)

本质上需去vuex.store.state.todos中加一条记录，这里就是涉及修改vuex中的数据，必须要用mutations，我们应该先去vuex中去创建好一个mutations，如下：

![1698215914295](./assets/1698215914295.png)

把这个方法直接映射到addTodo组件的methods中，如下：

![1698216097171](./assets/1698216097171.png)

#### 6）删除一条todos数据

删除操作也是要去修改数据，则对应的也要建立一个mutations。如下：

![1698216265999](./assets/1698216265999.png)

这个删除操作是在listTodo组件中完成的。在 listTodo组件中给删除的按钮绑定事件，如下：

![1698216370315](./assets/1698216370315.png)

#### 7）修改某一项的状态：完成，没有完成之间切换

说白了，就是修改vuex中每个todo的状态（done），如下：

![1698216415513](./assets/1698216415513.png)

这个操作，本质就是要去修改某一个todo项的done属性。所以也需要在mutations中去写好对应的方法。如下：

![1698216489101](./assets/1698216489101.png)

在ListTodo，映射成方法，这个工作是在ListTodo组件完成的，我们去给按钮加change事件。如下：

![1698216555664](./assets/1698216555664.png)

浏览器测试之，如下：

![1698216592374](./assets/1698216592374.png)

#### 8）批量修改状态: 全部完成，全部未完成

首先，我们要去判断当前情况下，是否所有的任务已经全部完成。如果全部完成，则它应该要处于check状态。现在，我们需要在原始数据的基础，加工得到一个新数据：是否全部完成。所以，应该要在vuex.store中的加一个getters，如下：

![1698216761751](./assets/1698216761751.png)

在App.vue中使用之，如下：

![1698216875894](./assets/1698216875894.png)

我们还要给全选按钮加change事件:

1. 如果当前是处于checked ，则点击事件发生，要全部改成done:false
2. 如果当前是没有选中，则点击事件发生，要全部改成done:true

上面的操作，也是要修改vuex中仓库的数据，则对应地要去建立mutations，如下：

![1698217060390](./assets/1698217060390.png)

在App.vue使用之，如下：

![1698217170724](./assets/1698217170724.png)

#### 9） 统计没有完成的数量

统计没有完成的数量，说白了，就是数一数，todos中todo的done是false个数，不需要对数据进行修改，只是在原始数据的基础上，加工得到新数据。去vuex.store中设置一个 getters，如下：

![1698217314892](./assets/1698217314892.png)

把它map到App.vue组件中，成为一个计算属性。如下：

![1698217384421](./assets/1698217384421.png)

#### 10）批量删除已经完成的

![1698218619709](./assets/1698218619709.png)

这个按钮，只有在“完成了数量>0”的情况下才可见。

* todos.length是所有任务的数量
* unDoneNumber: 还没有完成的数量
* todos.length - unDoneNumber === 已完成的
* todos.length - unDoneNumber > 0     已完成的数量大于0
* 当todos.length >unDoneNumber 说明，有一部分是已经完成了的

![1698218819590](./assets/1698218819590.png)

下面，接给它添加点击事件，点击之后，要把已经完成的任务从整个的todos当中删除掉。由于这里涉及修改数据 ，我们需要去建立 一个mutations。如下：

![1698218945697](./assets/1698218945697.png)

下面，把这个功能映射到App.vue组件的methods 中。如下：

![1698219014985](./assets/1698219014985.png)

浏览器测试之，如下：

![1698219048233](./assets/1698219048233.png)

#### 11）三种状态的筛选

#### 12）编辑todos的内容

#### 13）本地存储

### 8，面试题

* 简述Vuex的作用和意义?（基于Flux思想的状态管理工具，用于组件间数据通信、用于数据缓存）
* 简述Vuex的工作流程?（actions =》 mutations  =》 state =》 组件）
* 什么是单向数据流？（state  =》 view =》 action）
* 说一下状态管理的五个概念分别代表什么？说一下mutations和actions的区别？

## 十九，面试题汇总

* 常用的vue指令有哪些？你怎么理解指令？
* v-if 和 v-show 有什么区别？
  + v-if是控制真正的渲染或销毁，而不是显示与隐藏
  + v-show通过css display来控制显示与隐藏
  + 频繁切换显示状态用v-show，否则使用v-if
* 文本插值有“{{}}一闪而过”问题，怎么处理？
* v-for 可以循环哪些数据类型？
* v-model 有哪些修饰符？
* vue 中怎么阻止冒泡？怎么阻止默认事件？怎么监听键盘enter键？
* 工作中你封装过自定义指令吗？举一些例子
* 计算属性有什么作用？（两大作用）
* 计算属性能不能绑定在v-model上？（可以）
* 怎么理解计算属性的缓存功能？（有且仅有被关联的声明式变量变化时，计算属性才会重新计算）
* 什么是侦听器？有什么用？
* 侦听器能不能监听数组/对象的变化？（可以，但默认不监听深层）deep:true
* 侦听器为什么默认不支持深度监听？（性能优化）
* 如何监听一个对象中的某个属性变化？（deep:true, 推荐 'obj.key'这种监听写法）
* 在Vue中，侦听器能够监听哪些性质的变量变化呢？（data，计算属性，vuex中的数据，$route等）
* 什么是组件化？怎么理解组件化？
  + 组件是HTML的扩展，使用粒度较小的HTML元素封装成粒度更大的标签（Vue组件）。
  + 自定义组件技术，是MVVM框架中最重要的技术之一，可以实现快速开发、代码复用、提升可维护性。
  + 加上你的理解。
* 你工作中有没有封装比较好的组件？ vue-element-admin 
* 父子组件之间如何通信？（父传子、子传父）
* 什么是插槽？什么是具名插槽？
* 为什么组件中的data必须是一个函数？ 
  + 组件是可以复用的，如果是一个对象的，多个组件实例的data是指向同一个堆空间，数据相互影响
  + vm中的data可以是一个对象？ 
  + 答：它不需要复用
* Vue常用的生命周期有哪些？
* 在创建/挂载/更新/销毁阶段，Vue在背后分别做了些什么事儿？
* 响应式原理，发生在Vue哪些生命周期阶段？
* 虚拟DOM，在哪些阶段生成的？
* 哪些生命周期钩子可以执行多次？哪些执行一次？
* 什么虚拟DOM？（是一个很大的JSON数据，用于描述视图模板的，保存在内存中）
* 虚拟DOM存在的价值点在哪里？
  + 达到数据驱动视图的目的
  + vue和raect都是数据驱动视图的目的
  + 更新时，把DOM更新粒度降到最低，规避人为DOM滥操作
* 什么diff运算？（在更新阶段，patch对新旧虚拟DOM进行对比，找到差异，更新差异）
* 还有很多与生命周期有关的面试题
* 在Vue中实现条件渲染渲染有哪些办法？
  
  + v-if / v-show / component is
* 什么是动态组件？ 看一下官方文档怎么说的
  
  + keep-alive include exclude 还有两个新的生命周期钩子
* mounted和activated有什么区别？deactivated和beforeDestroy有什么区别？（执行次数、使用场景）
* Vue有哪些内置组件？  keep-alive  component slot  过渡动画相关2个  （5大内置组件）
* 哪些场景下你会用到动态组件？
* Vue中怎么做动画？（内置组件 《transition》）
* 说一下Vue动画怎么实现？（使用那6个钩子编写自定义动画、使用animate.css第三方动画）
  + 通过transition + css6个类名实现 或 使用animate.css第三方动画
  + js钩子函数实现（基本上不用）
* transition对多个元素执行动画时有什么要注意的？(加key、使用mode)
  + 加key、使用mode
  + vue3中不需要加key
* 说一下，vue中都有哪些复用技巧？
  + minix 
  + 过滤器
  + 插件
  + 渲染函数 jsx 
  + 自定义指令 
  + vue的原型对象    Vue.prototype.$http = xxx; 
* 需要大家，找一些混入的真实案例去看一下。
* 什么是混入？有什么用？  
  + 对选项进行复用
  + Vue.mixin()全局混入
  + mixins:[]局部混入
* 混入有什么缺点，有什么优点
  
  + 造成数据来源不明，混入的数据名字一样，会冲突，混入的数据有优先级，也会造成混乱
* 你用混入解决过什么问题？
  + 找一些混入的真实案例去看一下。
  + 注入埋点方法、Echarts图表封装
* 什么过滤器？你在工作中用它解决什么问题？（数据统一处理）
  + vue中代码的复用技巧
  + 作用：用于数据处理的。
  + 全局过滤器：使用 Vue.filter('名称', val =》{return newVal}) 定义，在任何组件中都可以直接使用。
  + 局部过滤器：使用 filters: {} 定义，只能在当前组件中使用。
  + 在vue3中就把过滤器淘汰了 
* 使用过滤器有什么要注意的？
  + 注意1：过滤器只能用在 {{}} 和 v-bind 中，不支持其它指令。
  + 注意2：过滤器还可以链式调用，像这样 {{ num / f1 / f2 }}，过滤器是有顺序的。
* 说一下，你对vue内容的理解？
  + 十几个指令（内置指令）
  + 组件化（一堆选项的集合，props, computed, data, methods, watch, filter, template...）
  + 五大内置组件（slot, transition, component, keep-alive）
  + 逻辑复用技术（自定义组件，混入，过滤器，自定义指令，插件，原型链）
  + 组件通信方案（9种，最常用的父子通信）
  + 三大原理（响应式原理，模板编译，vDom和patch） 
  + 生命周期
  + vue源码（你有没有读过vue源码？答：没有。xxxx）
* 常用指令有哪些？你怎么理解指令？你工作是否自已封装过指令？
  + 举一个你封装自定义指令的例子（权限指令、拖拽指令）
  + https://zhuanlan.zhihu.com/p/337659611  推荐8个常用指令（项目经验）
  + https://juejin.cn/post/6906028995133833230 
* 你有封装过Vue插件？怎么封装的？封装过什么？
* 请问 Vue.use() 有什么用？讲一讲它背后做了什么？（调用插件函数或install方法，并传入Vue实参）
* vur-router / vuex 这两个插件非常经典，这两个插件的源码相对来说还是比较简单的。
* 谈一谈你对 Vue.nextTick() 的理解？有什么用？
* nextTick() 和 updated() 的区别, 它们分别有什么应用场景？
* Vue响应式有没有缺陷呢？有什么缺陷？遇到这种问题你会怎么办？
* 如果有父子组件嵌套，他们的生命周期是怎样？
* provide提供的数据为什么不是响应式数据。
  
  + 从生命周期角度分析，注入数据发生在生成响应式系统之前
* Vue中有哪些常用的通信方案？（父子、ref、provide、slot、$parent、事件总线、Vuex）
* 父子组件之间怎么通信？（父传子、子传父）
* provide/inject有什么特点？（只能自上而下、没有响应式）
* $attrs能不能接收class和style？（不能）
* 谈一谈你对事件总线的理解（“订阅-发布”模式）的理解？
* 谈一谈以上九种通信方案之间的区别？或者任意两种通信方案之间的区别？（语法区别、使用场景的区别）
* 有没有读过vue源码？经常加班，没时间读，今年打算读一下
* Object.defineProperty有什么缺点？
  + 优点：兼容性好
  + 缺点：
  +     需要深度递归监听，只是深度递归，肯定有性能问题。
  +     无法监听新增属性和删除属性 ，解决：Vue.set  Vue.delete
  +     无法监听数组相关的方法，需要特殊处理。
  +     在vue3中，响应式就没有使用Object.defineProperty，使用了proxy。
* 对于数组的方法，如何实现劫持。
* 为何 v-for 中要用 key
  + diff算法中通过tag和key来判断是否是sameNode.
  + updateChildren中有了key，可以尽可能复用vnode，可以减少渲染次数，提升渲染性能。
  + key，不能是index和random。一般都是以id作为key
* 描述 vue 组件生命周期（以及有父子组件，两者的生命周期）
  
  + 父子组件嵌套的生命周期（也是一个面试题）
* 组件初次渲染和更新的过程
  初次渲染：

  

```text
  第一步：解析模板为render函数
  第二步：触发响应式，监听data中的属性，getter和setter
  第三步：执行render函数，生成vnode， 进而进行patch(elem,vnode)
    A）这一步会触发data getter，在getter中进行依赖收集（把数据“观察”起来）。
    注意：不一定是所有的数据都会被观察。是否被观察取决于模板中是否使用。
  第四步：把vnode转化成真实DOM，渲染到页面上。
```

    更新过程：
      第一步：修改数据，会触发data setter
    第二步：重新执行render函数，生成新的vnode（newVnode）
      第三步：进行patch(vnode,newVnode),patch的过程就是diff的过程

  

* 说一下对 MVVM 的理解
    数据驱动视图。如何达到数据驱动视图：vdom。
    简单的回答：只回答图上的内容 https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=mvvm&step_word=&hs=0&pn=0&spn=0&di=7214885350303334401&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=673888355%2C3365485600&os=383766179%2C1059975381&simid=673888355%2C3365485600&adpicid=0&lpn=0&ln=1197&fr=&fmq=1679387608751_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=https%3A%2F%2Fimg.jbzj.deiniu.com%2Ffile_images%2Farticle%2F201804%2F2018418101120793.jpg%3F2018318101136&fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3B1jtgt7_z%26e3Bv54AzdH3Fw6ptvsjAzdH3F8nbn00_z%26e3Bip4&gsm=1e&rpstart=0&rpnum=0&islist=&querylist=&nojc=undefined&dyTabStr=MCwzLDEsNiw0LDUsMiw3LDgsOQ%3D%3D

    复杂的回答：组件初次渲染和更新的过程

* computed 和 method 的区别？
* 为何组件 data 必须是一个函数？
  
  + 组件是可以复用，如果data是一个对象，多个组件实例中的data指向同一个堆空间。
* ajax 请求应该放在哪个生命周期？
  + mounted   js是单线程，ajax是异步获取数据，阻塞不了生命周期往下执行。
  + 放在created里面，也快不了多少时间
* 多组件有相同的逻辑，如何抽离？
  
  + 有很多复用技巧
* 何时需要使用异步组件？
  + 路由中异步加载
  + 加载大组件
* 何时需要使用 keep-alive
  + 缓存组件，不需要重复渲染
  + 如多个静态tab页切换。
  + 优化性能。
* 何时需要使用 beforeDestroy ？
  + 清除定时器
  + 解绑自定义事件 $off
  + 解绑原生DOM事件 scroll
* 什么是作用域插槽？为何需要它
  
  + 也是组件通信一种方案，使用作用域插槽实现子传父
* 场景题：用虚拟 DOM 描述一个 html 结构
* vue 如何监听 data 变化？
  
  + Object.defineProperty
* 简述 diff 算法过程
  + h vnode
  + path(elem, vnode) / path(vnode, newVnode)
  + pathVnode, addVnodes, removeVnodes
  + updateChildren key重要性
* vue 为何是异步渲染？
  + 合并data的修改，异步渲染，提高渲染性能
  + $nextTick()，在DOM更新完之后，自动调用回调。
* vue 性能优化 （开发环境编译模板）
  1）合理使用v-show和v-if
  2）合理使用computed
  3）v-for加上key, 在vue2中避免和v-if连用。
  4）自定义事件，DOM事件及时销毁。
  5）合理使用异步组件。
  6）合理使用keeplalive
  7）data层级不要太深
  8）webpack层面的优化（后面复习webpack, webpack4）
  9）前端通用的性能优化方案，如图片懒加载...
  10）使用SSR

## 二十，项目

链接：http://47.99.134.126:5008/#/home
