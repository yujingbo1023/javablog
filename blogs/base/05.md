---
title: 05-JS高级
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 1. 什么是预解析

**代码段是指一个script标签就是一个代码段。JS代码在执行时，是一个代码段一个代码段执行。**

```html
<!-- 代码段是彼此独立的，上面的代码段报错了，不会影响下面的代码段 -->
<!-- 1个script标签就是一个代码段 -->
<script>
    // 在一个代码段中就可以写JS代码
    var a = 110;

    // 上面代码段不能使用下面的代码段中定义的数据
    console.log(b); // ReferenceError: b is not defined
</script>
<!-- 一个网页中可以有多个代码段 -->
<script>
    var b = 220;
    // 可以在下面的代码段中使用上面的代码段中的数据
    console.log(a);
</script>
```

**JS代码的执行分两个阶段：一个叫预解析，一个叫执行，预解析结束后，才会进入到执行阶段。**

**什么是预解析?**
* 浏览器在执行JS代码的时候会分成两部分操作：预解析以及逐行执行代码
* 也就是说浏览器不会直接执行代码, 而是加工处理之后再执行, 
* 这个加工处理的过程, 我们就称之为预解析

**预编译期间做了什么？**
* 把声明提升：加var的变量就是被提升，function声明的函数也会提升，提升到代码段的最前面。
* 函数内部的局部变量，提升到函数体的最前面。
* 注意：变量的提升仅仅是声明 函数的提升不只提升了声明，也提升赋值

**练习题：**

```html
<script>
    // --------- 原题
    console.log(a);
    var a = 110;
    console.log(a);

    fn();

    function fn() {
        console.log("我是一个fn函数~");
    }
</script>
<script>
    // --------- 分析 
    // 下面的代码中有两个声明  加var的变量a    function声明的函数 fn
    // 两者都要提升  变量仅仅提升声明  function提升的整体
    console.log(a); // und
    var a = 110;
    console.log(a); // 110

    fn(); // 也可以执行
    function fn() {
        console.log("我是一个fn函数~");
    }
</script>
```

```html
<script>
    // --------- 原题
    g();
    var g = function() {
        console.log("g函数执行了....");
    };
</script>

<script>
    // --------- 分析 
    // g是一个变量  只不这个变量的值是一个函数  函数是一种数据类型
    // 进行预编译时，仅仅是提升了var g;  
    // var g; g的值是und    und();  报错了  
    g(); // TypeError: g is not a function  只有函数才可以加()调用
    var g = function() {
        console.log("g函数执行了....");
    }
</script>
```

```html
<script>
    // --------- 原题
    console.log(i);
    for (var i = 0; i < 10; i++) {}
    console.log(i);
</script>

<script>
    // --------- 分析 
    // i是全局变量  只有定义在函数内部的变量才是局部变量
    // var i会提升，所以前面输出的i是und
    console.log(i); // und
    for (var i = 0; i < 10; i++) {} // for循环对i进行了赋值
    console.log(i); // 10  
</script>
```

```html
<script>
    // --------- 原题
    var a = 666;
    fn()

    function fn() {
        var b = 777;
        console.log(a);
        console.log(b);
        console.log(c);
        var a = 888;
        var c = 999;
    }
</script>

<script>
    // --------- 分析 
    // 提升： 
    //    全局的：var a;   fn整体;  提升到代码段最前面 
    //    fn内部中的var b; var a; var c;都提升;  提升到函数体的最前面
    // 
    var a = 666;
    fn()
    // fn产生一个局部作用域，它的父级作用域是全局作用域
    function fn() {
        // var b; var a; var c;都提升了
        var b = 777;
        // 找a  自己有  使用自己的  如果自己没有  使用父级作用域的数据
        console.log(a); // und 自己函数体内如果有数据，就使用自己的数据
        console.log(b); // 777
        console.log(c); // und
        var a = 888;
        var c = 999;
    }
</script>
```

```html
<script>
    // --------- 原题
    console.log(value);
    var value = 123;

    function value() {
        console.log("我是value函数...");
    }
    console.log(value);
</script>

<script>
    // --------- 分析 
    // 预编译：
    //     提升：
    //        var value;会提升   value的值是und
    //        value函数整体也会提升   
    //             如果变量名和函数名一样，变量提升了，函数也提升了，提升后只会存在一个名字
    //             问题是value的值是函数，也就意味着，变量的value就被覆盖了
    console.log(value); // value是函数
    var value = 123; // 123赋值给了value，value又变成了123
    function value() {
        console.log("我是value函数...");
    }
    console.log(value); // 123
    // 提升的同名变量名和函数名，函数会覆盖变量，函数在JS中是一等公民，优先级高
</script>
```

```html
<script>
    // --------- 原题
    console.log(a);
    a = 666;
    console.log(a);
</script>

<script>
    // --------- 分析 
    //   没有加var的变量不会提升
    // 
    console.log(a); // a is not defined   /   und 
    a = 666;
    console.log(a); // 在一个代码段中，上面的代码出错了，下面的代码不会执行了
</script>
```

```html
<script>
    // --------- 原题
    function fn() {
        console.log(a);
        a = 666;
        console.log(a);
    }
    fn();
    console.log(a);
</script>

<script>
    // --------- 分析 
    // 提升：fn整体
    //    
    function fn() {
        console.log(a); // 报错   找a  没a  a is not defined  
        a = 666;
        console.log(a); // 不执行  
    }
    fn();
    console.log(a); // 不执行  
</script>
```

```html
<script>
    // --------- 原题
    function fn() {
        a = 110;
    }
    console.log(a);
</script>

<script>
    // --------- 分析 
    // 函数没有调用，相当于函数没有写，没有执行
    // 函数体中定义的所有的数据，都不会执行
    function fn() {
        a = 110; // 没有加var的变量是全局变量
    }
    // fn();  // 如果调用了，结果是110
    console.log(a);
</script>
```

```html
<script>
    // --------- 原题
    gn()

    function gn() {
        var k = 123;
        console.log(k);
    }
    console.log(k);
</script>

<script>
    // --------- 分析 
    // gn整体要提升
    gn()

    function gn() {
        var k = 123; // var k要提升到函数体最前面
        console.log(k); // 123
    }
    console.log(k); // 报错
</script>
```

## 2. 执行上下文和作用域链

**内存分区:**
* 我们只需要掌握两个区，一个是栈区，一个是堆区。
* 基本数据类型，是存储在栈区的，引用数据类型是存储在堆区，堆区的地址，还是保存在栈区

### 2.1 全局代码和函数代码中产生的EC

**JS代码分两类：**
* 全局代码：函数外面的代码都是全局代码
* 函数代码：一个函数就是一个局部代码

```html
<script>
    // 函数外面的就是全局代码
    var a = 1;
    var b = 2;

    function fn() {
        // 函数里面的是局部代码
        var c = 3;
        var d = 4;
    }
    fn()
    fn()
</script>
```

**分析如下:**
* 全局代码执行产生ECG（Execution Context Gloable），每当调用一个函数，就产生一个函数的EC。每产生一个EC，需要放到ECS（Execution Context Stack），当函数调用完毕，这个EC就是出栈，出栈后的EC，会被销毁，所谓的销毁指是它们分配的内存空间都要被释放掉。

**总结：**
* 当全局代码执行时，就会产生一个全局的执行上下文，EC(G); 
* 当函数代码执行时，就会产生一个局部的执行上下文，EC(Fn)。只要调用一个函数，就会产生一个局部执行上下文。调用100个函数，就会产生100个执行上下文。

**执行上下文栈：**
* js引擎内部有一个执行上下文栈（Execution Context Stack，简称ECS），它是用于执行代码的调用栈。
* Execute Context Stack  ===> ECS

**代码执行流程如下：**
* JS在执行代码时，肯定先执行全局代码，就会产生EC(G)，这个EC(G)就要入栈。当我们调用一个函数，就会产生一个局部的执行上下文，此时这个局部的执行上下文也要入栈。当函数调用完毕后，这个EC就要出栈，又进入EC(G)，当全局代码执行完后，EC(G)也要出栈。

**执行上下文的作用：**
* 提供数据，全局代码，肯定需要去全局的执行上下文中找数据。

### 2.2 全局代码和函数代码中产生的EC

**js引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）**
* 该对象 所有的作用域（scope）都可以访问； 
* 里面会包含Date、Array、String、Number、setTimeout、setInterval等等； 
* 其中还有一个window属性指向自己；说白了，GO就是window
* 只要我们写的全局变量或在全局中写的函数，都会挂载到window上面

**代码如下：**

```html
<script>
    console.log(window); // GO

    var a = 110;
    var b = 666;
    var res = a + b;

    function fn() {
        console.log("fn...");
    }

    console.log(window.a);
    console.log(window.b);
    window.fn()

    // 代码开始执行之前，JS引擎会帮我们创建一个全局对象，叫GO
    // 换句话，说到window，指的就是GO
    // GO中还需要放我们创建出来的全局变量和全局函数
    var globalObject = {
        String: "类",
        Data: "类",
        setTimeout: "函数",
        alert: "函数",
        // ....
        window: globalObject, // GO中有一个特殊的属性，叫window  window还是指向GO
        a: und,
        b: und,
        res: und,
        fn: "函数"
    };
</script>
```

```html
<script>
    var n = 110;
    console.log(n); // 110
    console.log(window.n) // 110

    m = 220;
    console.log(m); // 220
    console.log(window.m); // 220 m可以放到GO中，因为是全局变量

    console.log(window.name); // 人家给GO中放了一个name, 现在是空串
    console.log(window.x); // 访问对象中不存在的属性，结果是Und
</script>
```

**ECG被放入到ECS中里面包含两部分内容：**
* 第一部分：在代码执行前，在parser转成AST的过程中，会将全局定义的变量、函数等加入到GlobalObject中，但是并不会赋值；这个过程也称之为变量的作用域提升（hoisting） 
* 第二部分：在代码执行中，对变量赋值，或者执行其他的函数；

**遇到函数如何执行？**
* 在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context，简称FEC），并且压入到EC Stack中。

```html
<script>
    var a = 1;
    var b = 2;
    var res = a + b;
    console.log(res);

    function fn() {
        console.log("我是fn函数....");
    }
    // 当调用函数时，就会产生一个EC(fn)
    fn();
</script>
```

**ECF中包含三部分内容：**
* 第一部分：在解析函数成为AST树结构时，会创建一个Activation Object（AO）： AO中包含形参、arguments、函数定义和指向函数对象、定义的变量； 
* 第二部分：作用域链：由VO（在函数中就是AO对象）和父级VO组成，查找时会一层层查找； 
* 第三部分：this绑定的值：这个我们后续会详细解析；

**练习题（面试题）**

```html
<script>
    var n = 110;
    console.log(n);
    console.log(window.n);
    m = 220;
    console.log(m);
    console.log(x);
</script>
```

```html
<script>
    var a = 1;
    var b = "hello";

    function fn() {
        console.log("fn...");
    }
    var arr = ["a", "b", "c"];
    var obj = {
        name: "wc",
        age: 100
    }
</script>
```

```html
<script>
    function fn(a) {
        console.log(a);
    }
    fn(110)
    console.log(a);
</script>
```

```html
<script>
    var arr = [11, 22];

    function fn(arr) {
        arr[0] = 100;
        arr = [666];
        arr[0] = 0;
        console.log(arr);
    }
    fn(arr);
    console.log(arr);
</script>
```

```html
<script>
    var a = 1;
    var b = 1;

    function gn() {
        console.log(a, b);
        var a = b = 2;
        console.log(a, b);
    }
    gn();
    console.log(a, b);
</script>
```

```html
<script>
    var a = 1;
    var obj = {
        uname: "wangcai"
    }

    function fn() {
        var a2 = a;
        obj2 = obj;
        a2 = a;
        obj.uname = "xiaoqiang";
        console.log(a2);
        console.log(obj2);
    }
    fn();
    console.log(a);
    console.log(obj);
</script>
```

```html
<script>
    // 同名的变量名，只会提升第1个
    var a = 1;
    var a = 2;
    var a = 3;
    console.log(a);

    // 预编译后的代码如下：
    var a;
    a = 1;
    a = 2;
    a = 3;
    console.log(a);
</script>
```

```html
<script>
    // 提升：var a;  
    // a函数整体提升   a = funciton(){};
    // 执行：a = 1;
    var a = 1;

    function a() {
        console.log("a...");
    }
    console.log(a); // 函数a 
</script>
```

```html
<script>
    var a = 10;
    // 赋值操作就是把栈区（GO，AO）中的数据，copy一份，赋值给变量
    var b = a;
    console.log(a, b); // 10 10
    b = 1; // 把1重新赋值给b所对应的内存空间
    console.log(a, b); // 10  1
</script>
```

```html
<script>
    var a = [1, 2];
    // 把栈区的地址赋赋值给b， a和b指向同一个内存空间
    var b = a;
    console.log(a, b); // [1,2]   [1,2]
    // 把一个新堆的地址重新赋值给b  b指向一个新堆空间
    b = [3, 4];
    console.log(a, b); // [1,2]  [3,4] 
</script>
```

```html
<script>
    var a = [1, 2];
    var b = a;
    console.log(a, b); // [1,2] [1,2]
    b[0] = 110;
    console.log(a, b); //  [110, 2]   [110, 2]
</script>
```

```html
<script>
    var a = [1, 2];
    var b = [1, 2];
    // a 和 b 是地址  == 比较时比较的是地址 不同的堆，地址是不可能一样
    console.log(a == b); // false
    console.log(a === b); // false
</script>
```

```html
<script>
    var a = 110;
    var b = 110;
    console.log(a == b); // true
</script>
```

```html
<script>
    var a = [1, 2];
    // a 和 b中保存的地址是一样的
    var b = a;
    console.log(a == b); // true
    console.log(a === b); // true
</script>
```

```html
<script>
    console.log(a, b); // 报错：b is not defined
    var a = b = 2;
</script>
```

```html
<script>
    var a = {
        m: 666
    };
    var b = a;
    b = {
        m: 888
    };
    console.log(a.m); // {m:666}
</script>
```

```html
<script>
    var a = {
        n: 12
    };
    var b = a;
    b.n = 13;
    console.log(a.n); // 13
</script>
```

```html
<script>
    console.log(a); // 报错  
    a = 111;
</script>
```

```html
<script>
    var m = 1;
    n = 2;
    console.log(window.m); // 1
    console.log(window.n); // 2
</script>
```

```html
<script>
    function fn() {
        var a = 111;
    }
    fn();
    console.log(window.a); // 访问一个对象上不存在的属性，结果是und
</script>
```

```html
<script>
    var a = -1;
    if (++a) { // ++a 整体是新值 0 => false
        console.log("666");
    } else {
        console.log("888");
    }
</script>
```

```html
<script>
    console.log(a, b); // und  und 
    if (true) {
        var a = 1;
    } else {
        var b = 2;
    }
    console.log(a, b); // 1 und
</script>
```

```html
<script>
    var obj = {
        name: "wc",
        age: 18
    }
    // in是一个运算符  判断一个属性是否属性某个对象
    console.log("name" in obj); // true
    console.log("score" in obj); // false
</script>
```

```html
<script>
    var a;
    console.log(a); // und
    if ("a" in window) {
        a = 110;
    }
    console.log(a); // 110
</script>
```

```html
<script>
    console.log(a); // und
    if ("a" in window) {
        var a = 110;
    }
    console.log(a);
    110
</script>
```

```html
<script>
    var a = 100;

    function fn() {
        console.log(a);
        return
        var a = 110;
    }
    fn();
</script>
```

```html
<script>
    var n = 100;

    function foo() {
        n = 200;
    }
    foo()
    console.log(n);
</script>
```

```html
<script>
    function fn() {
        var a = b = 100;
    }
    fn();
    console.log(a);
    console.log(b);
</script>
```

```html
<script>
    var n = 100;
    // 找一个函数的父的EC，看的是函数的定义处，不是调用处
    function fn() {
        console.log(n);
    }

    function gn() {
        var n = 200;
        console.log(n);
        fn()
    }
    gn()
    console.log(n);
</script>
```

## 3. 加var的变量和不加var的变量

**加var的变量和不加var的变量有什么区别：**
* 加var的变量在预编译期间会提升，不加var的变量在预编译期间不会提升。

```html
<script>
    // 加var的变量在预编译期间会提升，不加var的变量在预编译期间不会提升。
    // console.log(a);  // undefined
    // var a = 110;

    console.log(b); // ReferenceError: b is not defined
    b = 120;
</script>
```

* 不管有没有加var，创建的全局变量，都会放到GO中的，也就是可以通过window.xx。

```html
<script>
    // 不管有没有加var，创建的全局变量，都会放到GO中的，也就是可以通过window.xx。
    var a = 110;
    b = 120;
    console.log(window.a); // 110
    console.log(window.b); // 120
</script>
```

* 加var的变量，可能是全局变量，也可能是局部变量，不加var的变量，只能是全局变量。

* 加var的局部变量，不会作用window的属性

```html
<script>
    function fn() {
        var a = 110;
    }
    fn();
    console.log(window.a);
</script>
```

**不加var创建的变量：**
* 不建议使用。 项目中尽量不要使用全局变量。在项目中，不要使用没有加var的变量。

## 4. let声明的变量

**使用let声明的变量的特点：**
* 使用let声明的变量没有提升。针对这个错误：ReferenceError: Cannot access 'a' before initialization有人是这样说的：let声明的变量也有提升。但是没有赋值（没有初始化），就记一种：使用let声明的变量也提升，只不过没有初始化，去使用的时候就报错了。

```html
<script>
    // 使用let声明的变量没有提升
    // initialization  初始化的意思
    console.log(a); // ReferenceError: Cannot access 'a' before initialization  
    let a = 110; // let也可以声明变量
</script>
```

* 使用let配合{}会形成块级作用域。 在C语言中，就有块级作用域。在JS中，原本是没有块级作用域。在块中声明的变量，只能在块中使用。

```html
<script>
    // 在let之前，只有两种作用域 1）全局作用域  2）函数内部的局部作用域
    var a = 110; // a处于全局作用域中
    console.log(a);

    function fn() {
        var b = 220; // b处于局部作用域中
        console.log(b);
    }
    fn();
    // 在let之前，是没有块级作用域  {}
    if (true) { // if 后面的 {} 在其它编程语言中会形成块级作用域
        // {}如果是块级作用域  c在{}外面是不能访问的
        var c = 330; // c是全局变量
    }
    console.log(c);
</script>
```

```html
<script>
    if (true) {
        // 此时 let + {} 就会形成块级作用域
        // 在此块定义的数据，只能在此块中访问
        let a = 110;
    }
    console.log(a);
</script>
```

* 使用let声明的变量并不会挂载到GO中

```html
<script>
    let a = 110;
    console.log(window.a);
</script>
```

* 使用let声明的变量也不能重复声明

```html
<script>
    var a = 1;
    var a = 2;
    var a = 3;
    console.log(a);
    let b = 1;
    let b = 2;
    let b = 3;
</script>
```

**需要知道：项目中不要使用var来声明变量，你要声明变量，使用let。**

**使用var声明变量不足：**
* 提升
* 重复声明   浏览器中有这样一个机制，如果一个变量提升过了，后面遇到同名变量，就不会提升了。

## 5. const声明变量（常量）

**使用const声明的变量（常量）的特点：**
* 声明的变量不能修改（常量）

```html
<script>
    const a = 110;
    a = 120;
    console.log(a);
</script>
```

* 声明时必须赋值（初始化）   定义 = 声明+赋值（初始化）

```html
<script>
    const a;
    a = 110;
    console.log(a);
</script>
```

* const声明的常量也不会提升。
* const声明的常量配合{} 也会形成块级作用域
* const声明的常量也不会挂载到GO上。

**总结：项目中不要使用var，如果声明变量使用let，如果声明常量，使用const。**

## 6. 练习题（面试题）

```html
<script>
    // 使用之前学的知识点来做
    // fn函数整体提升了
    console.log(fn) // fn函数
    window.fn(); // fn...
    console.log(window.fn); // fn函数
    if ("fn" in window) {
        fn(); // fn...
        function fn() {
            console.log("fn...");
        }
    }
    fn();
</script>
```

```html
<script>
    // 在很早的浏览器中，运行出来的结果，就是上面分析出来的结果
    // 但是现在的浏览器结果不一样了
    // 如果是全局函数  并且这个函数放到if中  它提升的不再是整体提升
    // 它提升的仅仅是函数名，整体函数体是没有提升的
    // 在预编译期间，如果函数声明放到if中，仅仅是提升函数名，不提升函数体
    console.log(fn) // fn函数名提升了，默认值和变量是一样的，是und
    window.fn(); // und不能加()去调用 
    console.log(window.fn); // 
    if ("fn" in window) {
        fn(); // 
        function fn() {
            console.log("fn...");
        }
    }
    fn();
</script>
```

```html
<script>
    // 在很早的浏览器中，运行出来的结果，就是上面分析出来的结果
    // 但是现在的浏览器结果不一样了
    // 如果是全局函数  并且这个函数放到if中  它提升的不再是整体提升
    // 它提升的仅仅是函数名，整体函数体是没有提升的
    // 在预编译期间，如果函数声明放到if中，仅仅是提升函数名，不提升函数体
    console.log(fn) // und 
    console.log(window.fn); //  und 
    // 问：GO中有没有fn  答：有的，只不过它的值是und 
    if ("fn" in window) {
        // 如果if条件成立，进入到if中的第1件事，就是给fn赋值
        fn(); // fn...
        function fn() {
            console.log("fn...");
        }
    }
    fn();
</script>
```

```html
<script>
    // 预编译：加var变量和function声明的函数整体
    // function fn(){ console.log(1); } 要提升   fn是一个函数 log(1)
    // function fn(){ console.log(2); }  已经提升过一次fn了， fn要重新赋值  log(2)
    // var fn; 进提升  fn值又变成了und 
    // function fn(){ console.log(4); }  fn的又变成了函数  log(4)
    // function fn(){ console.log(5); }  fn的又要重新赋值  log(5)
    // fn  函数   log(3)
    fn(); // 5
    function fn() {
        console.log(1);
    }
    fn(); // 5
    function fn() {
        console.log(2);
    }
    fn(); // 5
    var fn = function() {
        console.log(3);
    }
    fn(); // 3
    function fn() {
        console.log(4);
    }
    fn(); // 3
    function fn() {
        console.log(5);
    }
    fn(); // 3
</script>
```

```html
<script>
    // var a = 12; var b = 13; var c = 14;
    var a = 12;
    b = 13;
    c = 14;

    function fn(a) {
        // 形参a是函数内部的局部变量a  形参a的值是10
        console.log(a, b, c); // 10   13   14
        a = 100; // 找a  把100赋值给了局部变量a   
        b = 200; // 找b   把200赋值给外面的b 是全局变量b 
        console.log(a, b, c); // 100  200  14
    }
    b = fn(10); // und
    console.log(a, b, c); // 12  und   14
</script>
```

```html
<script>
    var a = 12;
    b = 13;
    c = 14;

    function fn(a) {
        console.log(a, b, c);
        a = 100;
        b = 200;
        console.log(a, b, c);
    }
    b = fn(10);
    console.log(a, b, c);
</script>
```

```html
<script>
    // var a = 1;
    // let a = 2;  // Identifier 'a' has already been declared
    function sum(a) {
        // 形参是相当于函数内部局部变量  
        console.log(a); //  报错了
        let a = 100; // 
        console.log(a); // 
    }
    sum(200);
</script>
```

```html
<script>
    var ary = [12, 13];

    function fn(ary) {
        console.log(ary);
        ary[0] = 100;
        ary = [100];
        ary[0] = 0;
        console.log(ary);
    }
    fn(ary);
    console.log(ary);
</script>
```

```html
<script>
    function fn() {
        function gn() {
            console.log("gn...");
        }
        return gn;
    }
    var r = fn();
    r();
</script>
```

```html
<script>
    function fn() {
        // 直接返回一个函数，返回的也是地址
        return function gn() {
            console.log("gn...");
        }
    }
    var r = fn();
    r();
</script>
```

```html
<script>
    var i = 0;

    function A() {
        var i = 10;

        function x() {
            console.log(i);
        }
        return x;
    }
    var y = A();
    y();

    function B() {
        var i = 20;
        y();
    }
    B();
</script>
```

```html
<script>
    var i = 5;

    function fn(i) {
        return function(n) {
            console.log(n + (++i))
        }
    }
    var f = fn(1);
    fn(2);
    fn(3)(4);
    fn(5)(6);
    f(7);
    console.log(i);
</script>
```

## 7. JS中函数是一等公民

**在JavaScript中，函数是非常重要的，并且是一等公民：**
* 那么就意味着函数的使用是非常灵活的； 
* 函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用； 

**什么是高阶函数：**
* 一个函数它的参数是函数或它的返回值是函数，那么这个函数就是高阶函数。

* 自己编写高阶函数

```html
<script>
    // func是形参  把gn这个函数传递给func
    // gn中保存的是地址  地址传递给func
    function fn(func) {
        func();
    }

    function gn() {
        console.log("gn...");
    }
    // gn叫实参
    fn(gn)
</script>
```

```html
<script>
    function add(num1, num2) {
        return num1 + num2
    }

    function sub(num1, num2) {
        return num1 - num2
    }

    function mul(num1, num2) {
        return num1 * num2
    }
    // 封装一个计算器函数
    function calc(num1, num2, fn) {
        console.log(fn(num1, num2));
    }
    calc(10, 20, add);
    calc(10, 20, sub);
    calc(10, 20, mul);
</script>
```

```html
<script>
    // fn也是高阶函数
    function fn() {
        function gn() {
            console.log("gn");
        }
        return gn; // 返回一个地址
    }
    let kn = fn();
    kn();
</script>
```

```html
<script>
    // 高阶函数：如果一个函数接受另外一个函数作为参数，或者该函数会返回另外一个函数作为返回值，
    // 那么这个函数就叫高阶函数
    // 闭包可以延长变量的生命周期
    function fn(count) {
        function add(num) {
            return count + num;
        }
        return add;
    }
    var gn5 = fn(5);
    console.log(gn5(6));
    console.log(gn5(10));
</script>
```

* 使用内置的高阶函数

```html
<!-- 使用传统的方式过滤偶数，如下： -->
<script>
    let nums = [10, 3, 12, 50, 99, 30];
    // 把上面数组中的偶数过滤出来
    let newArr = [];
    // 命令式编程
    for (var i = 0; i < nums.length; i++) {
        if (nums[i] % 2 == 0) {
            newArr.push(nums[i])
        }
    }
    console.log(newArr);
</script>
```

```html
<!-- 可以使用高阶函数，如下： -->
<script>
    // ---------------------- filter 过滤
    let nums = [10, 3, 12, 50, 99, 30];
    // function(item){}  整体是实参
    // filter 是JS中内置好的高阶函数
    // item 这个item表示数组中的每一项
    // 不要问为什么，JS就是这规定
    // 声明式编程
    let newArr = nums.filter(function(item) {
        // console.log(item);
        // return true; // 把item每一项都放到新数组中
        return item % 2 == 0;
    })
    console.log(newArr); // filter返回值是一个数组
</script>
```

```html
<script>
    // ---------------------- map 映射
    let nums = [10, 3, 12, 50, 99, 30];
    let newArr = nums.map(function(item) {
        // 可以对item每一项数据进行加工
        return item * 10
    })
    console.log(newArr); // map返回值是一个新数组
</script>
```

```html
<script>
    // ---------------------- forEach 遍历
    let nums = [10, 3, 12, 50, 99, 30];
    nums.forEach(function(item) {
        console.log(item);
    })
</script>
```

```html
<script>
    // ---------------------- find 查找
    let nums = [10, 3, 12, 50, 99, 30];
    var item = nums.find(function(item) {
        return item === 30
    })
    console.log(item);
</script>
```

```html
<script>
    // ---------------------- findIndex 
    let nums = [10, 3, 12, 50, 99, 30];
    // 返回找到元素的索引
    var item = nums.findIndex(function(item) {
        return item === 30
    })
    console.log(item);
</script>
```

```html
<script>
    // ---------------------- find 查找
    let names = [{
            name: "wc",
            age: 10
        },
        {
            name: "xq",
            age: 11
        },
        {
            name: "z3",
            age: 12
        },
        {
            name: "L4",
            age: 13
        },
    ];
    var res = names.find(function(item) {
        // item表示数组中的每一项，是里面的对象
        return item.name === 'z3'
    })
    console.log(res);
</script>
```

## 8. 什么是闭包

**什么是闭包：**
* 函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

**闭包是一片不会被销毁的EC。它对EC中的数据有保护和保存的作用：**
* 保护：防止像全局变量那样被污染，数据在函数内部，外界访问不了。
* 保存：可以像全局变量那样，延长变量的生命周期。
* 闭包使用不当可能会导致内存泄露

**应用场景：**
* 模块封装，在各模块规范（ES6）出现之前，都是用这样的方式防止变量污染全局
* 数据私有化
* 封装一些工具函数
* 在循环中创建闭包，防止取到意外的值。

```html
<script>
    var i = 20;

    function fn() {
        i -= 2;
        var i = 10;
        return function(n) {
            console.log((++i) - n);
        }
    }
    var f = fn();
    f(1);
    f(2);
    fn()(3);
    console.log(i);
</script>
```

```html
<script>
    let a = 0;
    b = 0;

    function A(a) {
        A = function(b) {
            // b++ 优先级高于 + 
            alert(a + b++);
        }
        alert(a++)
    }
    A(1); // 1
    A(2); // 4
</script>
```

```html
<script>
    var t = (function(i) {
        return function() {
            alert(i *= 2)
        }
    })(2);

    t(5);
</script>
```

```html
<script>
    var n = 0;

    function a() {
        var n = 10;

        function b() {
            n++;
            console.log(n);
        }
        b();
        return b;
    }
    var c = a();
    c();
    console.log(n);
</script>
```

## 9. IIFE

**Immediately Invoked Function Expression（立即调用函数表达式）**

```html
<script>
    function fn() {
        console.log("fn...");
    }
    // 之前：先定义函数  再去调用函数
    fn();

    // 思考：在定义函数时，能不能直接去调用
    // 答：IIFE
</script>
```

```html
<script>
    function fn() {
        console.log("fn...");
    }()
</script>
```

* 正确的IIFE，如下：

```html
<script>
    // IIFE写法一
    (function fn() {
        console.log("fn...");
    })()
</script>
<script>
    // IIFE写法二
    (function fn() {
        console.log("fn...");
    }())
</script>
<script>
    // IIFE写法三
    + function fn() {
        console.log("fn...");
    }()
</script>
<script>
    // IIFE写法四
    - function fn() {
        console.log("fn...");
    }()
</script>
<script>
    // IIFE写法五
    ! function fn() {
        console.log("fn...");
    }()
</script>
```

* 注意问题：

```html
<script>
    let obj = {
        name: "wc",
        age: 100
    }

    (function() {
        console.log("mn...");
    })();
</script>
```

```html
<script>
    let obj = {
        name: "wc",
        age: 100
    };

    (function() {
        console.log("mn...");
    })();
</script>
```

* 为了防止，你前面的代码没有加分号，通常写一个IIFE，都会在前面加上分号，如下：

```html
<script>
    let obj = {
        name: "wc",
        age: 100
    }
    // 在写IIFE时，直接以分号开头
    ;
    (function() {
        console.log("mn...");
    })();
</script>
```

## 10. this是什么？

**我们先来看一个让人困惑的问题，定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果，如下：**

```html
<script>
    function fn() {
        console.log(this);
    }
    // 直接调用，独立调用
    fn()

    // 创建一个对象，让对象去借用fn函数
    var obj = {
        name: "wc"
    };
    fn.call(obj)

    var obj2 = {
        name: "xq",
        func: fn
    }
    obj2.func()
</script>
```

**这个的案例可以给我们什么样的启示呢？**
1. 函数在调用时，JavaScript会默认给this绑定一个值； 
2. this的绑定和定义的位置（编写的位置）没有关系； 
3. this的绑定和调用方式以及调用的位置有关系； 
4. this是在运行时被绑定的；

```html
<script>
    // 谁也说不清，现在的this是谁
    // 只有代码运行起来后，JS底层才会给this赋值
    // this最终值和你书写的位置没有关系
    // 和你如何调用fn函数是有关系，不同的调用方式，会给this赋不同的值
    function fn() {
        console.log(this);
    }
</script>
```

**那么this到底是怎么样的绑定规则呢，绑定规则如下：**
* 绑定一：默认绑定； 
* 绑定二：隐式绑定； 
* 绑定三：显示绑定； 
* 绑定四：new绑定；

## 12. 默认绑定

**独立函数调用就是所谓的默认绑定，独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用**

* 代码如下：

```html
<script>
    // --------------- 独立的函数调用
    function fn() {
        console.log(this);
    }
    // 独立的函数调用
    // 函数内部的this,在浏览器中表示window
    fn();
</script>
```

```html
<script>
    // --------------- 独立的函数调用
    function fn() {
        console.log(this);
    }

    function gn() {
        console.log(this);
        fn() // 独立的函数调用
    }

    function kn() {
        console.log(this);
        gn(); // 独立的函数调用
    }
    kn(); // 独立的函数调用 
</script>
```

```html
<script>
    // --------------- 独立的函数调用
    var obj = {
        name: "wc",
        fn: function() {
            console.log(this);
        }
    }
    var gn = obj.fn;
    gn(); // 独立的函数调用 
</script>
```

```html
<script>
    // --------------- 独立的函数调用
    function fn() {
        console.log(this);
    }
    var obj = {
        name: "wc",
        fn: fn
    }
    var gn = obj.fn;
    gn(); // 独立的函数调用 
</script>
```

```html
<script>
    // --------------- 独立的函数调用
    function fn() {
        function gn() {
            console.log(this);
        }
        return gn;
    }
    var kn = fn();
    kn(); // 独立的函数调用 
</script>
```

## 13. 隐式绑定

**另外一种比较常见的调用方式是通过某个对象进行调用的，也就是它的调用位置中，是通过某个对象发起的函数调用**

* 代码如下：

```html
<script>
    // --------------- 隐式绑定
    function fn() {
        console.log(this);
    }

    var obj = {
        name: "wc",
        fn: fn
    }
    // fn中的this表示obj
    // fn中this是谁，看.前面是谁
    obj.fn(); // 隐式绑定 会把obj对象绑定到this上
</script>
```

```html
<meta charset="utf-8">
<script>
    // --------------- 隐式绑定
    var obj = {
        name: "wc",
        running: function() {
            console.log(this.name + "在跑步...");
        },
        coding: function() {
            console.log(this.name + "在打代码...");
        }
    }
    obj.running();
    obj.coding();
</script>
```

```html
<script>
    // --------------- 隐式绑定
    var obj = {
        name: "wc",
        fn: function() {
            console.log(this);
        }
    }
    var obj2 = {
        name: "xq",
        gn: obj.fn
    }
    // fn中this是谁，看.前面是谁
    obj2.gn(); // obj2
</script>
```

## 14. 显示绑定

**隐式绑定有一个前提条件：**
* 必须在调用的对象内部有一个对函数的引用（比如一个属性）； 
* 如果没有这样的引用，在进行调用时，会报找不到该函数的错误； 
* 正是通过这个引用，间接的将this绑定到了这个对象上；

**如果我们不希望在 对象内部 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？**

* JavaScript所有的函数都可以使用call和apply方法（这个和Prototype有关）。 
  + 它们两个的区别这里不再展开； 
  + 其实非常简单，第一个参数是相同的，后面的参数，apply为数组，call为参数列表； 
* 这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的。 
* 在调用这个函数时，会将this绑定到这个传入的对象上

**因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 显示绑定。**

* 代码如下：

```html
<script>
    // fn是一个函数
    function fn() {
        console.log("fn...");
    }
    // 在JS中一切都是对象，函数也是对象
    // 可以给这个对象上添加属性
    fn.uname = "wc";
    fn.age = 18;
    fn.score = 100;
    console.log(fn.uname);
    console.log(fn.age);
    console.log(fn.score);
</script>
```

* 通过call，apply，bind可以改变this指向。
* 函数这个对象上，默认有几个方法，现在学习几个：call，apply，bind。
* 代码如下：

```html
<script>
    function fn() {
        console.log("fn...");
        console.log(this);
    }
    let obj = {
        name: "wc"
    }
    // fn本身也是对象
    // call的作用：1）显示绑定this  2）让函数执行
    // 通过call可以显示绑定this为obj
    fn.call(obj);
</script>
```

* apply的作用和call是一模一样的，如下：

```html
<script>
    function fn() {
        console.log("fn...");
        console.log(this);
    }
    let obj = {
        name: "wc"
    }
    // apply的作用：1）显示绑定this  2）让函数执行
    // 通过call可以显示绑定this为obj
    fn.apply(obj);
</script>
```

* bind使用如下：

```html
<script>
    function fn() {
        console.log("fn...");
        console.log(this);
    }
    let obj = {
        name: "wc"
    }
    //bind的作用：1）显示绑定this  2）不会让函数执行   3）返回一个绑定this之后新函数
    // 通过call可以显示绑定this为obj
    let newFn = fn.bind(obj);
    newFn();
</script>
```

* 如果call，apply，bind后面跟的是基本数据类型，如下：

```html
<script>
    function fn() {
        console.log("fn...");
        console.log(this);
    }
    fn.call("hello"); // 会把"hello"包装成一个新的对象
    fn.call(undefined); // 参数是und this指定window
    fn.call(null); // 参数是null this指定window
</script>
```

## 15. new绑定

**JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。使用new关键字来调用函数是，会执行如下的操作：**

1. 创建一个全新的对象； 
2. 这个新对象会被执行prototype连接； 
3. 这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）； 
4. 如果函数没有返回其他对象，表达式会返回这个新对象；

```html
<script>
    // --------------- new运算符
    // 函数的几种角色：
    //    1）普通函数
    //    2）对象的方法
    //    3）普通的对象
    //    4）类  new一个类，就得到一个对象
    // 如果你要把函数当成一个类，建议把函数名首字母大写
    function Fn() {
        // new做了什么
        //   1）在类中创建一个空的对象
        //   2）把这个对象绑定到类中的this上面
        //   3）返回这个空对象 
        this.name = "wc";
        this.age = 18;
    }
    let obj = new Fn(); // new一个类，得到一个对象
    console.log(obj); // {name: 'wc', age: 18}
</script>
```

```html
<script>
    // 类  构造器
    //   JS内置了一些构造器  String  Number  Boolean
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    let p1 = new Person("wc", 18);
    console.log(p1);
    let p2 = new Person("xq", 20);
    console.log(p2);
</script>
```

## 16. 内置函数的绑定

**有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数**
* 这些内置函数会要求我们传入另外一个函数； 
* 我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行； 
* 这些函数中的this又是如何绑定的呢？

```html
<script>
    // 一次性定时器
    // 3000表示3000ms  3s
    // 3s之后，会自动调用里面的函数
    // setTimeout(function(){
    //     console.log("hello 定时器~");
    // },3000)

    // 循环定时器
    // 每隔2s会执行里面的函数
    setInterval(function() {
        console.log("hello 定时器~");
    }, 2000)
</script>
```

* 定时器中的this表示什么？如下：

```html
<script>
    // 定时器中的this表示window。
    setTimeout(function() {
        console.log(this);
    }, 3000)

    setInterval(function() {
        console.log(this);
    }, 2000);
</script>
```

* 监听器中的this，表示什么，如下：

```html
<div id="box">click me</div>
<script>
    // 得到id为box的元素  dom元素是一个对象
    // 对象是引用数据类型
    let box = document.getElementById("box");
    // box表示事件源  事件发生的场所
    // click表示事件类型    JS中有非常多不同类型的事件
    // function(){}   表示当点击事件发生了做什么 监听器
    box.onclick = function() {
        console.log("hello DOM~");
        console.log(this); // 监听器中的this表示事件源
    }
</script>
```

* 数组中有非常多的方法，这个方法中的this又表示什么，如下：

```html
<script>
    let names = ["wc", "xq", "z3"];
    names.forEach(function(item) {
        console.log(item, this);
    }, {
        name: "ok"
    })
</script>
```

## 17. 规则优先级

**默认规则的优先级最低**
* 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this 
* 显示绑定优先级高于隐式绑定 

```html
<script>
    // 隐式绑定
    let obj = {
        name: "wc",
        fn: function() {
            console.log(this);
        }
    }
    obj.fn();
</script>
```

```html
<script>
    function fn() {
        console.log(this);
    }
    let obj = {
        name: "wc",
        // bind 作用：1）绑定this 2）返回一个绑定this指向后的新函数
        fn: fn.bind({
            name: "xq"
        }) // fn.bind({name:"xq"})是显示绑定
    }
    obj.fn(); // obj.fn() 隐式绑定    
</script>
```

* new绑定优先级高于隐式绑定 

```html
<script>
    var obj = {
        name: "wc",
        fn: function() {
            console.log(this);
        }
    }
    // obj.fn(); // 隐式绑定  

    // 在JS中，只要是函数，都可以new
    let res = new obj.fn();
</script>
```

**new绑定优先级高于bind**
* new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高 
* new绑定可以和bind一起使用，new绑定优先级更高 

```html
<script>
    function fn() {
        console.log(this);
    }
    // bind返回改变this指向后的新函数
    var gn = fn.bind({
        name: "wc"
    });
    // gn();

    // this 是 {}  说明：new绑定高于显示绑定
    var kn = new gn();
</script>
```

```html
<script>
    function fn() {
        console.log(this);
    }
    // new 不能和call和apply一起使用
    // call 可以让fn执行  gn不是函数
    var gn = fn.call({
        name: "wc"
    });
    console.log(gn);
    var kn = new gn();
</script>
```

## 18. 忽略显示绑定

**我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。**
* 如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则

```html
<script>
    function fn() {
        console.log(this);
    }

    fn.apply({
        name: "wc"
    })

    // 忽略显示绑定
    fn.apply(null) // window
    fn.apply(undefined) // window
    var gn = fn.bind(null);
    gn();
</script>
```

## 19. 间接函数引用

**另外一种情况，创建一个函数的 间接引用，这种情况使用默认绑定规则**
* 赋值(obj2.foo = obj1.foo)的结果是foo函数； 
* foo函数被直接调用，那么是默认绑定；

```html
<script>
    var obj = {
        name: "wc",
        fn: function() {
            console.log(this);
        }
    }

    var obj2 = {
        name: "xq"
    };

    // obj2.gn = obj.fn;
    // obj2.gn(); // 隐式绑定
    // IIFE    var a = 1;
    // IIFE this表示window
    ;
    (obj2.gn = obj.fn)();

    ;
    (function() {
        console.log(this);
    }())
</script>
```

## 20. ES6箭头函数

```html
<script>
    // var fn = function(num1,num2){
    //     return num1 + num2;
    // }

    // 像上面的函数可以简写
    var fn = (num1, num2) => {
        return num1 + num2;
    }
    console.log(fn(1, 2));
</script>
```

```html
<script>
    // 如果形参只有一个，()可以不写
    var fn = num => {
        return num * 10;
    }
    console.log(fn(10));
</script>
```

```html
<script>
    // 如果函数体中只有一行语句，{}可以不写
    var fn = num => console.log(num + 100);
    fn(100)
</script>
```

```html
<script>
    // 如果函数体中只有一行代码，并且这行代码是return语句
    // {}可以不写  return也可以不写
    var fn = num => num * 10;
    console.log(fn(10));
</script>
```

```html
<script>
    // 如果函数体中只有一行代码，并且是return语句
    // return了一个对象
    // var fn = function(){
    //     return { name:"wc" }
    // }

    // 把上面的代码转成箭头函数
    // 此时它会把对象的{} 当成函数的{}
    // 需要使用()把对象包起来
    var fn = () => ({
        name: "wc"
    })
    console.log(fn());
</script>
```

## 21. ES6箭头函数this

**为什么在setTimeout的回调函数中可以直接使用this呢？**
* 因为箭头函数并不绑定this对象，那么this引用就会从上层作用于中找到对应的this。

**记：箭头函数中的this，需要向上找一级。**

```html
<script>
    console.log(this); // 最外层的this是window

    var fn = () => {
        // 箭头函数中的this都需要向外找一级
        console.log(this);
    }
    fn(); // window

    var obj = {
        name: "wc"
    }
    fn.call(obj); // window
</script>
```

```html
<script>
    var fn = () => {
        console.log(this);
    }
    fn.call("hello")
    fn.call({})
    fn.call(null)
    fn.call(undefined)
</script>
```

```html
<script>
    var obj = {
        name: "wc",
        fn: () => {
            console.log(this);
        }
    }
    obj.fn();
</script>
```

```html
<script>
    // setTimeout(function(){
    //     console.log(this);
    // },300)

    setTimeout(() => {
        console.log(this);
    }, 300);
</script>
```

## 22. 练习题

```html
<script>
    function fn() {
        console.log(this)
    }
    fn() // window
    window.fn() // window
</script>
```

```html
<button onclick="fn">登录</button>
<script>
    let btn = document.getElementsByTagName("button")[0]
    btn.onclick = function() {
        // 监听器中的this表示事件源
        console.log(this)
    }
</script>
```

```html
<script>
    let obj = {
        name: "wangcai",
        age: 100,
        run: function() {
            console.log(this)
            console.log("run....")
        }
    }
    obj.run()
</script>
```

```html
<script>
    ;
    (function f() {
        console.log(this);
    }()); // IIFE中的this表示window
</script>
```

```html
<button id="box">点击</button>
<script>
    let btn = document.getElementById("box");

    function f() {
        console.log(this);
    }
    // f()是值   und
    btn.onclick = f();
</script>
```

```html
<button id="box">点击</button>
<script>
    let btn = document.getElementById("box");

    function f() {
        return function() {
            console.log(this)
        }
    }
    btn.onclick = f();
</script>
```

```html
<script>
    function qq() {
        console.log(this);
    }
    window.qq();
    qq();
</script>
```

```html
<script>
    let wc = {
        name: "wangcai",
        age: 100,
        eat: function() {
            console.log("eat...")
            console.log(this);
        }
    }
    wc.eat();
</script>
```

 

```html
<script>
    let wc = {
        name: "wangcai",
        age: 100,
        eat: function() {
            console.log("eat...")
            console.log(this);
        }
    }
    let mm = wc.eat;
    mm(); // 独立函数调用
</script>
```

 

​    

```html
<script>
    var num = 10;
    var obj = {
        num: 20
    }
    obj.fn = (function(num) {
        this.num = num * 3;
        num++;
        console.log(num);
        return function(n) {
            this.num += n;
            num++;
            console.log(num)
        }
    })(obj.num);

    var fn = obj.fn;
    fn(5)
    console.log(window.num);
</script>
```

```html
<script>
    var num = 10;
    var obj = {
        num: 20
    }
    obj.fn = (function(num) {
        this.num = num * 3;
        num++;
        console.log(num);
        return function(n) {
            this.num += n;
            num++;
            console.log(num)
        }
    })(obj.num);

    obj.fn(10);
    console.log(num)
    console.log(window.num)
    console.log(obj.num)
</script>
```

```html
<script>
    (function() {
        var a = 1;
        var obj = {
            a: 10,
            f: function() {
                a *= 2;
            }
        }
        obj.f()
        alert(obj.a + a);
    })()
</script>
```

```html
<script>
    (function() {
        var a = 1;
        var obj = {
            a: 10,
            f: function() {
                this.a *= 2;
                console.log(this.a)
            }
        }
        obj.f()
    })()
</script>
```

```html
<script>
    var name = "window";
    var Wangcai = {
        name: "Wangcai",
        show: function() {
            console.log(this.name);
        },
        f: function() {
            var fun = this.show;
            fun(); // 独立函数调用
        }
    }
    Wangcai.f();
</script>
```

```html
<script>
    var fullname = "language";
    var obj = {
        fullname: "javascript",
        props: {
            getFullName: function() {
                // this是obj.props   name是und
                return this.name;
            }
        }
    }
    console.log(obj.props.getFullName());
</script>
```

```html
<script>
    var fullname = "language";
    var obj = {
        fullname: "javascript",
        props: {
            fullname: "hello",
            getFullName: function() {
                return this.fullname;
            }
        }
    }
    console.log(obj.props.getFullName());
</script>
```

```html
<script>
    var fullname = "language";
    var obj = {
        fullname: "javascript",
        props: {
            fullname: "hello",
            getFullName: function() {
                // window 
                return this.fullname;
            }
        }
    }
    let qq = obj.props.getFullName;
    console.log(qq()); // 独立函数调用
</script>
```

```html
<script>
    let obj = {
        fn: (function() {
            console.log(this); // window
            return function() {
                console.log(this); //  obj
            }
        })()
    }
    obj.fn();
</script>
```

```html
<script>
    let obj = {
        fn: (function() {
            console.log(this)
            return function() {
                console.log(this)
            }
        })()
    }
    let qq = obj.fn;
    qq(); // 独立函数调用 
</script>
```

## 23. 创建对象的两种方式

**如何创建一个对象呢？**
* 早期使用创建对象的方式最多的是使用Object类，并且使用new关键字来创建一个对象：这是因为早期很多JavaScript开发者是从Java过来的，它们也更习惯于Java中通过new的方式创建一个对象
* 后来很多开发者为了方便起见，都是直接通过字面量的形式来创建对象，这种形式看起来更加的简洁，并且对象和属性之间的内聚性也更强，所以这种方式后来就流行了起来

* 代码如下：

```html
<script>
    // 创建方式一：new Object创建
    // Object 类  构造器  函数  函数也是类
    // 函数有多种角色：1）普通函数  2）方法   3）对象   4）类
    // 对象是属性的无序集合  操作集合  CRUD
    let obj = new Object();
    obj.name = "wc";
    obj.age = 18;
    obj.height = 1.88;
    obj.running = function() {
        console.log("running...");
    }
    console.log(obj.name);
    console.log(obj.age);
    obj.running();

    // 创建方式二：通常字面量的形式
    let obj2 = {
        name: "xq",
        age: 20,
        eat: function() {
            console.log("eat...");
        }
    }
    console.log(obj2.name);
    obj2.eat();
</script>
```

* JS中内置的类，如下：

```html
<script>
    // Number是类，也叫构造器
    // 通过new运算符，得到一个对象
    // num1 百分之百是对象   var a = 110; a不是对象 a是number基本数据类型
    // 引用数据类型存储在堆区  num1中存储了地址  指向那个堆
    let num1 = new Number(110);
    console.log(num1);
    console.dir(num1); // dir是用来打印对象
</script>
```

```html
<script>
    // String是类 也叫构造器  构造函数
    // let str1 = "hello"; // str1不是对象
    // str1.toUppercase();  str1会包装成对象
    let str = new String("hello");
    console.log(str);
</script>
```

```html
<script>
    // let f = false; f不是对象
    let b = new Boolean(true);
    console.log(b);
</script>
```

```html
<script>
    let obj = new Object();
    obj.name = "wc";
    console.dir(obj);
</script>
```

```html
<script>
    let arr = new Array("wc", "xq");
    console.dir(arr);
</script>
```

* 补充一个运算符：instanceof  判断一个对象是否属于一个类，如下：

```html
<script>
    let obj = new Object();
    obj.name = "wc";

    // 判断obj是否是Object的对象
    console.log(obj instanceof Object); // true
    console.log(obj instanceof Number); // false
</script>
```

## 24. 一切都是对象 

**一切皆对象：**
你需要证明，你在JS中的见到的所有的数据都是对象，这样，你才能说一切皆对象。

**要证明，你见的所有数据都是对象：**

```text
- 所有的html元素都是对象
- 数组也是对象
- 函数也是对象
- 基本数据类型也可以是对象
- window也是对象  GO
- consolo也是对象
- {} 也是对象
- ...
```

* 代码如下：

```html
<ul>
    <li>html</li>
    <li>css</li>
    <li>js</li>
</ul>
<script>
    // document.getElementsByTagName("li") 得到上面的三个li
    // 得到的是一个伪数组   伪数组本质是对象
    // 真数组：["wc","xq"]  
    // 真对象：{name:"wc"}  
    // 伪数组：{0:"wc"}  {0:li,1:li,2:li}
    let lis = document.getElementsByTagName("li")
    console.log(lis);
    console.dir(lis);
    console.log("----------");
    console.log(lis[0]);
    console.log(lis[0] instanceof HTMLLIElement);
    console.dir(lis[0]);
</script>
```

```html
<script>
    // 数组是对象
    let arr = ["wc", "xq"];
    console.dir(arr);
    arr.push("z3")
    console.log(arr instanceof Array);
</script>
```

```html
<script>
    function gn() {
        console.log("gn...");
    }
    gn.a = 1;
    gn.b = 2;
    gn.c = 3;
    console.dir(gn);
    gn.call(123)
    console.log(gn instanceof Function);
</script>
```

```html
<script>
    let obj = {
        name: "wc"
    }
    console.log(obj.name);
    console.log(obj instanceof Object);
</script>
```

```html
<script>
    let num = 110; // num现在不是对象
    console.log(num.toFixed(2)); // num在此处就包装了对象

    let str = "hello";
    console.log(str.toUpperCase());
</script>
```

```html
<script>
    window.alert("hello")
    window.setTimeout(() => {
        console.log("定时器~");
    }, 1000)
    // console也是对象  log是这个对象中的方法
    console.log("js");
    // document也是对象  getElementById是方法
    document.getElementById("box")
</script>
```

## 25. 对象是属性的无序集合

**对象是属性的无序集合：**
* 操作集合中的属性，说到操作，就是指"增删改查"。
* 基本操作代码如下：

```html
<script>
    let obj = {
        name: "wc",
        age: 100,
        run: function() {
            console.log("run...");
        }
    }
    // . 属性访问运算符
    console.log(obj.name);
    console.log(obj.age);
    // [] 也可以访问对象中的属性
    console.log(obj['name']);
    console.log(obj['age']);

    // 有些情况只能使用[]  
    // 对象中的属性名存储在一个变量中
    let xxx = "name";
    console.log(obj.xxx);
    console.log(obj[xxx]);
</script>
```

```html
<script>
    // 对象中的键也可以是其它的数据类型
    // 了解 正常情况下，键都是字符串类型
    let obj = {
        123: "wc",
        true: 18,
        undefined: function() {
            console.log("xxxx");
        }
    }
    // console.log(obj.123); // 不行
    console.log(obj[123]);
    console.log(obj.true);
    console.log(obj[true]);
    obj.undefined();
    obj[undefined]();
</script>
```

```html
<script>
    let obj = {
        name: "wc",
        age: 18,
        jump: function() {
            console.log("jump...");
        }
    }
    // 访问一个对象上不存在的属性，得到的结果是und
    // 数组这个对象上有length，对象上没有
    console.log(obj.length); // undefined

    // 能不能使用for循环去遍历对象
    // for(let i=0; i<obj.length; i++){}  // 不能

    // 使用for in 可以遍历对象  key表示对象中的键
    // 想获取值  不能obj.key     obj[key]
    for (let key in obj) {
        console.log(obj[key]);
    }
</script>
```

* 数组也是对象，遍历数组的方案，如下：

```html
<script>
    let arr = ["wc", "xq", "z3"];

    // 遍历数组
    // 问下面的代码中有没有块级作用域，有的话，有几个？
    // 3个
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }

    // forEach
    arr.forEach(item => console.log(item))

    // for in
    for (let key in arr) {
        // key是索引
        console.log(arr[key]);
    }
</script>
```

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    obj.name = "wc666"; // 修改obj中的属性
    console.log(obj.name);
</script>
```

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    // delete是一个运算符
    delete obj.name;
    // 访问一个对象上不存在的属性，结果是und
    console.log(obj.name);
</script>
```

## 26. 对属性操作的控制

**前面我们对对象中的属性做了一些基本的操作，现在，学习如何精细化操作对象中的属性。在前面我们的属性都是直接定义在对象内部，或者直接添加到对象内部的：**
* 但是这样来做的时候我们就不能对这个属性进行一些限制：比如这个属性是否是可以通过delete删除的？这个属性是否在for-in遍历的时候被遍历出来呢？

**如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符。**
* 通过属性描述符可以精准的添加或修改对象的属性； 
* 属性描述符需要使用 Object.defineProperty 来对属性进行添加或者修改；
* Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象; 

**可接收三个参数：**
* obj要定义属性的对象；
* prop要定义或修改的属性的名称或 Symbol； 
* descriptor要定义或修改的属性描述符；

**返回值：**
* 被传递给函数的对象。

**属性描述符分类，属性描述符的类型有两种**
* 数据属性（Data Properties）描述符（Descriptor）
* 存取属性（Accessor访问器 Properties）描述符（Descriptor）

### 26.1 数据属性描述符

**数据数据描述符有如下四个特性：**
* [[Configurable]]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；
    - 和数据属性描述符是一致的
    - 当我们直接在一个对象上定义某个属性时，这个属性的[[Configurable]]为true；
    - 当我们通过属性描述符定义一个属性时，这个属性的[[Configurable]]默认为false；
* [[Enumerable]]：表示属性是否可以通过for-in或者Object.keys()返回该属性；
    - 和数据属性描述符是一致的；
    - 当我们直接在一个对象上定义某个属性时，这个属性的[[Enumerable]]为true； 
    - 当我们通过属性描述符定义一个属性时，这个属性的[[Enumerable]]默认为false；
* [[Writable]]：表示是否可以修改属性的值；
    - 当我们直接在一个对象上定义某个属性时，这个属性的[[Writable]]为true； 
    - 当我们通过属性描述符定义一个属性时，这个属性的[[Writable]]默认为false； 
* [[value]]：属性的value值，读取属性时会返回该值，修改属性时，会对其进行修改；
    - 默认情况下这个值是undefined；

* 代码如下：

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    // Object也是对象
    // 第三个参数是属性描述符，对height这个属性进行描述
    // 这样写，可以对height属性做精细化设置
    Object.defineProperty(obj, "height", {
        value: 1.88
    })
    console.log(obj.height);
</script>
```

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    // value 是给属性赋的值
    // configurable:配置属性是否可以删除
    Object.defineProperty(obj, "address", {
        value: "BJ",
        // configurable如果是false，表示此属性不能删除 
        configurable: false,
        // enumerable表示属性是否可以被枚举 false表示不能枚举
        enumerable: false,
        // writable表示是否可以给属性重新赋值
        writable: false
    })
    console.log(obj.address);
    delete obj.address
    console.log(obj.address);
    for (let key in obj) {
        console.log(obj[key]);
    }
    obj.address = "SH";
    console.log("----", obj.address);
</script>
```

### 26.2 存取属性描述符

**数据数据描述符有如下四个特性**
* [[Configurable]]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符；
    - 和数据属性描述符是一致的；
    - 当我们直接在一个对象上定义某个属性时，这个属性的[[Configurable]]为true； 
    - 当我们通过属性描述符定义一个属性时，这个属性的[[Configurable]]默认为false；
* [[Enumerable]]：表示属性是否可以通过for-in或者Object.keys()返回该属性；
    - 和数据属性描述符是一致的；
    - 当我们直接在一个对象上定义某个属性时，这个属性的[[Enumerable]]为true； 
    - 当我们通过属性描述符定义一个属性时，这个属性的[[Enumerable]]默认为false；
* [[get]]：获取属性时会执行的函数。默认为undefined
* [[set]]：设置属性时会执行的函数。默认为undefined

* 代码如下：

```html
<script>
    let obj = {
        name: "wc",
        age: 18,
        // 行业潜规则：如果属性以_打头，表示私有属性
        _address: "bj"
    }
    // 
    Object.defineProperty(obj, "address", {
        enumerable: true, // 可以枚举
        configurable: true, // 可以删除
        get: function() { // 获取器
            // console.log("get...");
            return this._address; // this表示obj
        },
        // 当给address设置新的值时会走设置器
        set: function(value) { // 设置器  value就是设置的新值
            // console.log("set...");
            this._address = value;
        }
    })
    // 当obj.address时，它会自动调用获取器
    console.log(obj.address);
    obj.address = "sh";
    console.log(obj.address);
</script>
```

### 26.3 同时定义多个属性

* Object.defineProperties() 方法直接在一个对象上定义 多个 新的属性或修改现有属性，并且返回该对象。

```html
<script>
    let obj = {
        _age: 18,
    }
    Object.defineProperties(obj, {
        name: {
            value: "wc",
            configurable: true,
            enumerable: true,
            writable: true
        },
        age: {
            configurable: true,
            enumerable: true,
            get: function() {
                return this._age;
            },
            set: function(value) {
                this._age = value;
            }
        }
    })
    console.log(obj.name);
    console.log(obj.age);
    obj.age = 20;
    console.log(obj.age);
</script>
```

```html
<script>
    let obj = {
        _age: 18,
        // 在一个对象中，就可以直接写获取器和设置器
        get age() { // 获取器
            return this._age;
        },
        set age(value) { // 设置器
            this._age = value;
        }
    }
    // 当obj.age时，会自动调用获取器
    console.log(obj.age);
    obj.age = 20;
    console.log(obj.age);
</script>
```

### 26.4 获取属性描述符

**获取对象的属性描述符：**
* getOwnPropertyDescriptor
* getOwnPropertyDescriptors

```html
<script>
    let obj = {
        _age: 18, // 不想让别人访问
    }
    Object.defineProperties(obj, {
        name: {
            value: "wc",
            configurable: true,
            enumerable: true,
            writable: true
        },
        age: {
            configurable: true,
            enumerable: true,
            get: function() {
                return this._age;
            },
            set: function(value) {
                this._age = value;
            }
        }
    })
    // 获取name属性的描述符
    console.log(Object.getOwnPropertyDescriptor(obj, "name"));
    // 获取对象的所有属性的描述符
    console.log(Object.getOwnPropertyDescriptors(obj));
</script>
```

## 27. 字面量形式创建

**现在要创建多个对象，有多个人，每个人都有自己的信息，此时，如何创建对象比较好？**

* 字面量形式创建代码如下

```html
<script>
    let wc = {
        name: "wangcai",
        age: 11,
        height: 140,
        address: "bj",
        eating: function() {
            console.log("eating...");
        },
        runing: function() {
            console.log("runing...");
        }
    }
    let xq = {
        name: "xiaoqiang",
        age: 12,
        height: 150,
        address: "sh",
        eating: function() {
            console.log("eating...");
        },
        coding: function() {
            console.log("coding...");
        }
    }
    let z3 = {
        name: "zhangsan",
        age: 128,
        height: 180,
        address: "gz",
        playing: function() {
            console.log("playing...");
        },
        coding: function() {
            console.log("coding...");
        }
    };
</script>
```

**缺点：需要写大量的代码，并且多个代码都是重复的。**

## 28. 工厂函数创建对象

* 使用工厂模式去创建对象，这是一种设计模式，这个工厂的主要作用主是产生我们需要的对象，代码如下：
****

```html
<script>
    // 工厂函数  目的：产生对象
    function createPerson(name, age, height, address) {
        let p = {};
        p.name = name;
        p.age = age;
        p.height = height;
        p.address = address;
        p.running = function() {
            console.log(this.name + "在跑步~");
        }
        return p;
    }

    let wc = createPerson("wangcai", 13, 160, "bj");
    wc.running();
    let xq = createPerson("xiaoqiang", 14, 170, "gz");
    xq.running();
    let zs = createPerson("zhangsan", 18, 180, "sz");
    zs.running();

    console.log(wc instanceof Object);
    console.log(xq instanceof Object);
    console.log(zs instanceof Object);
</script>
```

对象和实例是同一个意思。一个对象是属于某个类的实例。

**缺点：获取不到对象最真实的类型**

## 29. 使用构造器创建对象

* 工厂函数创建对象不足：在打印出它的类型时，都是Object。我们想让每一个对象都有自己特有的类型，此时，就需要使用构造器来创建对象了。

* 构造器，是JS中特有的，类似一个类，也叫构造函数，英文叫constructor，需要通过new一个构造器，就可以产生一个对象。

**new做了什么：**
1. 在构造器内部创建一个新的对象
2. 这个对象内部的prototype属性会被赋值为该构造函数的prototype属性;
3. 让构造器中的this指向这个对象
4. 执行构造器中的代码
5. 如果构造器没有返回对象，则返回上面的创建出来的对象

```html
<script>
    // 构造器，也就是类，首字母需要大写
    function Fn() {
        console.log("Fn...");
    }

    // Fn(); // 普通函数调用

    // ()可加可不加
    let wc = new Fn(); // obj对应的类是Fn
    console.log(wc);
</script>
```

```html
<script>
    // 构造器
    function Person(name, age, height, address) {
        this.name = name;
        this.age = age;
        this.height = height;
        this.address = address;
        this.runing = function() {
            console.log(this.name + " running...");
        }
    }
    let wc = new Person("wangcai", 19, 180, "bj");
    wc.runing();
    let xq = new Person("xiaoqiang", 18, 160, "gz");
    xq.runing();
    let zs = new Person("zhangsan", 15, 150, "sz");
    zs.runing();
</script>
```

**缺点：可能造成内存空间浪费。**

**上面创建对象的方案都有不足之处，有没有更加优雅的方案？** <br/>
答：有  

## 30. 公有属性和私有属性

**公有属性和私有属性**

* 一切都是对象
* 对象是属性的无序集合
* 每一个对象上都有一个叫_ _ proto _ _这样的属性，是一个属性名
* _ _ proto _ _对应的属性值是一个对象，这个对象叫隐式原型对象

* 代码如下：

```html
<script>
    // 对象是属性的无序集合
    // 属性分两类：1）私有属性  2）公有属性
    // 私有属性指的是对象自己的属性
    let obj = {
        name: "wc", // 私有属性
        age: 18 // 私有属性
    }
    console.dir(obj);
</script>
```

```html
<script>
    // 数组也是对象
    // 对象是属性的无序集合
    // 每一个对象上都有一个叫__proto__的属性
    // __proto__属性对应的值是一个对象
    let arr = ["wc", "xq"];
    console.dir(arr);
</script>
```

## 31. 每一个对象都有一个__proto__属性

**2，每一个对象都有一个__proto__属性**

```html
<script>
    // 每一个对象都有一个叫__proto__的属性，它的值是一个对象
    // 这个对象叫隐式原形对象
    let obj = {
        name: "wc", // 私有属性
        age: 18 // 私有属性
    }
    console.dir(obj);
    // 现在去obj中找hasOwnProperty  查找顺序如下：
    // 1）先在自己的私有属性中找  如果找到了 就使用 如果找不到 
    // 2）这会沿着__proto__去它的隐式原形对象中找  如果找到了  就使用  如果找不到
    // 3）还会沿着__proto__去它的隐式原形对象的隐式原形对象中
    console.log(obj.hasOwnProperty("name")); // hasOwnProperty 判断一个属性是否属于自己的私有属性
    console.log(obj.hasOwnProperty("hasOwnProperty"));
</script>
```

* 看一个题：

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    console.log(obj.__proto__); // 得到obj的隐式原型对象
</script>
```

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    console.log(obj.__proto__.hasOwnProperty("hasOwnProperty")); // true
</script>
```

```html
<script>
    let arr = ["wc", "xq"];
    console.dir(arr)
    // arr要找push  
    //  1）先去自己私有属性中找push  找不到
    //  2）沿着__proto__去隐式原型对象中
    arr.push("z3")
</script>
```

```html
<script>
    let arr = ["wc", "xq"];
    console.dir(arr)
    // arr要找valueOf
    //  1）先去自己私有属性中找valueOf  找不到
    //  2）沿着__proto__去隐式原型对象中  找不到
    //  3）再沿着__proto__去arr的隐藏原型对象的隐式原型对象中找
    arr.valueOf("z3")
</script>
```

```html
<script>
    let arr = ["wc", "xq"];
    console.dir(arr)
    // arr要找abc
    //  1）先去自己私有属性中找valueOf  找不到
    //  2）沿着__proto__去隐式原型对象中  找不到
    //  3）再沿着__proto__去arr的隐藏原型对象的隐式原型对象中找
    //  4）再沿着__proto__去arr的隐式原型对象的隐式原型对象的隐式原型对象中找
    //  5）....  直到找到null  如果还找不到，就报错
    arr.abc();
</script>
```

* 补充一个运算符：in 

```html
<script>
    let arr = ["wc"];
    // 判断push是否是arr对象的私有属性
    console.log(arr.hasOwnProperty("push"));

    // in是一个运算符  判断一个属性是否是某个对象的属性
    // 这个属性不管是私有的还公有的
    console.log("push" in arr);
</script>
```

## 32. 每一个函数都有一个prototype属性

* 作用域链：在EC中查找数据的机制。
* 原型链：在对象中查找属性的机制。

* 代码如下：

```html
<script>
    // 每一个函数都有一个prototye属性名
    // 这个属性名对应的值是一个对象，叫原型对象
    // 不要忘了：每一个对象都有一个叫__proto__属性
    // 函数是对象吗？是  函数也有一个__proto__属性
    function fn() {
        console.log("fn..");
    }
    console.dir(fn)

    // Array 叫构造器  构造器也是函数   构造器也是类
    // 函数在JS中是一等公民，函数有多种角色
    // new Array(); 
    console.dir(Array);
</script>
```

* 一个函数（构造器）的prototype属性指向的对象 和 通过这个函数（构造器）创建出来的对象的__proto__所指向的是同一个对象，只不过，__proto__指向的一般叫隐式原型对象，prototype指向的，一般叫原型对象。题目如下：

```html
<script>
    let arr1 = new Array("wc", "xq")
    let arr2 = new Array("z3", "L4")
    console.dir(arr1)
    console.log(Array.prototype == arr1.__proto__); // true
    console.log(Array.prototype == arr2.__proto__); // true

    console.log(arr1.__proto__.__proto__ == Object.prototype); // true
    console.log(arr1.__proto__.__proto__.__proto__); // null
</script>
```

## 33. constructor

**每一个原型对象上都有一个叫constructor属性，指向它对应的构造器**

```html
<script>
    let arr = new Array("wc", "xq");
    // constructor指向Array
    console.log(arr.__proto__.constructor);

    console.log(arr.__proto__.constructor == Array);
</script>
```

```html
<script>
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    let p = new Person("wc", 18)
    console.log(p.__proto__.constructor == Person);
</script>
```

```html
<script>
    let num = new Number(110)
    console.log(num.__proto__.constructor == Number);
</script>
```

## 34. 原型链的题

**需要记住的几个概念：**
* 一切都是对象
* 函数有多种角色
* 对象是属性的无序集合
* 每一个对象上都有一个__proto__属性
* 每一个函数上都有一个prototype属性
* 原型链研究的是对象属性的查找机制
* 作用链研究的是EC中数据的查找机制
* 闭包一个没有被销毁的执行上下文（栈空间）
* new做了什么，如下： <br />
    (1)在构造器内部创建一个新的对象 <br />
    (2)这个对象内部的prototype属性会被赋值为该构造函数的prototype属性;<br />
    (3)让构造器中的this指向这个对象<br />
    (4)执行构造器中的代码<br />
    (5)如果构造器没有返回对象，则返回上面的创建出来的对象<br />

```html
<script>
    function Fn() {
        this.x = 10;
        this.y = 20;
        this.getX = function() {
            console.log(this.x)
        }
    }
    Fn.prototype.getX = function() {
        console.log(this.x)
    }
    Fn.prototype.getY = function() {
        console.log(this.y)
    }
    let f1 = new Fn();
    f1.getX();
    f1.getY();
</script>
```

```html
<script>
    function Fn(num) {
        this.x = this.y = num;
    }
    Fn.prototype = {
        x: 20,
        sum: function() {
            console.log(this.x + this.y)
        }
    }
    Fn.prototype.constructor = Fn;
    let f1 = new Fn(10)
    console.log(f1.sum === Fn.prototype.sum)
    f1.sum();
    Fn.prototype.sum();
    console.log(f1.constructor)
</script>
```

```html
<script>
    function Fn() {
        let a = 1;
        this.a = a;
    }
    Fn.prototype.say = function() {
        this.a = 2;
    }
    Fn.prototype = new Fn();
    let f1 = new Fn();
    Fn.prototype.b = function() {
        this.a = 3;
    }
    console.log(f1.a)
    f1.say();
    console.log(f1.a)
    f1.b();
    console.log(f1.a)
</script>
```

```html
<script>
    function Fn() {
        this.x = 10;
        this.y = 20;
    }
    Fn.n = 1000;
    Fn.say = function() {
        console.log("hello")
    }
    Fn.prototype.sum = function() {
        return this.x + this.y;
    }
    let f1 = new Fn();
    f1.sum();
    console.log(f1.sum());
    console.log(Fn.prototype == Fn.__proto__);
    Fn.sum();
</script>
```

```html
<script>
    function C1(name) {
        if (name) {
            this.name = name;
        }
    }

    function C2(name) {
        this.name = name;
    }

    function C3(name) {
        this.name = name || "Hello";
    }
    C1.prototype.name = "Tom"
    C2.prototype.name = "Tom"
    C3.prototype.name = "Tom"
    console.log((new C1().name) + (new C2().name) + (new C3().name))
</script>
```

## 35. 再次聊一下创建对象的几种方式

**1）普通方式（new Object 或 字面量）**

```html
<script>
    let coder = new Object();
    coder.color = "white"
    coder.start = function() {
        console.log("开始打代码~");
    }
</script>
<!-- 不足：不方便批量地创建对象 -->
```

**2）工厂模式创建对象**

```html
<script>
    function createCoder() {
        let coder = new Object();
        coder.color = "white"
        coder.start = function() {
            console.log("开始打代码~");
        }
        return coder;
    }

    let coder1 = createCoder();
    let coder2 = createCoder();
    let coder3 = createCoder();
</script>
<!-- 不足：每个对象都是Object的实例。 -->
```

**3）构造器（构造函数）创建对象**

```html
<script>
    function Coder(color) {
        this.color = color;
        this.start = function() {
            console.log("开始打代码~");
        }
    }
    let redCoder = new Coder("red");
    let blueCoder = new Coder("blue");
</script>
<!-- 不足：造成内存空间浪费 -->
```

**4）构造器+原型创建对象**

* 把公有属性放到原型上就OK了，代码如下：

```html
<script>
    function Coder(color) {
        this.color = color; // 每一个程序员的私有属性
    }

    Coder.prototype.start = function() {
        console.log("开始打代码~");
    }

    let redCoder = new Coder("red");
    let blueCoder = new Coder("blue");
</script>
```

## 36. 静态属性

**静态属性是绑定在类的属性，类是构造器，构造器是函数，函数也是对象。**

* 代码如下：

```html
<script>
    function Person(name) {
        this.name = name; // 对象自己的私有属性

        // Person叫构造器 类 构造函数
        // 函数有多种角色  对象
        Person.total = 110; // total是们于Person这个类的
        // 位于类上的属性，叫静态属性
    }
    let wc = new Person("wc")
    let xq = new Person("xq")
    console.log(wc.name);
    console.log(xq.name);

    // 访问静态属性必须通过类名
    console.log(Person.total);
</script>
```

## 37. 不使用继承

```js
// 分析需求:
// 人类, 属性: name, age   会说话
// 学生, 属性: name, age, className  会说话
// 工人, 属性: name, age, companyName  会说话

// 为什么要有继承:
// 继承: 将多个构造函数, 建立关联, 实现方便管理 和 方便复用

// 角度
// 1. 方法的继承
// 2. 实例化属性过程的复用

function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype.sayHi = function() {
    console.log('会说话')
}

function Student(name, age, className) {
    this.name = name
    this.age = age
    this.className = className
}
Student.prototype.sayHi = function() {
    console.log('会说话')
}

function Worker(name, age, companyName) {
    this.name = name
    this.age = age
    this.companyName
}
Worker.prototype.sayHi = function() {
    console.log('会说话')
}
```

## 38. 继承之原型继承

**原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!** 

```js
// 目标: 原型继承 => 继承方法
// 原型继承: 通过改造原型链实现继承, 利用原型链的特征实现继承，所谓的原型继承，就是在改造原型链

// 1. 定义Person构造函数
function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype.say = function() {
    console.log('人类会说话')
}

// 2. 定义Student构造函数
function Student(name, age, className) {
    this.name = name
    this.age = age
    this.className = className
}
// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法
// 语法: 子构造函数.prototype = new 父构造函数()
Student.prototype = new Person()
Student.prototype.constructor = Student;

Student.prototype.study = function() {
    console.log('学生在学习')
}

let stu = new Student('张三', 18, '80期')
stu.say()
console.log(stu)
```

**原型链继承的缺点：**
* 如果父中的数据类型是引用数据类型，子对象修改了，另一个子对象也会受影响
* 创建Child对象是，不能传参

## 39. 继承之组合继承

```js
// 组合继承: 两种技术的组合, 原型链技术, 借用构造函数(call)结合, 发挥二者之长, 实现继承的方式
// 1. 原型链技术: 改造原型链, 实现继承方法
//    Student.prototype = new Person()
// 2. 实例属性的构造过程没有得到复用, 可以用借用构造函数的方式, 实现复用
//    Person.call(this, name, age)

function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype.sayHi = function() {
    console.log('会说话')
}

function Student(name, age, className) {
    // 不仅要执行Person构造函数, 且要让执行构造函数时的this指向创建出来的实例stu
    // call
    // 1. 调用函数
    // 2. 改变函数执行时的this指向
    Person.call(this, name, age)
    this.className = className
}
Student.prototype = new Person()

const stu = new Student('zs', 7, '一年级一班')
stu.sayHi()
console.log(stu)

// 方法通过 原型继承
// 属性通过 父构造函数的.call(this, name, age)
```

## 40. 继承之寄生组合继承

```js
function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype.sayHi = function() {
    console.log('会说话')
}

function Student(name, age, className) {
    // 不仅要执行Person构造函数, 且要让执行构造函数时的this指向创建出来的实例stu
    // call
    // 1. 调用函数
    // 2. 改变函数执行时的this指向
    Person.call(this, name, age)
    this.className = className
}
// 构造函数没有必要执行, 我们只需要的是原型链
Student.prototype = Object.create(Person.prototype)

const stu = new Student('zs', 7, '一年级一班')
stu.sayHi()
console.log(stu)

// 总结:
// Object.create() 以参数的对象, 作为新建对象的__proto__属性的值, 返回新建的对象
```

## 41 继承之ES6中的继承

```js
// function Person (name, age) {
//   this.name = name
//   this.age = age
// }
// Person.prototype.sayHi = function() {}
// Person.prototype.jump = function() {}

// 人类
class Person {
    // 类似于之前的构造函数
    constructor(name, age) {
        this.name = name
        this.age = age
    }
    // 底层 => 这两个方法, 就是添加到 Person.prototype 上
    sayHi() {
        console.log('你好哇')
    }
    jump() {
        console.log('会跳')
    }
}
const p = new Person('zs', 18)
console.log(p)

// 继承关键字 => extends
// 老师类
class Teacher extends Person {
    // 如果没有提供构造函数, 在继承时, 会默认自动借调父构造函数
    constructor(name, age, lesson) {
        // 你写的构造函数中, 没有借调父构造函数
        super(name, age) // 触发调用父构造函数, 进行实例的属性初始化
        this.lesson = lesson
    }
    teach() {
        console.log('会教书')
    }
}
const teacher = new Teacher('zs', 18, '教体育')
console.log(teacher)
```

## 42. with

**作用域链：** 一种数据的查找机制。

with语句，作用：扩展一个语句的作用域链。代码如下：

```html
<script>
    let address = "bj";
    let obj = {
        uname: "wc",
        uage: 18
    }
    with(obj) {
        // 找uname    之前：去ECG中找uname  没有
        // 打uage     之前：去ECG中找uage  没有
        // with 扩展了作用域链   现在：找数据，去obj中找
        // 现在：如果obj中没有，还会去ECG中找
        console.log(uname);
        console.log(uage);
        console.log(address);
    }
</script>
```

```html
<script>
    let msg = "xixi";
    let obj = {
        naem: "wc",
        msg: "haha"
    }

    function foo() {
        let msg = "hehe"

        function bar() {
            let msg = "heihei"
            with(obj) {
                // let msg = "lala"
                console.log(msg);
            }
        }
        bar()
    }
    foo()
</script>
```

在开发中，不要使用with，with语句破坏了作用域链，可能会出现一些错误，也有兼容性问题。

## 43. eval

eval是一个特殊的函数，作用：可以把一片字符串，当成JS代码运行。

```html
<script>
    let age = 110;
    var jsStr = " var msg = 'haha'; console.log(msg); console.log(age); ";

    // 可以把上面的字符串当成JS代码运行
    // eval执行代码，并不是沙箱环境，受外界的环境影响
    // 在node中，一个运行JS代码的沙箱环境
    eval(jsStr);
    console.log(msg);
</script>
```

**在开发中，不要使用eval，缺点：**
1. 可读性非常差
2. 本质是字符串，在执行过程中，可能会被恶意篡改，有被攻击的风险
3. eval执行的代码并不会被JS引擎优化

## 44. 严格模式

JS刚设计出来时，非常灵活，有非常多的不足，在ES5中，提出了严格模式，默认情况下，代码执行时，并不是严格模式，要使用严格模式，需要开启严格模式。

**在哪开启：**
1. 在一个JS文件中开启   “use strict”  这个文件中写的代码都受严格模式的约束
2. 在一个函数中开启格式模式   function fn(){  “use strict”   xxx  }  其它代码不受约束

```js
"use strict"

// 1）不能使用没有加var的全局变量
name = "wc";
console.log(name);

function foo() {
    age = 18;
    console.log(age);
}
foo();
```

```js
// 2）形参不能重名
function fn(x, y, z, x) {
    console.log(x, y, z, x);
}
fn(1, 2, 3, 4)
```

```js
// 3）不能使用老的8进制数据的写法
let num1 = 0x123; // 16进制
let num2 = 0o10; // 8进制(新的8进制写法)
let num3 = 010; // 8进制(老的8进制写法)
console.log(num1);
console.log(num2);
console.log(num3);
```

```js
// 4）不能使用with语句
let obj = {
    msg: "hello"
}
with(obj) {
    console.log(msg);
}
```

```js
// 5）在严格模式下，JS串中定义的数据，外界不能使用
// 外界定义的数据，在JS串中还是可以使用
let age = 110;
let jsStr = " 'use strict'; var msg = 'haha'; console.log(age); ";

console.log(msg);
eval(jsStr);
```

```js
// 6）在非严格模式下，this是window  在严格模式下，不会默认绑定，this是und
setTimeout(() => {
    console.log(this);
}, 2000)

function fn() {
    console.log(this);
}

fn();
```

```html
<script>
    function fn() {
        // 在函数内部去开启严格模式
        "use strict";
        a = 110;
        console.log(a);
    }
    fn();
</script>
```

```html
<script>
    function gn() {
        a = 123;
        console.log(a);
    }

    function fn() {
        // fn内部是严格模式 但是gn内部不是严格模式
        "use strict";
        gn();
    }
    fn();
</script>
```

## 45. 柯里化

```html
<script>
    // 未柯里化的函数
    function add(x, y, z) {
        return x + y + z;
    }
    console.log(add(20, 10, 30));

    // 柯里化处理的函数
    function add2(x) {
        return function(y) {
            return function(z) {
                return x + y + z;
            }
        }
    }
    console.log(add2(10)(20)(30));
</script>
```

* 经过柯里化处理的函数，可以简写：

```html
<script>
    let add2 = x => y => z => x + y + z;
    console.log(add2(10)(20)(30));
</script>
```

JS中函数的柯里化，我的认为：<br/>
**只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数，这个过程，就是柯里化。**

**函数式编程：**
* 让函数职责更加单一，在函数式编程，我们希望，一个函数处理问题尽可能单一，而不是将一大堆的处理过程交给一个函数来处理，所以，我们给函数传入的参数，应该非常灵活，可以先传入一部分参数，处理完后，再传其它参数。

```html
<script>
    // 没有经过柯里化处理
    function add(x, y, z) {
        x = x + 2;
        y = y * 2;
        z = z * z;
        //.... 
        return x + y + z;
    }
    console.log(add(1, 2, 3));

    // 把上面的函数进行柯化里处理
    function add2(x) {
        x = x + 2;
        return function(y) {
            y = y * 2;
            return function(z) {
                z = z * z;
                return x + y + z;
            }
        }
    }
    console.log(add2(1)(2)(3));
</script>
```

* 柯里化可以复用代码，如下：

```html
<script>
    function sum(m, n) {
        return m + n;
    }
    console.log(sum(10, 1));
    console.log(sum(10, 2));
    console.log(sum(10, 3));
    console.log(sum(10, 4));

    function sum2(count) {
        return function(num) {
            return count + num;
        }
    }
    let makeSum = sum2(10)
    console.log(makeSum(1));
    console.log(makeSum(2));
    console.log(makeSum(3));
    console.log(makeSum(4));
</script>
```

## 46. 组合函数

我们要完成一个功能，需要调用两个函数才能实现，之前，就是依次调用这两个函数。那么我们每一次要用这个功能，就需要调用两次函数，操作上有点重复，能不能把这个函数组合成一个函数呢？
* 答：可以的

可以对两个多个函数进行组合，组合后的函数，我们叫组合函数。

```html
<script>
    function double(num) {
        return num * 2;
    }

    function square(num) {
        return num ** 2;
    }
    // console.log(double(10));
    // console.log(square(10));

    // 需求：给一个数字，先乘以2，再平方
    let count = 12;
    let res = square(double(count))
    console.log(res);
</script>
```

## 47. 什么是JSON

**JSON: JavaScript Object Notation   JS对象描述符**

* 格式一：

```json
"hello json"
```

* 格式二：

```json
{
    "name": "wc",
    "age:": 19,
    "friend": {
        "name": "xq"
    },
    "hobbies":["zq","lq"]
}
```

* 格式三：

```json
[
    "abc",123,{"name:":"wc"}  
]
```

**JSON的语法要求：**
1. 支持的数据类型：数字，字符串，布尔值，null值，不能写函数
2. 对象的key必须使用双引号包起来
3. JSON中没有注释
4. 通过一些网站可以验证自己的JSON是否OK

**现在你需要对JSON的认识：**
1. JSON是服务器响应给客户端的数据格式   也可以把JSON数据给服务器  所以说  JSON是客户端与服务器之间通信的一种数据格式。是目前最最常用的数据格式。
2. JSON并不是JS对象，和JS对象的区别，你需要记住。

## 48. JSON的序列化和反序列化

**问：** 能不能把一个JS对象，存储到硬盘上？ <br/>
**答：** 可以存储  <br/>

```html
<script>
    // 当程序运行起来，对象是存储在内存中的
    // 程序运行结束或断电，内存上的数据就没了
    let obj = {
        name: "wc"
    }
    console.log(obj);

    // 能不能把obj对象也存储到硬盘（local storage）
    window.localStorage.setItem("obj", obj)

    // 你尝试把一个JS对象存储到local storage中，由于local storage中只能存储字符串，那么obj会调用toString方法，尝试转成字符串
</script>
```

* 此时我们需要把obj对象转成JSON串之后，再存储，这个过程，叫序列化。如下：

```html
<script>
    let obj = {
        name: "wc"
    }
    let objstr = JSON.stringify(obj); // 转成了JSON串
    console.log(objstr); // {"name":"wc"}  
    console.log(typeof objstr); // string JSON字符串
    window.localStorage.setItem("obj", objstr)
</script>
```

-反序列化：把JSON串还原成JS对象，代码如下：

```html
<script>
    let str = window.localStorage.getItem("obj")
    console.log(str);
    console.log(typeof str);
    let obj = JSON.parse(str);
    console.log(obj.name);
</script>
```

* 利用JSON可以实现深copy，如下：

```html
<script>
    let obj = {
        name: "wc"
    }
    // let newObj = obj; // 浅copy

    let objstr = JSON.stringify(obj)
    let newObj = JSON.parse(objstr);

    obj.name = "wc666";
    console.log(newObj.name);
</script>
```

## 49. 数据存储之LocalStorage

**数据可以存储在两个地方：**
* 内存
* 硬盘

**持久化数据：**就是把数据保存在硬盘。我们开发主要面对的是浏览器，浏览器中是否有一块区域可以持久化存储数据呢？
* 答：有的，Local Storage，Session Storage，Cookies

**LocalStorage是永久化数据存储方案，数据存储完毕，关闭浏览器，明天，后天.... 再打开浏览器，数据还是存在的。**

**对应的一个一些API，如下：**
* length 返回数据的数量
* setItem(key, value) 存储数据的   如果key一样，数据会发生覆盖
* getItem(key) 获取数据
* removeItem(key) 删除数据
* Clear() 清除local storage中的所有的数据

```html
<script>
    // 存储数据
    // window.localStorage.setItem("name","wc")
    // window.localStorage.setItem("age",18)

    // 获取数据
    // console.log(localStorage.getItem("name"));

    // 删除数据
    // localStorage.removeItem("age")

    // 清除数据
    localStorage.clear();
</script>
```

## 50. 数据存储之SessionStorage

* Session是会话的意思，打电话从开始到结束就可以称为一次会话，浏览器一个网站，从开始浏览到关闭浏览器，这个也可以称为一次会话。

* Setssion Storage中也可以存储数据，它的数据的有效性是在一次会话，当会话结束，数据会自动被销毁，或你跳到一个新的网页，sessionStorage中的数据也会被销毁。

* 对应的API，和localStorage中的API是一样的。

****

```html
<script>
    sessionStorage.setItem("name:", "xq");
    sessionStorage.setItem("age", 18)
</script>
```

* 请你封装一个工具类，这个类，可以对localStorage和sessionStorage进行操作，如下：

```js
// Cache是缓存的意思
// Cache还需要区域是永久性存储还是会话级存储
class Cache {
    constructor(isLocal = true) {
        this.storage = isLocal ? localStorage : sessionStorage;
    }
    setItem(key, value) {
        if (value) {
            this.storage.setItem(key, JSON.stringify(value))
        }
    }
    getItem(key) {
        let value = this.storage.getItem(key)
        if (value) {
            value = JSON.parse(value);
            return value;
        }
    }
    removeItem(key) {
        this.storage.removeItem(key)
    }
    clear() {
        this.storage.clear();
    }
    length() {
        return this.storage.length;
    }
}
// 如果不传参或传一个true 表示永久存储
let localCache = new Cache();

// 如果传入false，表示会话级存储
let sessionCache = new Cache(false);
```

使用之，如下：

```html
<script>
    // 由于上面的代码段中定义了localCache和sessionCache
    // 在下面的代码段中就可以使用localCache和sessionCache
    localCache.setItem("address", "bj")
    console.log(localCache.getItem("address"));
</script>
```

## 51. JS中的常见错误

**语法错误**
* 这类错误最好解决。只要有语法错误，所有代码都不会执行。

```html
<script>
    var a = 1;

    function fn {}
</script>
```

**引用错误**
* 错误之前的代码还会执行
* 错误之后的代码不会执行
* 通常情况下，我们使用了一个没有声明的数据，就会报这样的错误

```html
<script>
    console.log(1);
    console.log(2);
    console.log(a);
    var a = 3;
    console.log(b);
    console.log(4);
    console.log(5);
</script>
```

**范围错误**

```html
<script>
    // let arr = new Array(2); // 表示定义一个数组，里面可以放2个数据
    let arr = new Array(-2);
    console.log(arr);
</script>
```

## 52. 自己抛出错误和捕获错误

由于JS是弱类型语言，我们可以给函数传递各种各样的数据，如果内部没有进行校验，会给项目带来很多隐藏bug，这也就是现在TS为什么这火，因为TS中有很多类型校验。我们自己在JS中进行校验，如果参数不合法，怎么办？

**解决：**
1. return “你的参数不合法”  不好   一般不会使用return去提示调用者
2. 使用throw语句

* 代码如下：

```html
<script>
    function sum(num1, num2) {
        if (typeof num1 !== "number" || typeof num2 !== "number") {
            // return "你的参数不合适，请传入数字"
            // 和return一样，你是把错误扔到调用处
            throw "你的参数不合适，请传入数字"
        }
        return num1 + num2;
    }
    // 错误后面的代码不会执行了
    console.log(sum(10, null));
    console.log("我是后面的代码");
</script>
```

* 在JS中，错误也有一个类，叫Error，也应对了很多了类，如RangeError，SyntaxError，TypeError.....  我们就可以new 一个错误对象抛出去，如下：

```html
<script>
    function sum(num1, num2) {
        if (typeof num1 !== "number" || typeof num2 !== "number") {
            throw new Error("你的参数不合适，请传入数字")
            // throw "你的参数不合适，请传入数字"
        }
        return num1 + num2;
    }
    // 错误后面的代码不会执行了
    console.log(sum(10, null));

    console.log("我是后面的代码");
</script>
```

* 通常上面的演示，发现，如果代码出错了，下面的代码就不会执行了，如何解决这个错误，让下面的代码还要执行，要去try catch这个错误，代码如下：

```html
<script>
    function sum(num1, num2) {
        if (typeof num1 !== "number" || typeof num2 !== "number") {
            throw new Error("你的参数不合适，请传入数字")
        }
        return num1 + num2;
    }
    try {
        // try中放可能出错的代码
        sum(10, null)
    } catch (err) {
        // catch中就可以捕获，程序员或JS引擎抛出的错误
        console.log(err);
    }
    console.log("我是后面的代码");
</script>
```

## 53. let 关键字

### 53.1 基本用法

**ES6中新增了let命令，用于变量的声明，基本的用法和var类似。例如：**

```html
<script>
    // 使用var使用声明变量
    var userName = "wc";
    console.log("userName=", userName);
    // 使用let声明变量
    let userAge = 18;
    console.log("userAge=", userAge);
</script>
```

* 通过以上的代码，我们发现var和let的基本使用是类似的，但是两者还是有本质的区别，最大的区别就是：
* 使用let所声明的变量只在let命令所在的代码块中有效。

### 53.2 let与var区别

下面我们通过一个for循环的案例来演示一下let和var的区别, 如下所示：

```html
<script>
    for (var i = 1; i <= 10; i++) {
        console.log("i=", i)
    }
    console.log(" last=", i)
</script>
```

* 通过以上的代码，我们知道在循环体中i的值输出的是1--10，最后i的值为11.

* 但是如果将var换成let会出现什么问题呢？代码如下：

```javascript
for (let i = 1; i <= 10; i++) {
    console.log("i=", i)
}
console.log("last=", i)
```

* 在循环体中输出的i的值还是1--10, 但是循环体外部打印i的值时出现了错误，错误如下：

![](./images/let.png)

**出错的原因是：通过let声明的变量只在其对应的代码块中起作用，所谓的代码块我们可以理解成就是循环中的这一对大括号。**
* 当然在这里我们通过这个提示信息，可以发现在ES6中默认是启动了严格模式的，严格模式的特征就是：变量未声明不能使用，否则报的错误就是变量未定义。
* 那么在ES5中怎样开启严格模式呢？我们可以在代码的最开始加上：**“use strict”**
* 刚才我们说到，let声明的变量只在代码块中起作用，其实就是说明了通过let声明的变量仅在**块级作用域**内有效

### 53.3 块级作用域

**什么是块级作用域？**
* 有一段代码是用大括号包裹起来的，那么大括号里面就是一个块级作用域

也就是说，在我们写的如下的案例中：

```javascript
for (let i = 1; i <= 10; i++) {
    console.log("i=", i)
}
console.log("last=", i)
// i 这个变量的作用域只在这一对大括号内有效，超出这一对大括号就无效了。
```

**为什么需要块级作用域？**
* ES5 只有全局作用域和函数作用域，没有块级作用域，这样就会带来一些问题
* 第一：内层变量可能会覆盖外层变量
* 代码如下：

```javascript
var temp = new Date();

function show() {
    console.log("temp=", temp)
    if (false) {
        var temp = "hello world";
    }
}
show();
// 执行上面的代码，输出的结果为 *temp=undefined*  ，原因就是变量由于提升导致内层的temp变量覆盖了外层的temp变量
```

* 第二： 用来计数的循环变量成为了全局变量
* 关于这一点，在前面的循环案例中，已经能够看到。在这里，可以再看一下	

```html
<script>
    for (var i = 1; i <= 10; i++) {
        console.log("i=", i)
    }
    console.log("last=", i)

    // 在上面的代码中，变量i的作用只是用来控制循环，但是循环结束后，它并没有消失，而是成了全局的变量，这不是我们希望的，我们希望在循环结束后，该变量就要消失。
</script>
```

以上两点就是，在没有块级作用域的时候，带来的问题。

**下面使用let来改造前面的案例。**

```javascript
let temp = new Date();

function show() {
    console.log("temp=", temp)
    if (false) {
        let temp = "hello world";
    }

}
show();
// 通过上面的代码，可以知道let不像var那样会发生“变量提升”的现象。
```

**ES6块级作用域**

* let实际上为JavaScript新增了块级作用域，下面再看几个案例，通过这几个案例，巩固一下关于“块级作用域”这个知识点的理解，同时进一步体会块级作用域带来的好处

```html
<script>
    function test() {
        let num = 5;
        if (true) {
            let num = 10;
        }
        console.log(num)
    }
    test()
    // 上面的函数中有两个代码块，都声明了变量num,但是输出的结果是5.这表示外层的代码不受内层代码块的影响。如果使用var定义变量num,最后的输出的值就是10.
</script>
```

说一下，下面程序的输出结果是多少？

```javascript
if (true) {
    let b = 20;
    console.log(b)
    if (true) {
        let c = 30;
    }
    console.log(c);
}

// 输出的结果是：b的值是20，在输出c的时候，出现了错误。
// 导致的原因，两个if就是两个块级作用域，c这个变量在第二个if中，也就是第二个块级作用域中，所以在外部块级作用域中无法获取到变量c.
// 块级作用域的出现，带来了一个好处以前获得广泛使用的立即执行匿名函数不再需要了。
```

下面首先定义了一个立即执行匿名函数：

```javascript
(function text() {
    var temp = 'hello world';
    console.log('temp=', temp);
})()

// 匿名函数的好处：通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的空间，该空间内的变量和方法，不会破坏污染全局的空间 。
```

但是以上的写法是比较麻烦的，有了“块级作用域”后就编的比较简单了，代码如下：

```javascript
{
    let temp = 'hello world';
    console.log('temp=', temp);
}
// 通过以上的写法，也是创建了一个“私有”的空间，也就是创建了一个封闭的作用域。同样在该封闭的作用域中的变量和方法，不会破坏污染全局的空间。
// 但是以上写法比立即执行匿名函数简单很多。
```

现在问你一个问题，以下代码是否可以：

```javascript
let temp = '你好'; {
    let temp = 'hello world';
}

// 答案是可以的，因为这里有两个“块级作用域”，一个是外层，一个是内层，互不影响。
```

但是，现在修改成如下的写法：

```javascript
let temp = '你好'; {
    console.log('temp=', temp);
    let temp = 'hello world';
}

// 出错了，也是变量未定义的错误，造成错误的原因还是前面所讲解的let 不存在“变量提升”。
```

块级作用域还带来了另外一个好处，我们通过以下的案例来体会一下：

```javascript
// 该案例希望不同时间打印变量i的值。
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log('i=', i);
    }, 1000)
}

// 输出的都是 i=3，造成的原因就是i为全局的。
```

那么可以怎样解决呢？相信这一点对你来说很简单，在前面ES5课程中也讲过。

```javascript
for (var i = 0; i < 3; i++) {
    (function(i) {
        setTimeout(function() {
            console.log('i=', i);
        }, 1000)
    })(i)
}

// 通过以上的代码其实就是通过自定义一个函数，生成了函数的作用域,i变量就不是全局的了。
```

这种使用方式很麻烦，有了let命令后，就变的非常的简单了。

代码如下：

```javascript
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log('i=', i);
    }, 1000)
}
```

### 53.4 let命令注意事项

**不存在变量提升**

* let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则会出错。

```javascript
console.log(num);
let num = 2;
```

**暂时性死区**
* 什么是暂时性死区呢？

```javascript
// 先来看一个案例：
var num = 123;
if (true) {
    num = 666;
    let num;
}

// 上面的代码中存在全局的变量num,但是在块级作用域内使用了let又声明了一个局部的变量num,导致后面的num绑定到这个块级作用域，所以在let声明变量前，对num进行赋值操作会出错。

// 所以说，只要在块级作用域中存在let命令，它所声明的变量就被“绑定”在这个区域中，不会再受外部的影响。
```

**如果在区域中存在let命令，那么在这个区域中通过let命令所声明的变量从一开始就生成了一个封闭的作用域，只要在声明变量前使用，就会出错**。

**所谓的“暂时性死区”指的就是，在代码块内，使用let命令声明变量之前，该变量都是不可用的。**

**不允许重复声明**

```javascript
// let 不允许在相同的作用域内重复声明一个变量，
// 如果使用var声明变量是没有这个限制的。

function test() {
    var num = 12;
    var num = 20;
    console.log(num)
}
test()
```

```javascript
// 以上代码没有问题，但是如果将var换成let,就会出错。如下代码所示：
function test() {
    let num = 12;
    let num = 20;
    console.log(num)
}
test()
```

```javascript
// 当然，以下的写法也是错误的。
function test() {
    var num = 12;
    let num = 20;
    console.log(num)
}
test()
```

```javascript
// 同时，还需要注意，不能在函数内部声明的变量与参数同名，如下所示：
function test(num) {
    let num = 20;
    console.log(num)
}
test(30)
```

## 54. const命令

### 54.1 基本用法

const用来声明常量，常量指的就是一旦声明，其值是不能被修改的。

这一点与变量是不一样的，而变量指的是在程序运行中，是可以改变的量。

```javascript
let num = 12;
num = 30;
console.log(num)
```

以上的代码输出结果为:30

但是通过const命令声明的常量，其值是不允许被修改的。

```javascript
const PI = 3.14;
PI = 3.15;
console.log(PI)
```

以上代码会出错。

在以后的编程中，如果确定某个值后期不需要更改，就可以定义成常量，例如: PI, 它的取值就是3.14，后面不会改变。所以可以将其定义为常量。

### 54.2 const命令注意事项

#### 54.2.1 不存在常量提升

以下代码是错误的

```javascript
console.log(PI);
const PI = 3.14
```

#### 54.2.2 只在声明的块级作用域内有效

const命令的作用域与let命令相同：只在声明的块级作用域内有效

如下代码所示：

```javascript
if (true) {
    const PI = 3.14;
}
console.log(PI);
```

以上代码会出错

#### 54.2.3 暂时性死区

const命令与let指令一样，都有暂时性死区的问题，如下代码所示：

```javascript
if (true) {
    console.log(PI);
    const PI = 3.14;
}
```

以上代码会出错

#### 54.2.4 不允许重复声明

```javascript
let PI = 3.14;
const PI = 3.14;
console.log(PI);
```

以上代码会出错

#### 54.2.5 常量声明必须赋值

使用const声明常量，必须立即进行初始化赋值，不能后面进行赋值。

如下代码所示：

```javascript
const PI;
PI = 3.14;
console.log(PI);
```

以上代码会出错

## 55. 解构赋值

### 55.1 数组解构赋值基本用法

所谓的解构赋值，就是从数组或者是对象中提取出对应的值，然后将提取的值赋值给变量。

首先通过一个案例，来看一下以前是怎样实现的。

```javascript
let arr = [1, 2, 3];
let num1 = arr[0];
let num2 = arr[1];
let num3 = arr[2];
console.log(num1, num2, num3);
```

在这里定义了一个数组arr, 并且进行了初始化，下面紧跟着通过下标的方式获取数组中的值，然后赋值给对应的变量。

虽然这种方式可以实现，但是相对来说比较麻烦，ES6中提供了解构赋值的方式，代码如下：

```javascript
let arr = [1, 2, 3];
let [num1, num2, num3] = arr;
console.log(num1, num2, num3);
```

将arr数组中的值取出来分别赋值给了，num1, num2和num3.

通过观察，发现解构赋值等号两侧的结构是类似。

下面再看一个案例：

```javascript
let arr = [{
        userName: 'zs',
        age: 18
    },
    [1, 3], 6
];
let [{
        userName,
        age
    },
    [num1, num2], num3
] = arr;
console.log(userName, age, num1, num2, num3);
```

定义了一个arr数组，并且进行了初始化，arr数组中有对象，数组和数值。

现在通过解构赋值的方式，将数组中的值取出来赋给对应的变量，所以等号左侧的结构和数组arr的结构是一样的。

但是，如果不想获取具体的值，而是获取arr数组存储的json对象，数组，那么应该怎样写呢？

```javascript
let arr = [{
        userName: 'zs',
        age: 18
    },
    [1, 3], 6
];
let [jsonResult, array, num] = arr;
console.log(jsonResult, array, num);
```

### 55.2 注意事项

##### 55.2.1  如果解析不成功，对应的值会为undefined.

```javascript
let [num1, num2] = [6]
console.log(num1, num2);
```

以上的代码中，num1的值为6，num2的值为undefined.

##### 55.2.2  不完全解构的情况

所谓的不完全解构，表示等号左边只匹配右边数组的一部分。

代码如下：

```javascript
let [num1, num2] = [1, 2, 3];
console.log(num1, num2);
```

以上代码的执行结果：num1=1, num2 = 2

也就是只取了数组中的前两个值。

```javascript
// 如果只取第一个值呢？
let [num1] = [1, 2, 3];
console.log(num1);
```

```javascript
//只取第二个值呢？
let [, num, ] = [1, 2, 3];
console.log(num);
```

```javascript
// 只取第三个值呢？
let [, , num] = [1, 2, 3];
console.log(num);
```

### 55.3 对象解构赋值基本使用

解构不仅可以用于数组，还可以用于对象。

```javascript
let {
    userName,
    userAge
} = {
    userName: 'ls',
    userAge: 20
};
console.log(userName, userAge);
```

在对 对象进行解构赋值的时候，一定要注意：变量名必须与属性的名称一致，才能够取到正确的值。

如下所示：

```javascript
let {
    name,
    age
} = {
    userName: 'ls',
    userAge: 20
};
console.log(name, age);
```

输出的结果都是undefined.

那么应该怎样解决上面的问题呢？

```javascript
let {
    userName: name,
    userAge: age
} = {
    userName: 'ls',
    userAge: 20
}
console.log(name, age);
```

通过以上的代码解决了对应的问题，那么这种方式的原理是什么呢？

**先找到同名属性，然后再赋值给对应的变量。**

把上面的代码，改造成如下的形式，更容易理解：

```javascript
let obj = {
    userName: 'ls',
    userAge: 21
};
let {
    userName: name,
    userAge: age
} = obj;
console.log(name, age)
```

如果按照ES5的方式：

```javascript
let name = obj.userName
let age = obj.userAge
```

### 55.4 对象解构赋值注意事项

#### 55.4.1 默认解构

所谓的默认解构，指的是取出来值就用取出来的值，如果取不出来就用默认的值。

演示默认解构之前，先来看如下的代码：

```javascript
let obj = {
    name: 'zs'
};
let {
    name,
    age
} = obj;
console.log(name, age);
```

你想一下输出结果是什么呢？

输出的结果是：zs  undefined

也就是name变量的值为:‘zs’, age变量的值为:'undefined'.

由于没有给age变量赋值所以该变量的值为'undefined'.

现在修改一下上面的程序

```javascript
let obj = {
    name: 'zs'
};
let {
    name,
    age = 20
} = obj;
console.log(name, age);
```

现在给age这个变量赋了一个默认值为20，所以输出的结果为：zs 20

这也就是刚才所说到的默认解构，也就是取出来值就用取出来的值，如果取不出来就用默认的值。

现在再问你一个问题：如果在对应中有age属性，那么对应的等号左侧的age这个变量的值是多少呢?

如下代码所示：

```javascript
let obj = {
    name: 'zs',
    age: 26
};
let {
    name,
    age = 20
} = obj;
console.log(name, age);
```

输出的结果为: zs  26

这就是，取出来值就用取出来的，取不出来就用默认值。

#### 55.4.2  嵌套结构对象的解构

解构也可以用于对嵌套结构的对象，如下代码所示：

```javascript
let obj = {
    arr: [
        "Hello", {
            msg: 'World'
        }
    ]
}
let {
    arr: [str, {
        msg
    }]
} = obj;
console.log(str, msg);
```

在上面的代码中要注意的是：arr只是一种标志或者是一种模式，不是变量，因此不会被赋值。

再看一个案例:

```javascript
let obj = {
    local: {
        start: {
            x: 20,
            y: 30
        }
    }
};
let {
    local: {
        start: {
            x,
            y
        }
    }
} = obj;
console.log(x, y);
```

在该案例中创建了一个obj对象，在该对象中又嵌套了一个local对象，该对象可以认为是一个表示位置的坐标对象，在该对象中又嵌套了一个start对象，start对象可以认为是一个位置的起始坐标点，所以在该对象中有两个属性为x, y，分别表示横坐标和纵坐标。

所以说obj对象是一个比较复杂的嵌套结构的对象，现在对该对象进行解构，那么在等号的左侧的结构要和obj对象的结构一致，最后输出打印x, y的值。

问题：如果现在要打印等号左侧的local和start，那么输出的结果是什么呢？

会出错，原因就是在等号的左侧，只有x和y是变量，local和start都是一种标识，一种模式，所以不会被赋值。

### 55.5 字符串的解构赋值

字符串也可以进行解构赋值，这是因为字符串被转换成了一个类似于数组的对象。

```javascript
let [a, b, c, d, e, f] = 'wangcai';
console.log(a, b, c, d, e, f);
```

类似于数组的对象都有length属性，因此也可以对这个属性进行解构赋值。

```javascript
let {
    length: len
} = 'wangcai';
console.log('len=', len);
```

### 55.6 函数参数的解构赋值

函数的参数也能够进行解构的赋值，如下代码所示：

```javascript
function test([x, y]) {
    return x + y;
}
console.log(test([3, 6]));
```

上面的代码中，函数test的参数不是一个数组，而是通过解构得到的变量x和y.

函数的参数的解构也可以使用默认的值。

```javascript
function test({
    x = 0,
    y = 0
} = {}) {
    return [x, y];

}
console.log(test({
    x: 3,
    y: 6
}));
```

当然可以进行如下的调用

```javascript
test({
    x: 3
})
test({})
```

### 55.7 解构赋值的好处

#### 55.7.1 交换变量的值

```javascript
let num1 = 3;
let num2 = 6;
[num1, num2] = [num2, num1];
console.log(num1, num2);
```

#### 55.7.2 函数可以返回多个值

```javascript
function test() {
    return [1, 2, 3];
}
let [a, b, c] = test();
console.log(a, b, c);
```

在上面的代码中，返回了三个值，当然在实际的开发过程中，你可以根据自己的实际情况确定返回的数据的个数。

如果，我只想接收返回中的一部分值呢？

```javascript
// 接收第一个值
function test() {
    return [1, 2, 3];
}
let [a] = test();
console.log(a);

// 接收前两个值
function test() {
    return [1, 2, 3];
}
let [a, b] = test();
console.log(a, b);

// 只接收第一个值和第三个值。
function test() {
    return [1, 2, 3];
}
let [a, , b] = test();
console.log(a, b);
```

#### 55.7.3 函数返回一个对象

可以将函数返回的多个值封装到一个对象中。

```javascript
function test() {
    return {
        num1: 3,
        num2: 6
    }
}
let {
    num1,
    num2
} = test();
console.log(num1, num2);
```

#### 55.7.4 提取JSON对象中的数据

解构赋值对提取JSON对象中的数据也非常有用。

```javascript
let userData = {
    id: 12,
    userName: 'wangcai',
    userAge: 20
}
let {
    id,
    userName,
    userAge
} = userData;
console.log(id, userName, userAge);
```

以上的代码可以快速提取JSON中的数据。

## 56. 扩展运算符与 `rest` 运算符

### 56.1 扩展运算符

扩展运算符的表现形式是三个点（...）, 可以将一个数组转换为用逗号分隔的序列。

下面通过一个案例看一下基本的应用，案例的要求是将两个数组合并为一个数组。

先采用传统的做法：

```javascript
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [].concat(arr1, arr2);
console.log(arr3);
```

下面使用扩展运算符来完成上面的案例

```javascript
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [...arr1, ...arr2];
console.log(arr3);
```

通过以上的代码，发现也实现了我们最终想要的结果， `...arr1` 是将 `arr1` 这个数组中的所有的元素取出来，然后组成 '1, 2, 3'这个形式，放到 `...arr1` 这个位置，同理arr2也是一样。

通过扩展运算符实现起来发现更加的简单。

当然我们可以将上面使用扩展运算符实现的案例，转成ES5看一下。

转成ES5的代码如下：

```javascript
var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
var arr3 = [].concat(arr1, arr2);
console.log(arr3);
```

发现和我们最开始实现的是一样的。

### 56.2 扩展运算符应用场景

#### 56.2.1 代替数组中的apply方法

现在求数组中的最大值。

求最大值，我们想到的第一种方法就是：

通过循环的方式来完成，如下面的代码：

```javascript
let arr = [12, 23, 11, 56];
let max = arr[0]
for (let index = 0; index < arr.length; index++) {
    if (arr[index] > max) {
        max = arr[index];
    }

}
console.log("max=", max);
```

这种方式非常麻烦，所以可以使用Math对象中的max方法来完成.

先来看一下Math.max的基本用法

```javascript
console.log(Math.max(1, 5, 12, 67));
```

如果是用Math.max来计算数组中的最大值。（ES5的写法）

```javascript
let arr = [12, 23, 11, 56];
console.log(Math.max.apply(null, arr));
```

虽然可以使用 `Math.max.apply` 来实现，但是感觉还是很麻烦，

这里就可以使用扩展运算符

```javascript
let arr = [12, 23, 11, 56];
console.log(Math.max(...arr));
```

在上面的代码中（不管ES5还是ES6），由于JavaScript不提供求数组中最大值的函数，所以只能将数组转换成一个参数的列表，然后再进行相应的求值。

#### 56.2.2 用于函数调用

在函数调用的时候，需要进行参数的传递，在某些情况下，通过扩展运算符，更有利于参数的传递。

```javascript
function test(num1, num2) {
    return num1 + num2;
}
let array = [23, 56];
console.log(test(...array));
```

通过扩展运算符，将array这个数组中的值取出来，然后23赋值给了num1, 56赋值给了num2.

下面，再看一个使用扩展运算符处理函数参数的案例。

把一组数据添加到数组中。

```javascript
function test(array, ...items) {
    array.push(...items);
    console.log(array)
}
let array = [23, 56];
test(array, 90, 78, 98);
```

test这个函数的作用是：把90, 78, 98这三个数添加到array这个数组中，

在这里要注意的是：90, 78, 98 这三个数据给了items这个参数，这里我们用到了后面所讲解的rest参数，所以items这个参数实际上是一个数组，然后在test这个函数体内，又通过扩展运算符将items这个数组中的数据取出来给了array这个数组。

### 56.3 `rest` 运算符

####    56.3.1 rest参数基本使用

在 `ES6` 中引入了rest参数，形式为"... 变量名"，用于获取函数中的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组。

```javascript
function add(s, num1, num2) {
    return s + (num1 + num2);

}
console.log(add('+', 2, 3));
```

在上面定义的函数中，传递了三个参数，第一个参数：是一个‘+’号，后面两个参数，表示进行加法运算的数据。

但是，问题是如果参与运算的数据比较多，那么定义的参数也就比较多，这样比较麻烦。这时可以使用rest参数形式。

如下所示：

```javascript
function add(...values) {
    console.log(values);
}
add(2, 3);
```

通过以上的代码输出发现，values这个参数是一个数组，所传递的数据都存储到这个数组中，下面可以将数据从这个数组中取出来，进行运算。

```javascript
function add(...values) {
    // console.log(values);
    let sum = 0;
    for (let index = 0; index < values.length; index++) {
        sum += values[index];
    }
    return sum;
}
console.log(add(2, 3));
```

上面的循环方式，使用的是传统的模式，也可以使用 `forEach` 的形式来进行循环，如下所示：

```js
function add(...values) {
    let sum = 0;
    values.forEach(function(item) {
        sum += item
    })
    return sum;
}
console.log(add(2, 3));
```

下面我们再来看一个 `rest` 运算符的基本使用

解构会将相同数据结构对应的值赋给对应的变量，但是当我们想将其中的一部分值统一赋值给一个变量的时候，可以使用 `rest` 运算符。

如下代码：

```js
let arr = [1, 2, 3, 4, 5, 6];
let [arr1, ...arr2] = arr; //进行解构处理
console.log(arr1); // 1
console.log(arr2); // [2,3,4,5,6]
```

在上面的代码中， `arr` 经过解构后，变量 `arr1` 的值为1，而通过 `rest` 运算符会将后面所有的值都统一赋值给 `arr2` 变量，得到的 `arr2` 为一个数组。

####  56.3.2 rest参数的好处

在以前的案例中，我们都是使用 `arguments` .

那么这种用法比 `arguments` 有什么样的好处呢？

对数据进行排序，使用的是 `arguments` 。

```javascript
function sortFunc() {
    return Array.prototype.slice.call(arguments).sort()
}
console.log(sortFunc(23, 12, 67));
```

下面使用 rest的方式

```javascript
function sortFunc(...values) {
    return values.sort()
}
console.log(sortFunc(23, 12, 67));
```

因为values这个参数本身就是数组，所以可以直接使用sort函数，进行数据的排序操作。

通过以上的对比，发现使用rest这种参数的写法更简洁。

#### 56.3.3 rest参数注意问题

在使用rest这种参数的时候，一定要注意： rest参数之后不能再有其他的参数，也就是说rest参数只能是最后一个参数，否则会报错。

如下代码所示：

```javascript
function test(a, ...b, c) {
    console.log(a);
    console.log(b);
    console.log(c);
}
test(1, 23, 2, 5);
```

以上代码会出错，要求rest参数只能是最后一个参数。

通过前面对扩展运算符和 `rest` 运算符的讲解，我们知道两者是互为逆运算，扩展运算符是将数组分隔成独立的序列，而 `rest` 运算符是将独立的序列合并成一个数组。

既然两者都是通过3个点(...)来表示，那么如何判断这3个点属于哪一种运算符呢？我们可以遵循如下的规则：

第一：当3个点(...)出现在函数的形参上或者出现在赋值号的左侧，则表示的就是 `rest` 运算符

第二：当3个点(...)出现在函数的实参上或者出现在赋值号的右侧，则表示它为扩展运算符。

## 57. 什么是箭头函数

### 57.1 箭头函数基本使用

在ES6中允许使用 “箭头”（=>）来定义函数。

先使用传统的方式定义一个函数。

示例代码如下：

```javascript
// 使用传统方式定义函数
let f = function(x, y) {
    return x + y;
}
console.log(f(3, 6));
```

通过上面的代码，可以发现传统方式来定义函数的时候，比较麻烦。

箭头函数的使用

```javascript
let f = (x, y) => {
    return x + y
};
console.log(f(9, 8));
```

在调用f这个函数的时候，将9和8传递给了x, y这两个参数，然后进行加法运算。

如果参数只有一个，可以省略小括号。

```javascript
let f = num => {
    return num / 2;
}
console.log(f(6));
```

如果没有参数，只需要写一对小括号就可以。

```javascript
let f = () => {
    return 9 / 3;
}
console.log(f());
```

上面我们写的代码中，发现函数体中只有一条语句，那么这时是可以省略大括号的。

```javascript
let f = (x, y) => x + y;
console.log(f(3, 6));
```

把上面的代码转换成ES5的写法，发现和我们前面写的代码是一样的。

```javascript
var f = function f(x, y) {
    return x + y;
};
console.log(f(3, 6));
```

### 57.2  箭头函数注意事项

#### 57.2.1 直接返回对象

如果希望箭头函数**直接**返回一个对象，应该怎样写呢？

你可能认为很简单，可以采用如下的写法

```javascript
let f = (id, name) => {
    id: id,
    userName: name
};
console.log(f(1, 'zs'));
```

但是上面的写法是错误的，因为这时大括号被解释为代码块，解决的办法是：在对象外面加上小括号, 

所以，正确的写法如下：

```javascript
let f = (id, name) => ({
    id: id,
    userName: name
});
console.log(f(1, 'zs'));
```

通过打印，发现输出的是一个对象。

当然也可以采用如下的写法

```javascript
let f = (id, name) => {
    return {
        id: id,
        userName: name
    }
};
console.log(f(1, 'zs'));
```

#### 57.2.2 箭头函数中this的问题

下面定义一个对象，来理解this的应用。

看一下，如下代码：

```javascript
let person = {
    userName: 'ls',
    getUserName() {
        console.log(this.userName)
    }
}
person.getUserName();
```

以上代码执行的结果为：'ls', 并且在该程序中 `this` 为当前的person对象。

现在，将上面的代码修改一下，要求延迟1秒钟以后，再输出用户名的名称。

```javascript
let person = {
    userName: 'ls',
    getUserName() {
        setTimeout(function() {
            console.log(this.userName)
        }, 1000)
    }
}
person.getUserName();
```

上面的输出结果为： `undefined` ，因为在setTimeout中this指的是window, 而不是person对象。

为了解决上面的问题，可以将代码进行如下的修改：

```javascript
let person = {
    userName: 'ls',
    getUserName() {
        let that = this;
        setTimeout(function() {
            console.log(that.userName)
        }, 1000)
    }
}
person.getUserName();
```

在进入setTimeout这个方法之前，提前将this赋值给that变量，然后在setTimeout中使用that, 那么这时that指的就是person对象。

上面的解决方法比较麻烦，可以修改成箭头函数的形式，代码如下所示：

```js
let person = {
    userName: 'wangwu',
    getUserName() {
        setTimeout(() => {
            console.log(this.userName);
        }, 1000)
    }
}
person.getUserName();
```

通过上面的代码，可以发现在箭头函数中直接使用this是没有问题的。

你可以这样理解：**在箭头函数中是没有this的，如果在箭头函数中使用了this, 那么实际上使用的是外层代码块的this.  箭头函数不会创建自己的 `this,它只会从自己的作用域链的上一层继承this` **

或者通俗的理解：**找出定义箭头函数的上下文（即包含箭头函数最近的函数或者是对象），那么上下文所处的父上下文即为this.**

那么在我们这个案例中， `setTimeout` 函数中使用了箭头函数，箭头函数中用了 `this,` 而这时 `this` 指的是外层代码块也就是 `person` , 所以箭头函数中使用的this指的就是 `person` (包含箭头函数最近的函数是 `setTimeout` , 那么包含 `setTimeout` 这个函数的最近的函数或者是对象是谁呢？对了，是 `getUserName` 这个函数，而 `getUserName` 这个函数是属于哪个对象呢？是 `person` , 所以 `this` 为 `person` )

下面，再看一个案例：（可以将下面的代码转换成ES5的代码）

```javascript
let person = {
    userName: 'wangcai',
    getUserName: () => {
        console.log(this.userName)
    }
}
person.getUserName();
```

输出结果为:undefined

因为这时包含 `getUserName` 这个箭头函数最近的对象是person(这里也就是说 `getUserName` 这个箭头函数的上下文为 `person` ), 那么 `person` 对象所处的父上下文(也就是包含person这个对象最近的对象)，是谁呢？对了，就是 `window` 。

下面再看一个案例：

```javascript
let person = {
    userName: 'wangcai',
    getUserName() {
        return () => {
            console.log(this.userName);
        }
    }
}
person.getUserName()();
```

根据上面总结的规律是，这段代码输出的结果是：'wangcai'.

在这里还需要注意一个问题就是：

由于箭头函数没有自己的this, 所以不能使用 `call()` 、 `apply()` 、 `bind()` 这些方法来改变this的指向。

```js
let adder = {
    base: 1,
    add: function(a) {
        let f = v => v + this.base;
        let b = {
            base: 3
        };
        return f.call(b, a);
    }
};
console.log(adder.add(1))
```

上面代码执行的结果为:2

也就是说，箭头函数不能使用 `call( )` 来改变this的指向，本意是想让this指向b这个对象，但是实际上this还是adder这个对象。

#### 57.2.3 箭头函数不适合的场景

第一：不能作为构造函数，不能使用 `new` 操作符

构造函数是通过 `new` 操作符生成对象实例的，生成实例的过程也是通过构造函数给实例绑定 `this` 的过程，而箭头函数没有自己的 `this` ，因此不能使用箭头函数作为构造函数。

如下代码：

```js
function Person(name) {
    this.name = name;
}
var p = new Person("wangcai"); //正常
```

以上是我们前面经常使用的一种方式，没有问题

下面看一下使用箭头函数作为构造函数的情况

```js
let Person = (name) => {
    this.userName = name;
};
let p = new Person("lisi");
```

当执行上面的程序的时候，会出现错误

第二：没有 `prototype` 属性

因为在箭头函数中没有 `this` , 也就不存在自己的作用域，因此箭头函数是没有 `prototype` 属性的。

```js
let Person = (name) => {
    this.userName = name;
};
console.log(Person.prototype); // undefined
```

第三：不适合将原型函数定义成箭头函数

在给构造函数添加原型函数时，如果使用箭头函数，其中的 `this` 会指向全局作用域 `window` , 而不会指向构造函数。

因此并不会访问到构造函数本身，也就无法访问到实例属性，失去了原型函数的意义。

```js
function Person(name) {
    this.userName = name;
}
Person.prototype.sayHello = () => {
    console.log(this); // window
    console.log(this.userName); // undefined
};
let p = new Person("wangcai");
p.sayHello();
```

## 58、对象的扩展

### 58.1 属性与方法的简洁表示方式

以前创建对象的方式：

```javascript
let userName = 'wangcai';
let userAge = 18;
let person = {
    userName: userName,
    userAge: userAge
}
console.log(person);
```

通过上面的代码，可以发现对象中的属性名和变量名是一样的，像这种情况，在ES6中是可以简化如下形式：

```javascript
let userName = 'wangcai';
let userAge = 18;
let person = {
    userName,
    userAge
}
console.log(person);
```

通过以上代码可以发现：在ES6中，如果对象的属性名和变量名是一样的，那么两者可以合二为一。

当然，除了属性可以简写，方法也可以简写，以前定义方法的形式如下：

```javascript
let userName = 'wangcai';
let userAge = 18;
let person = {
    userName,
    userAge,
    sayHello: function() {
        console.log('你好')
    }
}
person.sayHello();
```

在ES6中可以简化成如下的形式:

```javascript
let userName = 'wangcai';
let userAge = 18;
let person = {
    userName,
    userAge,
    sayHello() {
        console.log('Hello');
    }
}
person.sayHello();
```

所以在以后的编程中，会经常看到或者是用到这种 `ES6` 的表示形式。

### 58.2 Object.assign( )方法

#### 58.2.1 基本使用

现在，有一个需求，将一个对象的属性拷贝给另外一个对象，应该怎样处理？

你可能会说，很简单，可以通过循环的方式来来实现。

如下代码所示：

```javascript
let obj1 = {
    name: 'wangcai'
};
let obj2 = {
    age: 20
};
let obj3 = {};
for (let key in obj1) {
    obj3[key] = obj1[key];
}
for (let key in obj2) {
    obj3[key] = obj2[key];
}
console.log('obj3=', obj3);
```

虽然通过循环的方式，可以实现对象属性的拷贝，但是很麻烦。下面讲解一个简单的方法： `Object.assign( )` 方法.

`Object.assign( )` 方法用来源对象的所有可枚举的属性复制到目标对象。该方法至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出异常。

示例代码如下：

```javascript
let target = {
    a: 1,
    b: 2
};
let source = {
    c: 3,
    d: 4
};
Object.assign(target, source);
console.log(target);
```

最终的结果：将source对象中的属性拷贝到target对象上。

在上面的定义中，可以看出参数不仅两个，可以有多个，但是要注意的是第一个参数一定是目标对象，下面再看一个多个参数的案例：

```javascript
let target = {
    a: 1,
    b: 2
};
let source = {
    c: 3,
    d: 4
};
let source1 = {
    e: 5,
    f: 6
};

Object.assign(target, source, source1);
console.log(target);
```

通过上面的代码，将source和 `source1` 这两个对象的属性都拷贝给了target对象。

#### 58.2.2  深浅拷贝问题

通过 `Object.assign( )` 方法，实现的拷贝只拷贝了属性的值，属于浅拷贝。

如下代码所示：

```javascript
let obj1 = {
    name: '张三',
    address: {
        city: '北京'
    }
}
let obj2 = {};
Object.assign(obj2, obj1);
obj2.address.city = "上海";
console.log("obj1=", obj1);
console.log("obj2=", obj2);
```

上面的代码中对 `obj2` 这个对象的city属性的值进行了修改，发现对应的 `obj1` 对象中的city属性的值也发生了改变。

但是，在某些情况下，我们不希望这样，我们希望修改一个对象的属性值时，不会影响到另外一个对象的属性值。

那么对应的要实现相应的深拷贝。

关于深拷贝，实现方式比较多，下面简单的说一种方式：(这里只是简单的模拟)

```javascript
function clone(source) {
    let newObj = {};
    for (let key in source) {
        // 由于address属性为对象，所以执行递归。
        if (typeof source[key] === 'object') {
            newObj[key] = clone(source[key]);
        } else {
            // 如果是name属性直接赋值
            newObj[key] = source[key];
        }
    }
    return newObj;
}
let obj1 = {
    name: '张三',
    address: {
        city: '北京'
    }
}
let obj2 = clone(obj1);
obj2.address.city = "上海";
console.log("obj1=", obj1);
console.log("obj2=", obj2);
```

#### 58.2.3 注意事项

1、如果目标对象与源对象有同名属性，那么后面的属性会覆盖前面的属性。

```javascript
let target = {
    a: 1,
    b: 2
};
let source = {
    b: 3,
    d: 4
};
Object.assign(target, source);
console.log(target);
```

上面的代码，将source对象中的属性拷贝给了target对象，但是source对象中有b这个属性，而且target对象上也有b属性，那么最终的结果是:source对象中的b属性覆盖掉target对象中的b属性。

2、不可枚举的属性不会被复制。

```javascript
let obj = {};
Object.defineProperty(obj, 'b', {
    enumerable: false,
    value: 'world'
})
let obj1 = {
    a: 'hello'
}
Object.assign(obj1, obj);
console.log('obj1=', obj1);
```

在上面的代码中，通过 `Object.defineProperty()` 方法为obj对象添加了一个属性b, 这个属性的值为 'world', 并且指定了enumerable这个属性的值为false. 也就是不可以被枚举。也就是该属性不可以通过for in来进行遍历。

最终，通过 `Object.assign` 这个方法进行拷贝，发现 `obj1` 对象中没有obj对象的b这个属性。

## 59. Symbol

### 59.1. Symbol简介

在具体讲解Symbol之前，先来看一个问题。

`ES5` 的对象属性名都是字符串，这样容易造成属性名的冲突。

代码如下所示：

```javascript
let obj = {
    num: 10,
    "num 1": 20
}
console.log(obj.num);
console.log(obj["num 1"]);
```

通过以上的代码，可以发现在对象中定义的属性的名称本身就是字符串，而且发现“num 1”中间是有空格的，所以在访问该属性的时候，通过[ ]的形式来进行访问。

那么为什么说容易造成属性名的冲突呢？

举例说明：你用了一个别人提供的对象，但是又想为这个对象添加新的方法或者是属性，新方法或者是新属性的名称有可能与现有对象中的属性名称或者是方法的名称产生冲突。如果有一种机制，能够保证每个属性的名字都是唯一的，**那么就能够从根本上防止属性名称的冲突问题**。这也就是ES6引入Symbol的原因。

Symbol是一种数据类型，是JavaScript语言的第7种数据类型，前6种分别是:undefined, null, 布尔值，字符串，数值和对象。

Symbol类型的值是通过Symbol函数生成的。它的值是独一无二的，也就是唯一的，可以保证对象中属性名称的唯一。

可以通过如下的代码测试类型

```javascript
let s = Symbol();
console.log(typeof s);
```

对应的输出类型为"symbol"

下面创建Symbol类型的变量，然后进行打印输出。

```javascript
let s = Symbol();
let s1 = Symbol();
console.log(s);
console.log(s1);
```

发现输出的结果都是：Symbol( )。

输出的结果都是Symbol( ), 那么无法区分，哪个Symbol( )是s变量的，哪个是s1变量的。

为了解决这个问题，Symbol( )函数可以接受一个字符串作为参数，这个参数表示对Symbol的描述，主要是为了在控制台进行输出打印的时候，能够区分开，Symbol最终是属于哪个变量的。

```javascript
let s = Symbol('s');
let s1 = Symbol('s1');
console.log(s);
console.log(s1);
```

输出的结果为：Symbol(s)和Symbol(s1)

注意：Symbol函数的参数只表示对当前Symbol值（结果）的描述，因此相同参数的Symbol函数的返回值是不相等的。代码如下：

```javascript
let s = Symbol('s');
let s1 = Symbol('s');
console.log(s === s1);
```

以上结果为：false.

### 59.2 Symbol应用场景

#### 59.2.1 作为属性名的Symbol

在前面的课程中，讲解过由于Symbol的值是唯一的，并且能够保证对象中不会出现同名的属性。下面，先来讲解一下，怎样使用Symbol作为属性名，然后再看一下怎样保证对象中不会出现同名属性。

第一种添加属性的方式：

```javascript
let mySymbol = Symbol();
let obj = {}
// 第一种添加属性的方式
obj[mySymbol] = 'hello';
console.log(obj[mySymbol]);
```

第二种添加属性的方式：

```javascript
let mySymbol = Symbol();
let obj = {
    [mySymbol]: 'world' // 注意mySymbol必须加上方括号，否则为字符串而不是Symbol类型。
}
console.log(obj[mySymbol]);
```

第三种添加属性的方式

```javascript
let mySymbol = Symbol();
let obj = {};
Object.defineProperty(obj, mySymbol, {
    value: '你好'
})
console.log(obj[mySymbol]);
```

#### 59.2.2  防止属性名称冲突

在前面，已经讲解了怎样使用Symbol作为属性名了，下面看一下怎样通过Symbol来防止属性名的冲突。

下面先定义一个对象，然后动态的向对象中添加一个id属性。

```javascript
let obj = {
    name: 'zs',
    age: 18
}

function test1(obj) {
    obj.id = 42;
}

function test2(obj) {
    obj.id = 369;
}
test1(obj);
test2(obj);
console.log(obj);
```

在上面的代码中，有两个函数分别是test1和test2向obj这个对象中动态添加id属性，在这里可以把这两个函数想象成两个不同的模块，或者是两个不同开发人员来实现的功能。

但是问题是，由于test2( )这个函数后执行，所以会将test1( )这个函数创建的id属性的值覆盖掉。那么这是我们不希望看到的，为了解决这个问题，可以使用Symbol作为属性名来解决。

```javascript
let obj = {
    name: 'zs',
    age: 18
}
let mySymbol = Symbol('lib1');

function test1(obj) {
    obj[mySymbol] = 42;

}
let mySymbol2 = Symbol('lib2');

function test2(obj) {
    obj[mySymbol2] = 369;
}
test1(obj);
test2(obj);
console.log(obj);
```

通过上面的代码可以发现，通过Symbol解决了属性名称冲突的问题。

## 60. Proxy

### 60.1. Proxy简介

有这样一个需求：有一个对象，我们需要监听这个对象的属性被设置了或被获取了。

直接上代码：

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }

    Object.defineProperty(obj, "name", {
        get: function() {
            console.log("监听到了obj对象的name属性被访问了");

            return "666";
        },
        set: function() {
            console.log("监听到了obj对象的name属性被设置了");
        }
    })

    // 在你获取或设置时，能不能监听到
    console.log(obj.name); // 获取obj中的属性
    obj.name = "xq"; // 设置obj中的name属性
</script>
```

上面的代码是监听到了name属性的，我想监听一个对象上N个属性，如何做：

```html
<script>
    let obj = {
        name: "wc",
        age: 18,
        adress: "bj",
    }
    Object.keys(obj).forEach(key => {
        let value = obj[key];
        Object.defineProperty(obj, key, {
            get: function() {
                console.log(`监听到了obj对象的${key}属性被访问了`);
                return value;
            },
            set: function() {
                console.log(`监听到了obj对象的${key}属性被设置了`);
            }
        })
    })
    console.log(obj.name);
    obj.name = "wc666";
    console.log(obj.adress);
</script>
```

**上面监听属性的变化，有什么不足？**
1. Object.defineProperty刚开始设计初衷，并不是用来监听对象中的属性 <br/>
2. 如果对象非常复杂，需要递归去监听，一旦递归，性能非常差 <br/>
3. 有些操作监听不了，如添加属性，删除属性.... <br/>

基于上面的缺点，在ES6中，引出了Proxy类，从这个类名上可以看出，它是一个代理。
和日常生活中的代理是一个意思，就是中介。也就是说，如果我们监听一个对象的相关操作，那么我们需要创建一个代理类，之后该对象的所有操作，都通过代码对象来完成，代理对象可以监听到我们对原始对象的操作。

使用Proxy监听对对象中属性的操作，代码如下：

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }

    // Proxy是ES6中的一个类
    // objProxy 是上面obj的代理对象
    // obj 叫原始对象
    // {} handler 处理对象
    let objProxy = new Proxy(obj, {
        // key 表示你访问的属性名
        // target 表示原始对象
        get: function(target, key) {
            console.log(`监听到了obj对象的${key}属性被访问了`, target);
            // .....
            return target[key]
        },
        set: function(target, key, newValue) {
            console.log(`监听到了obj对象的${key}属性被设置了`, target);
            target[key] = newValue;
        }
    })
    console.log(objProxy.name);
    objProxy.name = "wc666"
    console.log(objProxy.name);
</script>
```

当new Proxy时，第1个参数是原始对象，第2个参数是处理对象，处理对象中放捕获器，上面的的get和set其实就是捕获器，proxy中有13的捕获器：

```html
<script>
    let obj = {
        name: "wc",
        age: 18
    }
    // 代理对象就可以监听到你对对象中属性的操作
    let objProxy = new Proxy(obj, {
        // 获取值时的捕获器
        get: function(target, key) {
            console.log(`监听到了obj对象的${key}属性被访问了`, target);
            return target[key]
        },
        // 设置值时的捕获器
        set: function(target, key, newValue) {
            console.log(`监听到了obj对象的${key}属性被设置了`, target);
            target[key] = newValue;
        },
        // 监听in的捕获器
        has: function(target, key) {
            console.log(`监听到了obj对象的${key}属性in操作`, target);
            return key in target;
        },
        // 监听delete的捕获器
        deleteProperty: function(target, key) {
            console.log(`监听到了obj对象的${key}属性delete操作`, target);
            delete target[key]
        }
    })
    // 判断name是否是objProxy的属性
    console.log("name" in objProxy);
    delete objProxy.name;
    console.log(objProxy.name);
</script>
```

**注意：要使Proxy起作用，必须针对Proxy对象进行操作，不是针对目标对象进行操作(上面的是student对象)。**

## 61. Set和Map结构

在ES6之前，我们存储数据的结构主要有两种：数组、对象。在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap。

<br/>

Set结构与数组类似，但是成员的值都是唯一的，没有重复值。创建Set我们需要通过Set构造函数（暂时没有字面量创建的方式）, 我们可以发现Set中存放的元素是不会重复的，那么Set有一个非常常用的功能就是给数组去重

### 60.1 常用的操作方法

关于常用的操作方法，这里会讲解如下4个。

`add(value)` : 添加某个值，返回Set结构本身。

`delete(value)` : 删除某个值，返回一个布尔值，表示删除是否成功

`has(value)` : 返回一个布尔值，表示参数是否为Set的成员.

`clear()` : 清除所有成员，没有返回值

`遍历` : 另外Set是支持for of的遍历的

#### 60.1.1 add( )方法

下面先看一下 `add( )` 方法的使用

```javascript
let s = new Set();
s.add(1);
s.add(2);
s.add(3);
console.log(s);
console.log(s.size);
```

在上面的代码中，用到了size属性，这个属性返回的是Set结构中的成员总数。

Set结构中的成员是不允许出现重复值的，下面测试一下。

```javascript
let s = new Set();
s.add(1);
s.add(2);
s.add(3);
s.add(3)
console.log(s);
console.log(s.size);
```

在上面的代码中，又添加了一个数字3，但是在输出的时候，发现3这个数值只出现了一次，并且总数的个数也没有发生变化，所以Set是不允许出现重复的。

#### 60.1.2 has( )方法

```javascript
let s = new Set();
s.add(1);
s.add(2);
s.add(3);
s.add(3);
console.log(s);
console.log(s.size);
console.log(s.has(3))
console.log(s.has(5))
```

#### 60.1.3 delete( )方法

```javascript
let s = new Set();
s.add(1);
s.add(2);
s.add(3);
s.add(3);
console.log(s);
console.log(s.size);
console.log(s.delete(3)) //删除成功返回true.
console.log(s.has(3))
console.log(s.has(5))
```

#### 60.1.4 clear()方法

```javascript
let s = new Set();
s.add(1);
s.add(2);
s.add(3);
s.add(3);
console.log(s);
console.log(s.size);
console.log(s.delete(3))
console.log(s.has(3))
console.log(s.has(5))
s.clear(); // 清除所有项
console.log(s);
```

Set结构是一个类似数组的结构，那么怎样转换成一个真正的数据呢?

可以通过前面学习的 `Arrray.from` 方法。

```javascript
let s = new Set();
s.add(1);
s.add(2);
s.add(3);
let array = Array.from(s);
console.log(array);
```

在使用数组编程的时候，经常会用到一个功能，就是清除数组中的重复的数据，那么在这里可以借助于Set结构来完成。

```javascript
// 清除数组中的重复数据.
// Set函数可以接受一个数组或者是类似数组的对象，作为参数。
let array = [1, 2, 3, 3, 5, 6];
let s = new Set(array);
console.log(Array.from(s));
```

### 60.2 WeakSet使用

和Set类似的另外一个数据结构称之为WeakSet，也是内部元素不能重复的数据结构。

**那么和Set有什么区别呢？**
* 区别一：WeakSet中只能存放对象类型，不能存放基本数据类型；
* 区别二：WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收；
* 区别三：WeakSet不能遍历，因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁，所以存储到WeakSet中的对象是没办法获取的；

**WeakSet常见的方法：**
* add(value)：添加某个元素，返回WeakSet对象本身
* delete(value)：从WeakSet中删除和这个值相等的元素，返回boolean类型
* has(value)：判断WeakSet中是否存在某个元素，返回boolean类型

```js
 // 1.Weak Reference(弱引用)和Strong Reference(强引用)
 let obj1 = {
     name: "wc"
 }
 let obj2 = {
     name: "xq"
 }
 let obj3 = {
     name: "z3"
 }

 // let arr = [obj1, obj2, obj3]
 // obj1 = null
 // obj2 = null
 // obj3 = null

 // const set = new Set(arr)
 // arr = null

 // 2.WeakSet的用法
 // 2.1.和Set的区别一: 只能存放对象类型
 const weakSet = new WeakSet()
 weakSet.add(obj1)
 weakSet.add(obj2)
 weakSet.add(obj3)

 // 2.2.和Set的区别二: 对对象的引用都是弱引用

 // 3.WeakSet的应用
 const pWeakSet = new WeakSet()
 class Person {
     constructor() {
         pWeakSet.add(this)
     }

     running() {
         if (!pWeakSet.has(this)) {
             console.log("Type error: 调用的方式不对")
             return
         }
         console.log("running~")
     }
 }

 let p = new Person()
 // p = null
 p.running()
 const runFn = p.running
 runFn()
 const obj = {
     run: runFn
 }
 obj.run()
```

### 60.3 Map结构

另外一个新增的数据结构是Map，用于存储映射关系。但是我们可能会想，在之前我们可以使用对象来存储映射关系，他们有什么区别呢？

* 事实上我们对象存储映射关系只能用字符串（ES6新增了Symbol）作为属性名（key）
* 某些情况下我们可能希望通过其他类型作为key，比如对象，这个时候会自动将对象转成字符串来作为key，那么我们就可以使用Map

**Map的常用属性和方法**
* 常见的属性之size：返回Map中元素的个数；
* 常见的方法之set(key, value)：在Map中添加key、value，并且返回整个Map对象
* 常见的方法之get(key)：根据key获取Map中的value；
* 常见的方法之has(key)：判断是否包括某一个key，返回Boolean类型；
* 常见的方法之delete(key)：根据key删除一个键值对，返回Boolean类型
* 常见的方法之clear()：清空所有的元素；
* 常见的方法之forEach(callback, [, thisArg])：通过forEach遍历Map；
* Map也可以通过for of进行遍历。

```js
 const info = {
     name: "wc"
 }
 const info2 = {
     age: 18
 }

 // 1.对象类型的局限性: 不可以使用复杂类型作为key
 // const obj = {
 //   address: "bj",
 //   [info]: "haha",
 //   [info2]: "hehe"
 // }
 // console.log(obj)

 // 2.Map映射类型
 const map = new Map()
 map.set(info, "wc")
 map.set(info2, "xq")
 console.log(map)

 // 3.Map的常见属性和方法
 // console.log(map.size)
 // 3.1. set方法, 设置内容
 map.set(info, "z3")
 console.log(map)
 // 3.2. get方法, 获取内容
 // console.log(map.get(info))
 // 3.3. delete方法, 删除内容
 // map.delete(info)
 // console.log(map)
 // 3.4. has方法, 判断内容
 // console.log(map.has(info2))
 // 3.5. clear方法, 清空内容
 // map.clear()
 // console.log(map)
 // 3.6. forEach方法
 // map.forEach(item => console.log(item))

 // 4.for...of遍历
 for (const item of map) {
     const [key, value] = item
     console.log(key, value)
 }
```

### 60.4 WeakMap的使用

和Map类型的另外一个数据结构称之为WeakMap，也是以键值对的形式存在的。

**和Map有什么区别：**
* 区别一：WeakMap的key只能使用对象，不接受其他的类型作为key；
* 区别二：WeakMap的key对对象想的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收该对象
* 区别三：WeakMap也是不能遍历的，没有forEach方法，也不支持通过for of的方式进行遍历；

**WeakMap常见的方法有四个：**
* set(key, value)：在Map中添加key、value，并且返回整个Map对象；
* get(key)：根据key获取Map中的value；
* has(key)：判断是否包括某一个key，返回Boolean类型；
* delete(key)：根据key删除一个键值对，返回Boolean类型；

```js
 let obj1 = {
     name: "wc"
 }
 let obj2 = {
     name: "xq"
 }

 // 1.WeakMap的基本使用
 const weakMap = new WeakMap()
 // weakMap.set(123, "aaa")
 weakMap.set(obj1, "aaa")
 weakMap.set(obj2, "bbb")

 obj1 = null
 obj2 = null
```

## 62. class定义类

前面，可以把函数当成一个类，函数当成一个类，在其它编程语言中，我没见过，ES6中，为了和其它编程语言保持一致，提出一个class关键，通过class去定义类，但是class仅仅是语法糖，最终还需要转化成函数。

使用class定义一个类，如下：

```html
<script>
    // Person是类名
    class Person {

    }
    let p = new Person();
    console.log(p); // 对象
</script>
```

```html
<script>
    // Person是类名
    // 类表达式
    let Person = class {

    }
    let p = new Person();
    console.log(p); // 对象
</script>
```

通过类创建出来的对象和通过构造器创建出来的对象，有什么区别？
它和我们前面使用构造器创建类的特性基本上是一样的。

```html
<script>
    function Student() {}
    console.log(typeof Student); // function

    class Person {

    }
    let p = new Person();
    // 通过class创建的类，也有prototype
    console.log(Person.prototype);
    console.log(p.__proto__);
    console.log(Person.prototype == p.__proto__);
    console.log(typeof Person);
</script>
```

通过class创建的对象，如何赋值私有属性和公有属性，如下：

```html
<script>
    class Person {
        // 一个类只有一个constructor
        // 1）内部创建一个对象  nm = {}
        // 2）将Person的原型prototype赋值给创建出来的对象  nm.__proto__ = Person.prototype
        // 3）将对象赋值给this  将this指向对象   new绑定  this = mn;
        // 4）执行constructor中的代码
        // 5）返回创建出来的对象  return nm
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
    }
    // p的私有属性：name  age
    let p = new Person("wc", 18);
    console.log(p.hasOwnProperty("name"));
    console.log(p.hasOwnProperty("age"));
</script>
```

对象中的方法或公有属性写法如下：

```html
<script>
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        // running是公有属性还是私有属性
        running() {
            console.log(this.name + " running...");
        }
    }
    let p = new Person("wc", 18);
    p.running();
    console.dir(p)
</script>
```

类中的设置器和访问器，使用如下：

```html
<script>
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
            // _address 表示不建议在类的外面访问
            // 当时就可以使用get 和 set
            this._address = "bj"
        }
        get address() {
            console.log("getter调用了~");
            // getter返回什么，address属性就是什么
            return this._address;
        }
        set address(value) {
            this._address = value;
        }
    }
    let p = new Person("wc", 18);
    console.log(p.address); // 自动调用上面的get address(){}
    p.address = "gz" // 自动调用上面的set address(){}
    console.log(p.address);
</script>
```

之前，使用函数创建创建，函数有多种角色，函数可以是类，也可以是对象，可以在函数这个对象上添加属性，如下：

```html
<script>
    function Fn() {

    }
    let f = new Fn();
    Fn.age = 110;
    Fn.address = "bj";
    console.log(Fn.age);
    console.log(Fn.address);
</script>
```

能不能在class对应的类名上添加一些属性呢？答：可以的，这样的属性，叫静态属性，如下：

```html
<script>
    // 一切都是对象
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        running() {
            console.log(this.name + " running...");
        }
        // 静态属性 只能通过类名来访问
        static eating() {
            console.log("eating...");
        }
    }
    Person.eating();
    let p = new Person("wc", 10);
    p.eating();
</script>
```

通过class创建的类，如何玩继承呢，代码如下：

```html
<script>
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        running() {
            console.log(this.name + " running...");
        }
        static eating() {
            console.log("eating...");
        }
    }
    // extends表示继承  Student类继承了Person类
    class Student extends Person {
        constructor(name, age, sno) {
            // 由于Student继承了Person，当new Student时，还需要走Person的constructor
            // super(); // super表示调用Persion的constructor
            // this.name = name;  // name表示Student的私有属性
            // this.age = age;  // age表示Student的私有属性
            // this.sno = sno;   // sno表示Student的私有属性

            super(name, age);
            this.sno = sno;
        }
    }
    let stu = new Student("wc", 18, 110);
    console.log(stu.name);
    console.log(stu.age);
    stu.running();
    Student.eating(); // 静态属性也可以继承到
</script>
```

父类有的公有属性，子类是可以重写，代码如下：

```html
<script>
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        running() {
            console.log(this.name + " running...");
        }
    }
    class Student extends Person {
        constructor(name, age, sno) {
            super(name, age);
            this.sno = sno;
        }
        // 父类有的方法，子类也可以有同名方法，重写
        // super.running();表示调用父类的runing
        running() {
            super.running();
            console.log("Student running....");
        }
    }
    let stu = new Student("wc", 18, 110);
    stu.running(); // 如果自已有，就调用自己的
</script>
```

我们自己写的类，能不能继承，JS中内置的类呢？如下：

```html
<script>
    // 自己实现的类，去继承JS中的内置的类
    class MyArray extends Array {
        // 你的push，覆盖了Array中的push
        // 重写
        push() {
            console.log("....");
        }
    }
    let marr = new MyArray();
    marr.push(1)
    marr.push(2)
    console.log(marr);
</script>
```

## 63. ES7 - Array Includes

在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 indexOf 获取结果，并且判断是否为 -1。在ES7中，我们可以通过includes来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true，否则返回false。

```js
let names = ["wc", "xq", "z3"];
if (names.includes("wc")) {
    console.log("包含wc")
}

console.log(names.indexOf(NaN)); // -1 
console.log(names.includes(NaN)); // true
```

## 64. ES7 –指数exponentiation运算符

在ES7之前，计算数字的乘方需要通过 Math.pow 方法来完成。在ES7中，增加了 ** 运算符，可以对数字来计算乘方

```js
const res = Math.pow(2, 2);
const res2 = 3 ** 3;
console.log(res, res2)
```

## 65. ES8 Object values 和 Object entries

之前我们可以通过 Object.keys 获取一个对象所有的key，在ES8中提供了 Object.values 来获取所有的value值。

```js
const obj = {
    name: "wc",
    age: 18,
    height: 1.88,
    address: "bj"
}

// 1.获取所有的key
const keys = Object.keys(obj)
console.log(keys)

// 2.ES8 Object.values
const values = Object.values(obj)
console.log(values)

// 3.ES8 Object.entries
// 3.1. 对对象操作
const entries = Object.entries(obj)
console.log(entries)
for (const entry of entries) {
    const [key, value] = entry
    console.log(key, value)
}

// 3.2. 对数组/字符串操作
console.log(Object.entries(["wc", "xq"]))
console.log(Object.entries("Hello"))
```

## 66. ES8 - String Padding

某些字符串我们需要对其进行前后的填充，来实现某种格式化效果，ES8中增加了 padStart 和 padEnd 方法，分别是对字符串的首尾进行填充的。应用场景：比如需要对身份证、银行卡的前面位数进行隐藏：

```js
// padStart和padEnd
// 1.应用场景一: 对时间进行格式化
// const minute = "15".padStart(2, "0")
// const second = "6".padStart(2, "0")

// console.log(`${minute}:${second}`)

// 2.应用场景二: 对一些敏感数据格式化
let cardNumber = "410883199898764665"
const sliceNumber = cardNumber.slice(-4)
cardNumber = sliceNumber.padStart(cardNumber.length, "*")
console.log(cardNumber)
```

## 67. ES8 - Trailing Commas

在ES8中，我们允许在函数定义和调用时多加一个逗号

```js
 function foo(num1, num2, ) {
     console.log(num1, num2)
 }

 foo(10, 20, )
```

## 68. ES8 - Object Descriptors

* Object.getOwnPropertyDescriptors

## 69. ES8 - Async Function

* 之前已讲过

## 70. ES9新增知识点

**ES9新增知识点**
* Async iterators：迭代器
* Object spread operators：之前讲过了
* Promise finally：之前讲过了

## 71. ES10 - flat flatMap

**flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回**

**flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组**
* 注意一：flatMap是先进行map操作，再做flat的操作；
* 注意二：flatMap中的flat相当于深度为1；

```js
// flat的使用: 将一个数组, 按照制定的深度遍历, 将遍历到的元素和子数组中的元素组成一个新的数组, 进行返回
const nums = [10, 20,
    [111, 222],
    [333, 444],
    [
        [123, 321],
        [231, 312]
    ]
]
const newNums1 = nums.flat(1)
console.log(newNums1)
const newNums2 = nums.flat(2)
console.log(newNums2)

// 2.flatMap的使用:对数组中每一个元素应用一次传入的map对应的函数
const messages = [
    "wc",
    "xq",
    "z3"
]

// 1.for循环的方式:
// const newInfos = []
// for (const item of messages) {
//   const infos = item.split(" ")
//   for (const info of infos) {
//     newInfos.push(info)
//   }
// }
// console.log(newInfos)

// 2.先进行map, 再进行flat操作
// const newMessages = messages.map(item => item.split(" "))
// const finalMessages = newMessages.flat(1)
// console.log(finalMessages)

// 3.flatMap
const finalMessages = messages.flatMap(item => item.split(" "))
console.log(finalMessages)
```

## 72. ES10 - Object fromEntries

在前面，我们可以通过 Object.entries 将一个对象转换成 entries，那么如果我们有一个entries了，如何将其转换成对象呢？ES10提供了 Object.formEntries来完成转换：

```js
 // 1.对象
 const obj = {
     name: "wc",
     age: 18,
     height: 1.88
 }

 const entries = Object.entries(obj)
 const info = Object.fromEntries(entries)
 console.log(info)

 // 2.应用
 const searchString = "?name=wc&age=18&height=1.88"
 const params = new URLSearchParams(searchString)
 console.log(params.get("name"))
 console.log(params.get("age"))
 console.log(params.entries())

 for (const item of params.entries()) {
     console.log(item)
 }

 const paramObj = Object.fromEntries(params)
 console.log(paramObj)
```

## 73. ES10 - trimStart trimEnd

去除一个字符串首尾的空格，我们可以通过trim方法，如果单独去除前面或者后面呢
* ES10中给我们提供了trimStart和trimEnd

```js
const message = "   Hello World    "
console.log(message.trim())
console.log(message.trimStart())
console.log(message.trimEnd())
```

## 74. ES11 - BigInt

在早期的JavaScript中，我们不能正确的表示过大的数字, 大于MAX_SAFE_INTEGER的数值，表示的可能是不正确的，如下：

```js
let maxInt = Number.MAX_SAFE_INTEGER;
console.log(maxInt);
console.log(maxInt + 1);
console.log(maxInt + 2);
```

那么ES11中，引入了新的数据类型BigInt，用于表示大的整数, BitInt的表示方法是在数值的后面加上n

```js
let bigInt = 9007199254740992n;
console.log(bigInt + 1n);
console.log(bigInt + 2n);
```

## 75. ES11 - Nullish Coalescing Operator

ES11，Nullish Coalescing Operator增加了空值合并操作符：

```js
let info = undefined
// info = info || "默认值"
// console.log(info)

// ??: 空值合并运算符
info = info ?? "默认值"
console.log(info)
```

## 76. ES11 - Optional Chaining

可选链也是ES11中新增一个特性，主要作用是让我们的代码在进行null和undefined判断时更加清晰和简洁：

```js
const obj = {
    name: "wc",
    friend: {
        name: "xq",
        // running: function() {
        //   console.log("running~")
        // }
    }
}

// 1.直接调用: 非常危险
// obj.friend.running()

// 2.if判断: 麻烦/不够简洁
// if (obj.friend && obj.friend.running) {
//   obj.friend.running()
// }

// 3.可选链的用法: ?.
obj?.friend?.running?.()
```

## 77. ES11 - Global This

之前我们希望获取JavaScript环境的全局对象，不同的环境获取的方式是不一样的
* 在浏览器中可以通过this、window来获取；
* 在Node中我们需要通过global来获取；

在ES11中对获取全局对象进行了统一的规范：globalThis

```js
console.log(globalThis)
```

## 78. ES11 - for..in标准化

在ES11之前，虽然很多浏览器支持for...in来遍历对象类型，但是并没有被ECMA标准化，在ES11中，对其进行了标准化，for...in是用于遍历对象的key的。

```js
let obj = {
    name: "wc",
    age: 18,
    height: 1.88
}
for (let key in obj) {
    console.log(key)
}
```

## 79. ES12 - logical assignment operators

```js
 // 赋值运算符
 // const foo = "xq"
 let counter = 100
 counter = counter + 100
 counter += 50

 // 逻辑赋值运算符
 function foo(message) {
     // 1.||逻辑赋值运算符
     // message = message || "默认值"
     // message ||= "默认值"

     // 2.??逻辑赋值运算符
     // message = message ?? "默认值"
     message ?? = "默认值"

     console.log(message)
 }

 foo("wc")
 foo()

 // 3.&&逻辑赋值运算符
 let obj = {
     name: "wc",
     running: function() {
         console.log("running~")
     }
 }

 // 3.1.&&一般的应用场景
 // obj && obj.running && obj.running()
 // obj = obj && obj.name
 obj && = obj.name
 console.log(obj)
```

## 80. ES13 - method .at()

字符串、数组的at方法，它们是作为ES13中的新特性加入的。

## 81. ES13 - Object.hasOwn(obj, propKey)

Object中新增了一个静态方法（类方法）： hasOwn(obj, propKey), 方法用于判断一个对象中是否有某个自己的属性；

**和之前学习的Object.prototype.hasOwnProperty有什么区别呢**
* 区别一：防止对象内部有重写hasOwnProperty
* 区别二：对于隐式原型指向null的对象， hasOwnProperty无法进行判断

```js
 const obj = {
     name: "wc",
     age: 18,
     // 防止对象中也有一个自己的hasOwnProperty方法
     hasOwnProperty: function() {
         return "ok"
     },
     __proto__: {
         address: "bj"
     }
 }

 console.log(obj.name, obj.age)
 console.log(obj.address)

 console.log(obj.hasOwnProperty("name"))
 console.log(obj.hasOwnProperty("address"))

 console.log(Object.hasOwn(obj, "name"))
 console.log(Object.hasOwn(obj, "address"))

 // 和hasOwnProperty的区别二:
 const info = Object.create(null)
 info.name = "wc"
 // console.log(info.hasOwnProperty("name"))
 console.log(Object.hasOwn(info, "name"))
```

## 82. ES13 - New members of classes

在ES13中，新增了定义class类中成员字段（field）的其他方式：
* Instance public fields
* Static public fields
* Instance private fields
* static private fields
* static block

```js
 class Person {
     // 实例属性
     // 对象属性: public 公共 -> public instance fields
     height = 1.88

     // 对象属性: private 私有: 潜规则
     // _intro = "name is wc"

     // ES13对象属性: private 私有: 潜规则
     #intro = "name is wc"

     // 2.类属性(static)
     // 类属性: public
     static totalCount = "1000万"

     // 类属性: private
     static #maleTotalCount = "1000万"

     constructor(name, age) {
         // 对象中的属性: 在constructor通过this设置
         this.name = name
         this.age = age
         this.address = "bj"
     }

     // 3.静态代码块
     static {
         console.log("Hello World")
         console.log("Hello Person")
     }
 }

 const p = new Person("wc", 18)
 console.log(p)
 console.log(p.name, p.age, p.height, p.address, p.#intro)
 console.log(Person.#maleTotalCount)
```

## 83. 最早解决异步

**JS中的代码，分两类**
* 同步代码
    - 我们写的绝大代码都是从上到下执行的，也就是说代码的书写顺序和代码的执行顺序是一样的，这样的代码是同步代码，也就说，你看到的98%的代码都是同步代码。
* 异步代码
    - 还有一部分代码，是异步代码，异步代码的书写顺序和代码的执行顺序不一样，这样的代码很少，我们学一类，说一类，前面学的定时器，就是异步代码。

**最早解决异步**

```html
<script>
    // 最早解决异步问题：靠回调函数
    // 1.设计这样的一个函数
    function execCode(counter, successCallback, failureCallback) {
        // 异步任务
        setTimeout(() => {
            if (counter > 0) { // counter可以计算的情况 
                let total = 0
                for (let i = 0; i < counter; i++) {
                    total += i
                }
                // 在某一个时刻只需要回调传入的函数
                successCallback(total)
            } else { // 失败情况, counter有问题
                failureCallback(`${counter}值有问题`)
            }
        }, 3000)
    }
    // 2.ES5之前,处理异步的代码都是这样封装
    execCode(100, (value) => {
        console.log("本次执行成功了:", value)
    }, (err) => {
        console.log("本次执行失败了:", err)
    });
</script>
```

## 84. Promise介绍

**Promise是ES6中的一个类，翻译是承诺，许诺的意思。**

* new Promise就可以得到一个对象，new Promise时，需要传入一个回调函数，这个回调函数是立即执行，叫执行器，这个执行器中有两个参数，分别是resolve和reject，在执行器，可以写代码代码，代码如下：

```html
<script>
    // p叫promise对象
    // 手写promise
    // 当new Promise时，执行器会立即执行
    // Promise有三个状态  当new出来时，是处于等状态
    // 调用resolve可以把等待状态的promise变成成功态
    // 调用reject可以把等待状态的promise变成失败态
    // 一个promise只能从等待到成功或从等待到失败
    let p = new Promise((resolve, reject) => {
        console.log("我是执行器，我立即执行了...");
        // 在执行器中通常写异步代码
        // 我们说的异步指的是定时器中的回调函数
        setTimeout(() => {
            // console.log("我是定时器");
            // 在异步代码中，可以调用resovle或reject
            // resolve,reject是一个函数
            // resolve中的值，就是成功的值，也就是终值  value
            // resolve("包包"); // 就是把等待的promise变成成功的promise

            // reject中的值，就是失败的值，也就是失败的原因  reason
            reject("没钱"); // 就是把等待的promise变成失败的promise
        }, 3000)
    });
</script>
```

**Promise有三种状态:**
* 等待状态：pending   默认你创建出来的promise是处于等待状态
* 成功状态：fulfulled   当调用resolve时，就可以把promise从等待变成成功
* 失败状态：rejected   当调用reject时，就可以把promise从等待变成失败

**一个函数可以返回一个promise，如下：**

```html
<script>
    // Promise解决异步问题
    function execCode(counter) {
        let promise = new Promise((resolve, reject) => {
            // 异步任务
            setTimeout(() => {
                if (counter > 0) { // counter可以计算的情况 
                    let total = 0
                    for (let i = 0; i < counter; i++) {
                        total += i
                    }
                    // 成功的回调
                    resolve(total)
                } else { // 失败情况, counter有问题
                    // 失败的回调
                    reject(`${counter}有问题`)
                }
            }, 3000)
        })
        return promise;
    }
    let promise = execCode(100)
    promise.then(result => {
        console.log(result);
    }, err => {
        console.log(err);
    })
</script>
```

## 85. Promise系统掌握之resolve的实参问题

```html
<script>
    // resolve的实参问题
    const p = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p的resolve")
            reject("没钱")
        }, 2000)
    })
    const promise = new Promise((resolve, reject) => {
        // 1）参数是普通的数据
        // resolve(["a","b","c"])

        // 2）参数是promise 
        // 如果resolve的参数是promise，最终结果由p决定
        // resolve(p)

        // 3）参数是thenable(就是一个对象中有一个then函数)
        resolve({
            then: function(resolve, reject) {
                // resolve("包包")
                reject("没钱")
            }
        })
    });

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
    })
</script>
```

## 86. Promise系统掌握之then函数

```html
<script>
    // then函数
    const promise = new Promise((resolve, reject) => {
        resolve("success")
        // reject("error")
    });

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
    })

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
    })

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
    })
</script>
```

## 87. Promise系统掌握之then函数的返回值

**then方法是有返回值的，它返回一个新的promise，只要你敢then，就返回一个新的promise。现在我们需要研究新的promsie是成功的还是失败的，新的promise是成功的还是失败的，取决于上一个then做了什么，当上一个then方法中的回调函数在执行时，新promise处于等待状态，当上一个then返回一个结果时，那这个结果就决定了新的promise的状态，情况有下面四种：**
* 上一个then返回一个普通的值（包含und）  新的promise是成功的promsie
* 上一个then返回一个promise
* 上一个then返回一个thenable值
* 上一个then抛出一个错误

```html
<script>
    // then函数的返回值问题
    const promise = new Promise((resolve, reject) => {
        resolve("success")
    });

    // then函数需要返回一个新的promise
    promise.then(res => {
        console.log(res);
        // 这里没有返回值，默认返回und  
        // 如果返回一个普通值 整体的promise就是一个成功的promise 终值是这个普通值  包括und
        // return "hello"
        // return 123;
    }, err => {
        console.log(err);
    }).then(res => {
        console.log("res:", res);
    }, err => {
        console.log("err:", err);
    })
</script>
```

```html
<script>
    const p = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("OK~")
            reject("BAD~")
        }, 2000)
    })

    // then函数的返回值问题
    const promise = new Promise((resolve, reject) => {
        resolve("success")
    });

    promise.then(res => {
        console.log(res);
        // 如果返回的是一个promise，整体promise的结果取决于你返回的promise的状态
        return p;
    }, err => {
        console.log(err);
    }).then(res => {
        console.log("res:", res);
    }, err => {
        console.log("err:", err);
    })
</script>
```

```html
<script>
    // then函数的返回值问题
    const promise = new Promise((resolve, reject) => {
        resolve("success")
    });

    promise.then(res => {
        console.log(res);
        // 如果返回thenable，整体的promise取决于thenable的状态
        return {
            then: function(resolve, reject) {
                // resolve("包包")
                reject("没钱")
            }
        };
    }, err => {
        console.log(err);
    }).then(res => {
        console.log("res:", res);
    }, err => {
        console.log("err:", err);
    })
</script>
```

## 88. Promise系统掌握之then的顺延

```html
<script>
    // then的顺延
    const promise = new Promise((resolve, reject) => {
        resolve("success")
    });

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
    }).then(null, err => {
        console.log("err:", err);
    }).then(res => {
        console.log("res:", res);
    })
</script>
```

```html
<script>
    // then的顺延
    const promise = new Promise((resolve, reject) => {
        reject("bad")
    });

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
        // 这里返回了und  就意味着新的promise是成功的
        // new Error("我错了")  就意味着新的promise是失败的
        throw new Error("我错了")
    }).then(res => {
        console.log("res:", res);
    }, null).then(null, err => {
        console.log("err:", err);
    })
</script>
```

```html
<script>
    // then的顺延
    const promise = new Promise((resolve, reject) => {
        reject("bad")
    });

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
        throw new Error("我错了")
    }).then(res => {
        console.log("res:", res);
    }).catch(err => {
        console.log("err:", err);
    })
</script>
```

## 89. Promise系统掌握之finally

**在ES9中，新增了finally方法，无论promise是成功的，还是失败的，最终都会执行finally**

* 代码如下：

```html
<script>
    // finally
    const promise = new Promise((resolve, reject) => {
        reject("bad")
    });

    promise.then(res => {
        console.log(res);
    }, err => {
        console.log(err);
        throw new Error("我错了")
    }).then(res => {
        console.log("res:", res);
    }).catch(err => {
        console.log("err:", err);
    }).finally(() => {
        console.log("哈哈哈哈")
        console.log("呵呵呵呵")
    })
</script>
```

## 90. Promise系统掌握之类方法(静态方法)

前面学习的then，catch，finally都是promise实例上的方法，其实在Promise这个类上面，还有一些，这些方法，叫静态方法，代码如下：

```html
<script>
    // 类方法(静态方法)
    const promise = Promise.resolve("hello")

    promise.then(res => {
        console.log("then结果:", res)
    })
    // 相当于
    // new Promise((resolve) => {
    //   resolve("hello")
    // })
</script>
```

```html
<script>
    // 类方法(静态方法)
    const promise = Promise.reject("rejected error")
    promise.catch(err => {
        console.log("err:", err)
    })

    // 相当于
    // new Promise((_, reject) => {
    //   reject("rejected error")
    // })
</script>
```

```html
<script>
    // 类方法(静态方法) all

    // 创建三个Promise
    const p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p1 resolve")
            reject("p1 reject error")
        }, 3000)
    })

    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p2 resolve")
            reject("p2 reject error")
        }, 2000)
    })

    const p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("p3 resolve")
        }, 5000)
    })

    // 类方法(静态方法) all
    // all的作用：所有promise都成功后，得到所有成功后的promise结果
    //    如果有一个先失败了，直接得到最先失败promise的结果
    Promise.all([p1, p2, p3]).then(res => {
        // ['p1 resolve', 'p2 resolve', 'p3 resolve']
        console.log(res);
    }).catch(err => {
        console.log(err);
    })
</script>
```

```html
<script>
    // 类方法(静态方法) allSettled

    // 创建三个Promise
    const p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p1 resolve")
            reject("p1 reject error")
        }, 3000)
    })

    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p2 resolve")
            reject("p2 reject error")
        }, 2000)
    })

    const p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("p3 resolve")
        }, 5000)
    })

    // 类方法: allSettled
    // [
    //     {
    //         "status": "fulfilled",
    //         "value": "p1 resolve"
    //     },
    //     {
    //         "status": "fulfilled",
    //         "value": "p2 resolve"
    //     },
    //     {
    //         "status": "fulfilled",
    //         "value": "p3 resolve"
    //     }
    // ]   
    // allSettled  获取所有的promise的结果，不管成功还是失败
    Promise.allSettled([p1, p2, p3]).then(res => {
        console.log("all settled:", res)
    })
</script>
```

```html
<script>
    // 创建三个Promise
    const p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p1 resolve")
            reject("p1 reject error")
        }, 3000)
    })

    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p2 resolve")
            reject("p2 reject error")
        }, 2000)
    })

    const p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("p3 resolve")
        }, 5000)
    })
    // 类方法: race方法    race是比赛的意思
    // 特点: 会等到第一个Promise有结果(无论这个结果是fulfilled还是rejected)
    Promise.race([p1, p2, p3]).then(res => {
        console.log("race promise:", res)
    }).catch(err => {
        console.log("race promise err:", err)
    })
</script>
```

```html
<script>
    // 类方法: any方法

    // 创建三个Promise
    const p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p1 resolve")
            reject("p1 reject error")
        }, 3000)
    })
    const p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("p2 resolve")
            // reject("p2 reject error")
        }, 2000)
    })
    const p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            // resolve("p3 resolve")
            reject("p3 reject error")
        }, 5000)
    })
    // 类方法: any方法
    //  any 返回第1个成功的  或者  返回所有都失败了
    Promise.any([p1, p2, p3]).then(res => {
        console.log("any promise res:", res)
    }).catch(err => {
        console.log("any promise err:", err)
    })
</script>
```

## 91. 认识async函数

* async是一个关键字，用于声明一个异步函数，async是asynchronous简写，是异步的意思。

* sync是synchronous简写，是同步的意思。

```html
<script>
    // 普通函数
    // function foo() { }
    // const bar = function () { }
    // const baz = () => { }

    // 生成器函数
    // function* foo() { }

    // 异步函数
    async function foo() {
        console.log("foo function1")
        console.log("foo function2")
        console.log("foo function3")
    }
    // async返回promise
    let res = foo();
    console.log(res);

    let gn = async function() {};
    let kn = async () => {};
    class Person {
        async running() {}
    }
</script>
```

## 92. async函数的返回值

**异步函数的结果永远都是promise**

异步函数内部代码的执行过程和普通函数是一样的，默认也是同步执行。异步函数和普通函数的区别，如下：
* 异步函数可以有返回值，但是不管返回什么普通值，都会包裹在Pormise.resolve中
* 如果异步函数自己返回了promise，得到的Promies状态由这个promise决定
* 如果我们异步函数返回值是一个对象并且实现thenable，得到的Promies状态由then方法中做了什么才能决定
* 如果在async函数中抛出一个错误，得到的promise是一个失败的promsie

```html
<script>
    async function foo() {
        console.log("foo function1")
        console.log("foo function2")
        console.log("foo function3")
        // 1)返回普通值，promis是成功的promsie
        // return 123;

        // 2)返回promise   res这个promise是成功还是失败，取决于你返回的promise是成功还是失败
        // return new Promise((resolve, reject)=>{
        //     setTimeout(()=>{
        //         resolve("hello")
        //     },2000)
        // })

        // 3)返回thenable  res这个promise是成功还是失败，取决于你返回的thenable是成功还是失败
        return {
            then: function(resolve, reject) {
                reject("没钱~")
            }
        }
    }

    let res = foo();
    res.then(res => {
        console.log("res:", res);
    }).catch(err => {
        console.log("err:", err);
    })
</script>
```

## 93. async函数有异常

```html
<script>
    // 在async函数中，如果抛出一个错误，res这个promise是失败的promise
    async function foo() {
        console.log("foo function1")
        console.log("foo function2")
        console.log("foo function3")
        throw new Error("我是异常")
    }

    let res = foo();
    res.then(res => {
        console.log("res:", res);
    }).catch(err => {
        console.log("err:", err);
    })
</script>
```

## 94. awati的使用

**async关键字可以单独使用，在异步函数内部可以使用await关键字，但是在普通函数中不能使用await关键字，await关键字有什么作用？**
* await后面跟一个表达式，这个表达式普通是一个promise
* 这个await可以等待它后面的promise成功后，拿到成功的结果，得到之后，才会执行后面的代码。

**await后面跟不同的数据：**
* 如果await后面跟一个普通值，那么会直接返回这个值。
* 如果await后面跟一个thenable对象，那么要看你这个thenable中的then做了什么。
* 如果await后面的promise是失败的，需要通过try catch来获取失败的结果。

```html
<script>
    // await后面跟一个普通值
    // function fn(){
    //     await 123
    // }
    // SyntaxError: await is only valid in async functions and the top level bodies of modules
    // fn();

    // awati 1）必须写在async函数中  2）await后面通常是跟一个promsie
    //       3）await前面就可以获取promise成功的结果
    async function gn() {
        let rs = await 123
        console.log("rs:", rs); // 123
        // 返回一个und 
    }
    gn().then(res => {
        console.log("res:", res);
    })
</script>
```

## 95. await后面通常跟promise

```html
<script>
    function bar() {
        console.log("bar function")
        return new Promise(resolve => {
            setTimeout(() => {
                resolve(123)
            }, 2000)
        })
    }
    async function foo() {
        // await后续返回一个Promise, 那么会等待Promise有结果之后, 才会继续执行后续的代码
        // await下面的代码相当于一个.then  
        const res1 = await bar()
        console.log("await后面的代码:", res1)
        const res2 = await bar()
        console.log("await后面的代码:", res2)
    }

    foo()
</script>
```

## 96. 使用async+await处理异常问题

```html
<script>
    function requestData(url) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(url)
                // reject("error message")
            }, 2000);
        })
    }

    async function getData() {
        const res1 = await requestData("001")
        console.log("res1:", res1)
        const res2 = await requestData(res1)
        console.log("res2:", res2)
        const res3 = await requestData(res2)
        console.log("res3:", res3)
        return res3
    }
    getData().then(res => {
        console.log(res);
    })
</script>
```

## 97. 说一下，什么是浏览器事件环

**进程：**
* 计算机已经运行直来的程序，是操作系统操作程序的一种方式。当一个软件运行起来后，就是一个进程，电脑上可以运行很多软件，在OS上，有很多的进程，进程是OS分配资源（CPU和内存）的基本单位。OS可以当在一个工厂，一个个的车间就是进程。

**线程：**
* 操作系统能够运行运算调度的最小单位，一个进程中，至少要包含一个线程，用来执行程序中的代码，这个线程叫主线程，线程才是真正干活的，类似于工厂中的工人。一个车间如果只有一个工人，就是单线程，如果一个车间中有N个工人，就是多线程。

**浏览器是多进程的：**
* 浏览器是一个多进程的软件，一个选项卡，就是一个进程，进程之间一般是独立的。在每一个进程中，包含了很多的线程，其中就包括JS代码执行线程。执行JS代码的线程就一个，也就是说，同一个时刻，只能做一件事，那么我们就说JS是单线程的。如果遇到了一个非常耗时的任务，线程就阻塞，此时，JS的主线程不会等待，浏览器会开一些其它线程去执行耗时任务，小线程执行的结果，就通过回调函数告诉主线程，我们说的JS是单线程的，是指主线程是单线程的，浏览器内部还可以开一些其它线程，如定时器线程，如ajax数据请求线程。

**异步代码分两类：**
* 宏任务：ajax，setTimeout，setInterval，DOM事件监听，UI渲染....
* 微任务：promies中的then回调  Mutaion Observer ...

**JS代码的执行顺序：**
1. 从代码段开始执行
2. 如果遇到一个宏任务，会把这个任务放到一个宏任务队列，如果遇到一个微任务，就把这个微任务放到微任务任务中。
3. 当同步代码执行完毕后，先去清空微任务队列。
4. 当微任务队列清空完毕后，从宏任务队列中取出一个宏任务，去执行，在执行过程中，你的宏任务中可能还有同步代码或宏任务或微任务，重复上面的步骤，执行完一个宏任务，肯定要清空微任务队列。

## 98. 事件环相关的面试题

```html
<script>
    console.log(1)
    setTimeout(() => {
        console.log(2)
        Promise.resolve().then(() => {
            console.log(3)
        })

    })
    setTimeout(() => {
        console.log(4)
        Promise.resolve().then(() => {
            console.log(5)
        })
    })
    Promise.resolve().then(() => {
        console.log(6)
    })
</script>
```

```html
<script>
    console.log('script start');
    setTimeout(function() {
        console.log('setTimeout');
    }, 0);
    Promise.resolve()
        .then(function() {
            console.log('promise1');
        })
        .then(function() {
            console.log('promise2');
        });

    console.log('script end');
</script>
```

```html
<script>
    setTimeout(function() {
        console.log("setTimeout1");
        new Promise(function(resolve) {
            resolve();
        }).then(function() {
            new Promise(function(resolve) {
                resolve();
            }).then(function() {
                console.log("then4");
            });
            console.log("then2");
        });
    });

    new Promise(function(resolve) {
        console.log("promise1");
        resolve();
    }).then(function() {
        console.log("then1");
    });

    setTimeout(function() {
        console.log("setTimeout2");
    });

    console.log(2);

    new Promise(function(resolve) {
        resolve();
    }).then(function() {
        console.log("then3");
    });
</script>
```

```html
<script>
    async function bar() {
        console.log("22222")
        return new Promise((resolve) => {
            resolve()
        })
    }

    async function foo() {
        console.log("111111")

        await bar()

        console.log("33333")
    }

    foo()
    console.log("444444")
</script>
```

```html
<script>
    async function async1() {
        console.log('async1 start')
        await async2();
        console.log('async1 end')
    }

    async function async2() {
        console.log('async2')
    }

    console.log('script start')

    setTimeout(function() {
        console.log('setTimeout')
    }, 0)

    async1();

    new Promise(function(resolve) {
        console.log('promise1')
        resolve();
    }).then(function() {
        console.log('promise2')
    })

    console.log('script end')
</script>
```

```html
<script>
    Promise.resolve().then(() => {
        console.log(0);
        return 4
    }).then((res) => {
        console.log(res)
    })

    Promise.resolve().then(() => {
        console.log(1);
    }).then(() => {
        console.log(2);
    }).then(() => {
        console.log(3);
    }).then(() => {
        console.log(5);
    }).then(() => {
        console.log(6);
    })
</script>
```

```html
<script>
    let start = Date.now();
    for (let i = 0; i < 10000000000; i++) {}
    console.log("哈哈")
    let end = Date.now();
    console.log((end - start) / 1000);

    setTimeout(() => {
        console.log("111")
    }, 10000);

    let start1 = Date.now();
    for (let i = 0; i < 10000000000; i++) {}
    console.log("呵呵")
    let end1 = Date.now();
    console.log((end1 - start1) / 1000);

    // while(true){}
</script>
```
