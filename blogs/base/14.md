---
title: 14-vue3精讲
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 一，Vue3互动教程

### 1，Vue3介绍

Vue3文档地址：https://cn.vuejs.org/

![1699319502119](./assets/1699319502119.png)

Vue特点：

![1699319344915](./assets/1699319344915.png)

易学易用

* API设计简单，好上手，也是Vue很火的原因

性能出色

* proxy，精准更新，diff算法....

灵活多变

* 渐进式，可大可小的项目都可以做，可以逐步集成很多第三方的依赖

**你是如何理解vue2？**

* vue是数据驱动视图（响应式原理）
* vue2是选项式API（一堆的选项）
* 组件化开发（自定义属性，自定义事件，自定义插槽，选项式API，组件通信）
* 十几个指令（内置指令），指令的本质是对DOM操作的封装......
* 五大内置组件（slot, transition, component, keep-alive, transition-group）
* 复用技巧（组件，混入，过滤器，自定义指令，插件，原型链....）
* 图：组件的生命周期图，MVVM图，Vuex图，响应式原理图...

**技术栈官网**

* 技术栈：Vue3+VueRouter4+Pinia2+Vant3/ElementPlus
* 1、Vue3官网：https://vuejs.org/
* 2、VueRouter(V4)：https://router.vuejs.org/
* 3、Pinia(V2)：https://pinia.vuejs.org/
* 4、Vite构建工具：https://vitejs.dev/
* 5、ElementPlus：https://element-plus.gitee.io/zh-CN/
* 6、Vant(v3)：https://vant-contrib.gitee.io/vant/#/zh-CN

### 2，创建Vue3项目

命令：

```shell
 npm create vue@latest
```

演示一下：

![1699319779878](./assets/1699319779878.png)

进入项目，安装依赖，运行项目，如下：

![1699319872862](./assets/1699319872862.png)

运行起来后如下：

![1699319902200](./assets/1699319902200.png)

浏览器测试之，如下：

![1699319930580](./assets/1699319930580.png)

使用vscode打开项目，如下：

![1699320068173](./assets/1699320068173.png)

目录分析：

* vite.config.js 是Vite官方配置文件，各种配置参考Vite官网。
* index.html 是SPA挂载的根页面
* main.js 是入口文件
* App.vue 是根组件（SFC单文件组织）
* src 文件夹 是源码目录
  + views 放路由级别的组件
  + compoents 放通用组件
  + router 放路由相关的
  + store 放仓库相关的
  + api  封装API接口相关的
  + utils 放工具函数

在开发Vue3，在VSCode中还需要安装插件，如下：

![1699320280610](./assets/1699320280610.png)

项目创建完毕了，然后就要学习知识点了，看文档，如下：

![1699320354204](./assets/1699320354204.png)

互动教程，如下：

![1699320563175](./assets/1699320563175.png)

### 3，声明式渲染

**四种语法范式：**

* 选项式写法：完成支持Vue2写法，我们之前学习的Vue2的写法就是选项式写法
* 组合式写法：只使用setup()，把组合式API写在setup中就是组合式写法
* 选项式+组合式写法：可以使用setup()+选项式写法
* 组合式语法糖写法：在script标签上添加setup，只支持组合式写法，规避选项式写法。

**选项式写法：**

![1699320903861](./assets/1699320903861.png)

参考代码：

```vue
<template>
  <h1>选项式API写法</h1>
  <h1 v-text="num"></h1>
  <button @click="add">+1</button>
</template>

<script>
export default {
  data() {
    return {
      num: 0,
    };
  },
  methods: {
    add() {
      this.num++;
    },
  },
};
</script>

<style scoped>
</style>
```

**组合式写法:(了解)**

![1699321265052](./assets/1699321265052.png)

参考代码：

```vue
<template>
  <h1>选项式API写法</h1>
  <h1 v-text="num"></h1>
  <button @click="add">+1</button>
</template>

<script>
// ref是组合式API
import { ref } from "vue";

export default {
  // Vue3的选项写法：对Vue2范式完全兼容，可以同时使用setup和选项，也可只使用setup。
  // 官方已经不推荐使用这种选项写法了。选项写法，都有对应的组合API来实现。
  // 解读setup这个选项：相当于Vue2中的created()，可以理解成是组件生命周期的第一阶段；setup(props,context)，context表示上下文，为什么在setup中要有一个上下文对象，因为在setup选项中没有this。
  setup(props, context) {
    // setup是组合式API的入口
    const num = ref(1);

    //num是调用ref函数之后的结果，它是一个对象
    // 不能直接num++  num.value才是响应式数据的值
    // 在模板中，它会自动的.value
    const add = () => {
      num.value++;
    };

    return {
      num,
      add,
    };
  },
};
</script>

<style scoped>
</style>
```

**选项式和组合式混写：（了解）**

![1699321391844](./assets/1699321391844.png)

参考代码：

```vue
<template>
  <h1>选项式+组合式API写法</h1>
  <h1 v-text="num"></h1>
  <button @click="add">+1</button>
</template>

<script>
import { ref } from "vue";
// 非常不推荐这种写法
export default {
  // 组合选项
  setup(props, context) {
    const num = ref(1);
    return {
      num,
    };
  },
  methods: {
    add() {
      this.num++;
    },
  },
};
</script>
```

**组合式语法糖写法(推荐):**

![1699321525653](./assets/1699321525653.png)

参考代码：

```vue
<template>
  <h1>组合式语法糖写法</h1>
  <h1 v-text="num"></h1>
  <button @click="add">+1</button>
</template>

<script setup>
import { ref } from "vue";

const num = ref(10);

const add = () => {
  num.value++;
};
</script>
```

官方文档教程，如下：

![1699321956969](./assets/1699321956969.png)

![1699322224789](./assets/1699322224789.png)

### 3，Atribute绑定

试着把一个动态的 `class` 绑定添加到这个 `<h1>` 上，并使用 `titleClass` 的 ref 作为它的值。如果绑定正确，文字将会变为红色。代码如下：

![1699323515723](./assets/1699323515723.png)

### 5，表单绑定与双向绑定

直接上代码：

![1699323880372](./assets/1699323880372.png)

![1699323988089](./assets/1699323988089.png)

什么是双向绑定？什么是单向绑定？

* 单向绑定：数据驱动视图，通过ref或reactive定义的响应式数据，数据发生变化时，模板会自动刷新。
* 双向绑定：数据驱动视图，视图驱动数据。    v-model=@input + :value

### 6，条件渲染

直接看文档，如下：

![1699324400366](./assets/1699324400366.png)

### 7，列表渲染

直接写todo案例，如下：

![1699325052186](./assets/1699325052186.png)

参考代码：

```vue

<template>
  <form @submit.prevent="addTodo">
    <input type="text" v-model="newTodo" />
    <!-- <button @click="addTodo">Add Todo</button> -->
    <button>Add Todo</button>
  </form>
  <ul>
    <li v-for="todo in todos" :key="todo.id">
      {{ todo.text }}
      <button @click="removeTodo(todo)">X</button>
    </li>
  </ul>
</template>

<script setup>
import { ref, reactive } from "vue";

let id = 0; // 给每个 todo 对象一个唯一的 id

const newTodo = ref("");
const todos = ref([
  { id: id++, text: "Learn HTML" },
  { id: id++, text: "Learn JavaScript" },
  { id: id++, text: "Learn Vue" },
]);

const removeTodo = (todo) => {
  // console.log("todo:",todo.id);
  let idx = todos.value.findIndex(item=>item.id === todo.id);
  todos.value.splice(idx,1)
};

const addTodo = () => {
  if (!newTodo.value.trim().length) return alert("输入框不能为空~"); 
  todos.value.push({ id: id++, text: newTodo.value });
  newTodo.value = "";
};
</script>
```

为什么 key的值不能为索引？

### 8，计算属性

计算属性就是根据已有的状态，计算出一个新的状态。我们可以把模板中的复杂计算抽离到计算属性中，让模板看上去更优雅。计算属性有缓存，当计算属性依赖的状态发生了变化，才会重新计算。

官方写的：

* 计算属性会自动跟踪其计算中所使用的到的其他响应式状态，并将它们收集为自己的依赖。计算结果会被缓存，并只有在其依赖发生改变时才会被自动更新。

总结：

* 计算属性有缓存的特性。
* 只有它依赖的状态，变化的空间不大，计算属性的收益更高

直接上官方的案例：

![1699326104336](./assets/1699326104336.png)

参考代码：

```vue

<template>
  <form @submit.prevent="addTodo">
    <input type="text" v-model="newTodo" />
    <button>Add Todo</button>
  </form>
  <ul>
    <li v-for="todo in filterTodos" :key="todo.id">
      <input type="checkbox" v-model="todo.done" />
      <span :class="{ done: todo.done }"> {{ todo.text }}</span>
      <button @click="removeTodo(todo)">X</button>
    </li>
  </ul>
  <button @click="hideCompleted = !hideCompleted">
    {{ hideCompleted ? "Show all" : "Hide completed" }}
  </button>
</template>

<script setup>
import { ref, reactive, computed } from "vue";

let id = 0; // 给每个 todo 对象一个唯一的 id

const hideCompleted = ref(false);
const newTodo = ref("");
const todos = ref([
  { id: id++, done: true, text: "Learn HTML" },
  { id: id++, done: true, text: "Learn JavaScript" },
  { id: id++, done: false, text: "Learn Vue" },
]);

const filterTodos = computed(() => {
  if (!hideCompleted.value) {
    return todos.value;
  }
  if (hideCompleted.value) {
    return todos.value.filter((todo) => {
      return !todo.done;
    });
  }
});

const removeTodo = (todo) => {
  // console.log("todo:",todo.id);
  let idx = todos.value.findIndex((item) => item.id === todo.id);
  todos.value.splice(idx, 1);
};

const addTodo = () => {
  if (!newTodo.value.trim().length) return alert("输入框不能为空~");
  todos.value.push({ id: id++, text: newTodo.value });
  newTodo.value = "";
};
</script>

<style>
.done {
  text-decoration: line-through;
}
</style>
```

### 9，生命周期与模板引用

目前为止，Vue 为我们处理了所有的 DOM 更新，这要归功于响应性和声明式渲染。然而，有时我们也会不可避免地需要手动操作 DOM。

这时我们需要使用**模板引用**——也就是指向模板中一个 DOM 元素的 ref。直接上代码：

![1699327596784](./assets/1699327596784.png)

参考代码：

```vue
<template>
  <!-- 此处的ref和我们讲面讲的ref含义是不一样的 -->
  <p ref="p">hello</p>
</template>

<script setup>
// 在vue3中生命周期函数都是组合式API
// 都是以on打头
import { ref, onMounted } from "vue";

const p = ref(null);

onMounted(()=>{
  // 此时组件已经挂载。
  console.log(p.value);
  p.value.textContent = 'mounted!'
});
</script>
```

### 10，侦听器

直接上代码：

![1699327820553](./assets/1699327820553.png)

直接官方的案例：

![1699328151795](./assets/1699328151795.png)

参考代码：

```vue
<template>
  <p>Todo id: {{ todoId }}</p>
  <button @click="todoId++">Fetch next todo</button>
  <p v-if="!todoData">Loading...</p>
  <pre v-else>{{ todoData }}</pre>
</template>

<script setup>
import { ref, watch } from "vue";

const todoId = ref(1);
const todoData = ref(null);

async function fetchData() {
  todoData.value = null;
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  );
  todoData.value = await res.json();
}

fetchData();

watch(todoId, fetchData);
</script>
```

### 11，组件

组件的使用，如下：

![1699328331139](./assets/1699328331139.png)

### 12，Props

子组件可以通过 props 从父组件接受动态数据。

直接上代码：

![1699328701895](./assets/1699328701895.png)

### 13，Emits

vue是单向数据流，什么叫单向数据流？props只能从上到下流。如果想把数据从子流到父，方式有：

* 给子传递一个方法，子去调用方法
* 通过自定义事件

在vue2中，自定义事件不需要接收，在vue3中自定义事件也需要接收，如下：

![1699329308632](./assets/1699329308632.png)

![1699329424228](./assets/1699329424228.png)

### 14，Slot

参考文档：https://cn.vuejs.org/tutorial/#step-14

## 二，实现TodoMVC

### 1，静态页面

todo.html，如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./index.css">
    <title>Document</title>
</head>

<body>
    <section class="todoapp">
        <header class="header">
            <h1>todos</h1>
            <input class="new-todo" autofocus autocomplete="off" placeholder="What needs to be done?" />
        </header>
        <section class="main">
            <input id="toggle-all" class="toggle-all" type="checkbox" />
            <label for="toggle-all">Mark all as complete</label>
            <ul class="todo-list">
                <!-- :class="{ completed: item.done }" -->
                <li class="todo">
                    <div>
                        <input class="toggle" type="checkbox" />
                        <label>学习vue</label>
                        <button class="destroy"></button>
                    </div>
                    <input class="edit" type="text" style="display: none;" />
                </li>
            </ul>
        </section>
        <footer class="footer">
            <span class="todo-count"> <strong></strong> 1 item left </span>
            <ul class="filters">
                <li><a href="">All</a>
                </li>
                <li><a href="">Active</a>
                </li>
                <li>
                    <!-- :class="{ selected: visibility == 'Completed'} -->
                    <a href="">Completed</a>
                </li>
            </ul>
            <button class="clear-completed">
                Clear completed
            </button>
        </footer>

    </section>
</body>

</html>
```

todo.css 代码如下：

```css
html,
body {
    margin: 0;
    padding: 0;
}

button {
    margin: 0;
    padding: 0;
    border: 0;
    background: none;
    font-size: 100%;
    vertical-align: baseline;
    font-family: inherit;
    font-weight: inherit;
    color: inherit;
    -webkit-appearance: none;
    appearance: none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #f5f5f5;
    color: #4d4d4d;
    min-width: 230px;
    max-width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    font-weight: 300;
}

:focus {
    outline: 0;
}

.hidden {
    display: none;
}

.todoapp {
    background: #fff;
    margin: 130px 0 40px 0;
    position: relative;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),
        0 25px 50px 0 rgba(0, 0, 0, 0.1);
}

.todoapp input::-webkit-input-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp input::-moz-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp input::input-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp h1 {
    position: absolute;
    top: -155px;
    width: 100%;
    font-size: 100px;
    font-weight: 100;
    text-align: center;
    color: rgba(175, 47, 47, 0.15);
    -webkit-text-rendering: optimizeLegibility;
    -moz-text-rendering: optimizeLegibility;
    text-rendering: optimizeLegibility;
}

.new-todo,
.edit {
    position: relative;
    margin: 0;
    width: 100%;
    font-size: 24px;
    font-family: inherit;
    font-weight: inherit;
    line-height: 1.4em;
    border: 0;
    color: inherit;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.new-todo {
    padding: 16px 16px 16px 60px;
    border: none;
    background: rgba(0, 0, 0, 0.003);
    box-shadow: inset 0 -2px 1px rgba(0, 0, 0, 0.03);
}

.main {
    position: relative;
    z-index: 2;
    border-top: 1px solid #e6e6e6;
}

.toggle-all {
    text-align: center;
    border: none;
    /* Mobile Safari */
    opacity: 0;
    position: absolute;
}

.toggle-all+label {
    width: 60px;
    height: 34px;
    font-size: 0;
    position: absolute;
    top: -52px;
    left: -13px;
    -webkit-transform: rotate(90deg);
    transform: rotate(90deg);
}

.toggle-all+label:before {
    content: '❯';
    font-size: 22px;
    color: #e6e6e6;
    padding: 10px 27px 10px 27px;
}

.toggle-all:checked+label:before {
    color: #737373;
}

.todo-list {
    margin: 0;
    padding: 0;
    list-style: none;
}

.todo-list li {
    position: relative;
    font-size: 24px;
    border-bottom: 1px solid #ededed;
}

.todo-list li:last-child {
    border-bottom: none;
}

.todo-list li.editing {
    border-bottom: none;
    padding: 0;
}

.todo-list li .edit {
    display: block;
    width: 506px;
    padding: 12px 16px;
    margin: 0 0 0 43px;
}

.todo-list li.editing .view {
    /* display: none; */
}

.todo-list li .toggle {
    text-align: center;
    width: 40px;
    /* auto, since non-WebKit browsers doesn't support input styling */
    height: auto;
    position: absolute;
    top: 0;
    bottom: 0;
    margin: auto 0;
    border: none;
    /* Mobile Safari */
    -webkit-appearance: none;
    appearance: none;
}

.todo-list li .toggle {
    opacity: 0;
}

.todo-list li .toggle+label {
    /*
		Firefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433
		IE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/
	*/
    background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E');
    background-repeat: no-repeat;
    background-position: center left;
}

.todo-list li .toggle:checked+label {
    background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E');
}

.todo-list li label {
    word-break: break-all;
    padding: 15px 15px 15px 60px;
    display: block;
    line-height: 1.2;
    transition: color 0.4s;
}

.todo-list li.completed label {
    color: #d9d9d9;
    text-decoration: line-through;
}

.todo-list li .destroy {
    display: none;
    position: absolute;
    top: 0;
    right: 10px;
    bottom: 0;
    width: 40px;
    height: 40px;
    margin: auto 0;
    font-size: 30px;
    color: #cc9a9a;
    margin-bottom: 11px;
    transition: color 0.2s ease-out;
}

.todo-list li .destroy:hover {
    color: #af5b5e;
}

.todo-list li .destroy:after {
    content: '×';
}

.todo-list li:hover .destroy {
    display: block;
}

/* .todo-list li .edit {
	display: none;
} */

.todo-list li.editing:last-child {
    margin-bottom: -1px;
}

.footer {
    color: #777;
    padding: 10px 15px;
    height: 20px;
    text-align: center;
    border-top: 1px solid #e6e6e6;
}

.footer:before {
    content: '';
    position: absolute;
    right: 0;
    bottom: 0;
    left: 0;
    height: 50px;
    overflow: hidden;
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2), filters 0 8px 0 -3px #f6f6f6,
        0 9px 1px -3px rgba(0, 0, 0, 0.2),
        0 16px 0 -6px #f6f6f6,
        0 17px 2px -6px rgba(0, 0, 0, 0.2);
}

.todo-count {
    float: left;
    text-align: left;
}

.todo-count strong {
    font-weight: 300;
}

.filters {
    margin: 0;
    padding: 0;
    list-style: none;
    position: absolute;
    right: 0;
    left: 0;
}

.filters li {
    display: inline;
}

.filters li a {
    color: inherit;
    margin: 3px;
    padding: 3px 7px;
    text-decoration: none;
    border: 1px solid transparent;
    border-radius: 3px;
}

.filters li a:hover {
    border-color: rgba(175, 47, 47, 0.1);
}

.filters li a.selected {
    border-color: rgba(175, 47, 47, 0.2);
}

.clear-completed,
html .clear-completed:active {
    float: right;
    position: relative;
    line-height: 20px;
    text-decoration: none;
    cursor: pointer;
}

.clear-completed:hover {
    text-decoration: underline;
}

.info {
    margin: 65px auto 0;
    color: #bfbfbf;
    font-size: 10px;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
    text-align: center;
}

.info p {
    line-height: 1;
}

.info a {
    color: inherit;
    text-decoration: none;
    font-weight: 400;
}

.info a:hover {
    text-decoration: underline;
}

/*
	Hack to remove background from Mobile Safari.
	Can't use it globally since it destroys checkboxes in Firefox
*/
@media screen and (-webkit-min-device-pixel-ratio:0) {

    .toggle-all,
    .todo-list li .toggle {
        background: none;
    }

    .todo-list li .toggle {
        height: 40px;
    }
}

@media (max-width: 430px) {
    .footer {
        height: 50px;
    }

    .filters {
        bottom: 10px;
    }
}
```

在项目，使用上面的静态页，如下：

![1699337982747](./assets/1699337982747.png)

浏览器效果：

![1699338015131](./assets/1699338015131.png)

### 2，拆组件

拆分如下：

![1699338051950](./assets/1699338051950.png)

TodoHeader.vue：

```vue
<template>
    <header class="header">
        <h1>todos</h1>
        <input class="new-todo" autofocus autocomplete="off" placeholder="What needs to be done?" />
    </header>
</template>
```

TodoMain.vue：

```vue
<template>
  <section class="main">
    <input id="toggle-all" class="toggle-all" type="checkbox" />
    <label for="toggle-all">Mark all as complete</label>
    <ul class="todo-list">
      <!-- :class="{ completed: item.done }" -->
      <li class="todo">
        <div>
          <input class="toggle" type="checkbox" />
          <label>学习vue</label>
          <button class="destroy"></button>
        </div>
        <input class="edit" type="text" style="display: none" />
      </li>
    </ul>
  </section>
</template>
```

TodoFooter.vue：

```vue
<template>
   <footer class="footer">
      <span class="todo-count"> <strong></strong> 1 item left </span>
      <ul class="filters">
        <li><a href="">All</a></li>
        <li><a href="">Active</a></li>
        <li>
          <!-- :class="{ selected: visibility == 'Completed'} -->
          <a href="">Completed</a>
        </li>
      </ul>
      <button class="clear-completed">Clear completed</button>
    </footer>
</template>
```

在App.vue中引用之，如下：

![1699338337151](./assets/1699338337151.png)

### 3，显示todo

在App.vue中定义状态，如下：

```vue
<template>
  <section class="todoapp">
    <todo-header></todo-header>
    <todo-main :todoList="todoList"></todo-main>
    <todo-footer></todo-footer>
  </section>
</template>

<script setup>
import { ref, reactive } from "vue";
import TodoHeader from "./components/TodoHeader.vue";
import TodoMain from "./components/TodoMain.vue";
import TodoFooter from "./components/TodoFooter.vue";

let todoList = reactive([
  { id: "01", text: "学习vue3", done: true, isEdit: false },
  { id: "02", text: "学习java", done: false, isEdit: false },
]);
</script>
```

子中接收数据，渲染数据，如下：

![1699338662759](./assets/1699338662759.png)

### 4，删除todo

绑定自定义事件，如下：

![1699338775779](./assets/1699338775779.png)

在子中触发自定义事件，并传参，如下：

![1699338884019](./assets/1699338884019.png)

父接收之，如下：

![1699338935916](./assets/1699338935916.png)

实现删除，如下：

![1699338968518](./assets/1699338968518.png)

### 5，改变单个todo的状态

绑定自定义事件，如下：

![1699339107773](./assets/1699339107773.png)

子中给checkbox绑定change方法，触发父中的自定义事件，如下：

![1699339285171](./assets/1699339285171.png)

### 6，全选和全不选

如果所有的todo都完成了，全选按钮就是需要选中，需要定义一个计算属性，如下：

![1699339431492](./assets/1699339431492.png)

子需要接收之，如下：

![1699339508697](./assets/1699339508697.png)

可以点击上面的全选按钮，实现全选与全不选，给全选按钮绑定点击事件，如下：

![1699339843302](./assets/1699339843302.png)

绑定自定义事件，如下：

![1699339867325](./assets/1699339867325.png)

测试之，如下：

![1699339900105](./assets/1699339900105.png)

剩下的不写了，不会写的参考：https://yujingbo1023.github.io/feblog/Framework/vue3/08.html

## 三，Vue3深入指南之基础

### 1，创建一个应用

创建应用代码：

```js
import {
    createApp
} from 'vue'

import App from './App.vue'

const app = createApp(App)

// #app是哪里来的？
app.mount('#app')
```

应用实例会暴露一个 `.config` 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：

![1699341867401](./assets/1699341867401.png)

应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：

![1699342022331](./assets/1699342022331.png)

应用实例并不只限于一个。 `createApp` API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。

![1699342227591](./assets/1699342227591.png)

### 2，模板表达式

渲染原始html字符串，如下：

![1699342456792](./assets/1699342456792.png)

什么是表达式？

* 任何有值的内容都是表达式
* 只要可以写在return后面的都是表达式

胡子中可以放什么？

![1699343072398](./assets/1699343072398.png)

**受限的全局访问**

模板中的表达式将被沙盒化，仅能够访问到[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3)。该列表中会暴露常用的内置全局对象，比如 `Math` 和 `Date` 。

没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 `window` 上的属性。然而，你也可以自行在 [ `app.config.globalProperties` ](https://cn.vuejs.org/api/application.html#app-config-globalproperties) 上显式地添加它们，供所有的 Vue 表达式使用。

![1699343183677](./assets/1699343183677.png)

动态绑定多个值，如下：

![1699343369833](./assets/1699343369833.png)

### 3，响应式基础

vue的响应式，书写如下的代码：

```vue
<script setup>
import { ref } from "vue";

const count = ref(0); // count实际上是对象

function inc() {
  count.value++;
}
</script>

<template>
  <h1>
    {{ count }}
  </h1>
  <h1 @click="inc">点我+1</h1>
</template>
```

看文章：

https://cn.vuejs.org/guide/extras/reactivity-in-depth.html

写代码：

![1699345275271](./assets/1699345275271.png)

手动update模型，如下：

![1699345404355](./assets/1699345404355.png)

自动update模型，如下：

![1699346202838](./assets/1699346202838.png)

参考代码：

```html
<script>
    // 只有对应才能被代理  data是原始对象，不具备响应式的
    let data = {
        A0: 1,
        A1: 2
    };

    function update(receiver) {
        A2 = receiver.A0 + receiver.A1;
        console.log("A2:", A2);
    }

    function whenDepsChange(callback) {
        let proxy_data = new Proxy(data, {
            set(target, propKey, value, receiver) {
                // 每次A0 A1发生变化会执行
                target[propKey] = value;
                callback(receiver);
            }, // target表示原始对象  propKey就是代理的key
            get(target, propKey, receiver) { // receiver是proxy对象本身
                console.log("get...");
                return target[propKey]
            }
        })
        return proxy_data;
    }

    // 代理对象  具备响应了
    let proxy_data = whenDepsChange(update);
    // console.log(proxy_data.A0);
    // console.log(proxy_data.A1);
    proxy_data.A0 = 100;

    proxy_data.A1 = 100;
</script>
```

深层响应式，如下：

![1699346857929](./assets/1699346857929.png)

有深层响应式，就有浅层响应式，如下：

https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive

DOM的更新时机，如下：

![1699347330302](./assets/1699347330302.png)

什么是代理对象？

![1699405797412](./assets/1699405797412.png)

reactive是代理对象，如下：

![1699406031524](./assets/1699406031524.png)

reactive也是深层响应式，如下：

![1699406122053](./assets/1699406122053.png)

有深层响应式，就有浅层响应式，如下：

![1699406606832](./assets/1699406606832.png)

参考代码：

```vue
<template>
  <div>
    <h1 v-text="info1.a.b.c"></h1>
    <button @click="add1">自增</button>
    <hr />
    <h1 v-text="info2.a.b.c"></h1>
    <button @click="add2">自增</button>
  </div>
</template>

<script setup>
import { ref, reactive, shallowRef, triggerRef } from "vue";

// ref是定义基本数据数据的响应式
// reactive是定义引用数据类型的响应式
// 其实ref也可以定义，如果ref中写了一人引用数据类型，它的内部还是会调用reactive
let info1 = ref({ a: { b: { c: 3 } } });
let add1 = () => {
  info1.value.a.b.c++;
};

// {a:{b:{c:3}}} 整体替换的话是响应式的，对a,b,c修改并不是响应式的
let info2 = shallowRef({ a: { b: { c: 3 } } });
let add2 = () => {
  info2.value.a.b.c++;
  // info2.value.a.b = { c: 888 };
  // info2.value.a = { b: { c: 888 } };
  // info2.value = { a: { b: { c: 888 } } };

  triggerRef(info2); // 强制刷新
};
</script>
```

我们也可以利用shallowReactive定义浅层响应式，如下：

![1699406980122](./assets/1699406980122.png)

参考代码：

```vue
<template>
  <div>
    <h1>shallowReactive的使用</h1>
    <h2>{{ aa }}</h2>
    <button @click="change">change</button>
  </div>
</template>

<script setup>
import { ref, reactive, shallowRef, shallowReactive } from "vue";

// 浅层响应式
// 只能对第1层代理
// aa 是调用shallowReactive的返回值  它是一个proxy
let aa = shallowReactive({ a: { b: { c: 1 } } });

const change = () => {
  // aa.a.b.c = 888;
  // aa.a.b = { c: 888 };
  aa.a = { b: { c: 888 } }; // 是响应式的

  // 你是把一个普通对象赋值给了aa，aa此时就是一个普通对象了，不再是响应式
  // aa = { a: { b: { c: 888 } } };
};
</script>
```

**响应式代理 VS 原始对象**

值得注意的是， `reactive()` 返回的是一个原始对象的 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，它和原始对象是不相等的：

![1699407170344](./assets/1699407170344.png)

为保证访问代理的一致性，对同一个原始对象调用 `reactive()` 会总是返回同样的代理对象，而对一个已存在的代理对象调用 `reactive()` 会返回其本身：

![1699407384638](./assets/1699407384638.png)

这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：

![1699407648171](./assets/1699407648171.png)

**reactive的局限性：**

1. **有限的值类型**：它只能用于对象类型 (对象、数组和如 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections))。它不能持有如 `string`、`number` 或 `boolean` 这样的[原始类型](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)。
2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：

![1699407937744](./assets/1699407937744.png)

3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：

![1699408065649](./assets/1699408065649.png)

ref作为reactive对象的属性，会自动解包：

![1699408420731](./assets/1699408420731.png)

如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：

![1699408537008](./assets/1699408537008.png)

与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型(如 `Map` ) 中的元素被访问时，它**不会**被解包：

![1699408830612](./assets/1699408830612.png)

![1699409160317](./assets/1699409160317.png)

### 4，计算属性

官方的代码：

```vue
<template>
  <div>
    <p>Has published books:</p>
    <span>{{ publishedBooksMessage }}</span>
  </div>
</template>

<script setup>
import { reactive, computed, onMounted } from "vue";

const author = reactive({
  name: "John Doe",
  books: [
    "Vue 2 - Advanced Guide",
    "Vue 3 - Basic Guide",
    "Vue 4 - The Mystery",
  ],
});

// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? "Yes" : "No";
});

onMounted(()=>{
  console.log(publishedBooksMessage.value);
});
</script>
```

可写计算属性，计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建，如下：

![1699411088229](./assets/1699411088229.png)

### 5，类与样式绑定

绑定class，常见的写法：

![1699411397353](./assets/1699411397353.png)

:class后面也可以跟一上reactive，如下：

![1699411508188](./assets/1699411508188.png)

:class后面也可以跟一个计算属性，如下：

![1699411699789](./assets/1699411699789.png)

:class后面也可以跟一个数组，如下：

![1699411833436](./assets/1699411833436.png)

class可以写在组件上，如下：

![1699412005428](./assets/1699412005428.png)

也可以在组件上写:class，如下：

![1699412081304](./assets/1699412081304.png)

$attrs可以接收自定义属性，在vue3中是可以接收到class，如下：

![1699412219022](./assets/1699412219022.png)

### 6，条件渲染

v-if可以写在template标签上，如下：

![1699413367970](./assets/1699413367970.png)

v-show不能写在template标签上，如下：

![1699413507037](./assets/1699413507037.png)

**v-if 和 v-show的区别？**

`v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。

`v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。

相比之下， `v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换。

总的来说， `v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。

### 7，列表渲染

v-for的基本使用，如下：

![1699413922720](./assets/1699413922720.png)

v-for可以解构，如下：

![1699413985395](./assets/1699413985395.png)

v-for嵌套v-for，如下：

![1699414222573](./assets/1699414222573.png)

v-for of的用法，如下：

![1699414340662](./assets/1699414340662.png)

大tempalte标签上，使用v-for，如下：

![1699414592238](./assets/1699414592238.png)

不建议v-if和v-for连用，如下：

![1699414849701](./assets/1699414849701.png)

解决：

![1699414883932](./assets/1699414883932.png)

在计算属性中使用 `reverse()` 和 `sort()` 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：

![1699425684253](./assets/1699425684253.png)

### 8，事件处理

事件绑定：

![1699426186543](./assets/1699426186543.png)

事件修饰符，如下：

![1699426485519](./assets/1699426485519.png)

![1699426522303](./assets/1699426522303.png)

![1699426605092](./assets/1699426605092.png)

### 9，表单输入绑定

v-mode的使用：

![1699427196596](./assets/1699427196596.png)

复选框：

![1699427531805](./assets/1699427531805.png)

多个复选框：

![1699427801922](./assets/1699427801922.png)

单选按钮：

![1699427948355](./assets/1699427948355.png)

选择器：

![1699428065545](./assets/1699428065545.png)

多选：

![1699428110644](./assets/1699428110644.png)

复选框：

![1699428411885](./assets/1699428411885.png)

### 10，生命周期

生命周期钩子

* [onMounted()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onmounted)
* [onUpdated()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onupdated)
* [onUnmounted()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onunmounted)
* [onBeforeMount()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onbeforemount)
* [onBeforeUpdate()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onbeforeupdate)
* [onBeforeUnmount()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onbeforeunmount)
* [onErrorCaptured()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onerrorcaptured)
* [onRenderTracked()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onrendertracked)
* [onRenderTriggered()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onrendertriggered)
* [onActivated()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onactivated)
* [onDeactivated()](https://cn.vuejs.org/api/composition-api-lifecycle.html#ondeactivated)
* [onServerPrefetch()](https://cn.vuejs.org/api/composition-api-lifecycle.html#onserverprefetch)

onMounted，组件挂载完成后执行：

![1699429551108](./assets/1699429551108.png)

onUpdated，响应式状态变化后，更新其DOM，DOM更新完后调用：

![1699429755410](./assets/1699429755410.png)

onUnMounted，在组件实例被卸载后调用：

![1699429996522](./assets/1699429996522.png)

### 11，侦听器

先看官方的案例：

![1699430591002](./assets/1699430591002.png)

监听器的多种写法：

![1699430760521](./assets/1699430760521.png)

![1699430887110](./assets/1699430887110.png)

![1699431012013](./assets/1699431012013.png)

不能直接侦听响应式对象的属性值，例如:

![1699431173924](./assets/1699431173924.png)

深层侦听：

![1699431373210](./assets/1699431373210.png)

![1699431492027](./assets/1699431492027.png)

watchEffect的使用，就把它当成另一种侦听器，比watch更加优雅。如下：

![1699433618406](./assets/1699433618406.png)

参考代码：

```vue
<template>
  <div>
    <h1>watchEffect的使用</h1>
    <h1 v-text="num"></h1>
    <button @click="num++">自增</button>
    <hr />
    <h1 v-text="foo"></h1>
    <button @click="foo--">自减</button>
    <hr />
    <h1 v-text="bar.a"></h1>
    <button @click="bar.a++">改变</button>
  </div>
</template>

<script setup>
import { ref, computed, watchEffect, watchPostEffect, reactive } from "vue";
let num = ref(1);
let foo = ref(200);
let bar = reactive({ a: 1, b: 2 });

// 下面的代码，一开始只会执行一次，后面不管哪个状态发生变化都不会执行
watchEffect(() => {
  console.log("watchEffect01...");
});

// 在回调函数中，用到了num，当num变化了，回调函数就会执行
// num叫watchEffect的依赖
watchEffect(() => {
  console.log("watchEffect02...", num.value);
});

watchEffect(() => {
  console.log("watchEffect03...", foo.value);
});

watchEffect(() => {
  console.log("watchEffect04...", foo.value, num.value);
});
</script>
```

回调的执行时机：

![1699434425716](./assets/1699434425716.png)

参考代码：

```vue
<template>
  <div>
    <h1>watchEffect的使用</h1>
    <h1 v-text="num" id="h1box"></h1>
    <button @click="num++">自增</button>
    <hr />
    <h1 v-text="foo"></h1>
    <button @click="foo--">自减</button>
    <hr />
    <h1 v-text="bar.a"></h1>
    <button @click="bar.a++">改变</button>
  </div>
</template>

<script setup>
import { ref, computed, watchEffect, watchPostEffect, reactive } from "vue";
let num = ref(1);
let foo = ref(200);
let bar = reactive({ a: 1, b: 2 });

// watchEffect(
//   () => {
//     console.log("watchEffect01...", foo.value, num.value);
//     console.log(document.getElementById("h1box").innerHTML);
//   },
//   { flush: "pre" }
// );
// watchEffect(
//   () => {
//     console.log("watchEffect01...", foo.value, num.value);
//     console.log(document.getElementById("h1box").innerHTML);
//   },
//   { flush: "post" }
// );
watchPostEffect(() => {
  console.log("watchEffect01...", foo.value, num.value);
  console.log(document.getElementById("h1box").innerHTML);
});
</script>
```

停止侦听：

![1699434676061](./assets/1699434676061.png)

### 12，模板引用

它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。

代码如下：

![1699492446524](./assets/1699492446524.png)

注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 `input` ，在初次渲染时会是 `null` 。这是因为在初次渲染前这个元素还不存在呢！

如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 `null` 的情况：

![1699492746584](./assets/1699492746584.png)

当在 `v-for` 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：

![1699492922711](./assets/1699492922711.png)

除了使用字符串值作名字， `ref` attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：

![1699493181190](./assets/1699493181190.png)

把ref写在组件上，如下：

![1699493521343](./assets/1699493521343.png)

### 13，组件基础

组件另一种写法，写成js文件，如下：

![1699493993225](./assets/1699493993225.png)

关于命名：

![1699494568771](./assets/1699494568771.png)

![1699494632799](./assets/1699494632799.png)

自定义事件官方案例，如下：

![1699495292199](./assets/1699495292199.png)

App.vue参考代码：

```vue
<template>
  <div :style="{fontSize:postFontSize+'em'}">
    <BlogPost
      v-for="post in posts"
      :key="post.id"
      :title="post.title"
      @enlarge-text="postFontSize += 0.1"
    ></BlogPost>
  </div>
</template>

<script setup>
import { ref, computed, watchEffect, onMounted, reactive } from "vue";
import BlogPost from "./components/BlogPost.vue";

const posts = ref([
  { id: 1, title: "My journey with Vue" },
  { id: 2, title: "Blogging with Vue" },
  { id: 3, title: "Why Vue is so fun" },
]);
const postFontSize = ref(1);

</script>
```

BlogPost.vue参考代码：

```vue
<template>
  <div>
    <h4>{{ title }}</h4>
     <!-- <button  @click="$emit('enlarge-text')">Enlarge text</button> -->
     <button  @click="fn">Enlarge text</button>
  </div>
</template>

<script setup>
import { ref } from "vue";

let props = defineProps(["title"]);
let emit = defineEmits(["enlarge-text"])

let fn = ()=>{
  emit('enlarge-text')
};
</script>
```

动态组件案例：

![1699496911060](./assets/1699496911060.png)

参考代码：

https://play.vuejs.org/#eNqNVdFu2jAU/RUrfaCVCLRj2kMG1bqp0raHrdr61kxTcBxwSezIdhgI8e87thMT1FIBErLvPT4+5+bmsovu6nq0bliURFNNFa8N0cw09W0qeFVLZchXWTFSKFmRwWhsNxY+COkHqY0Oebc7BtwpuuTrA0W7PwbtiGIF2bcgnyKpoFJoQ2ijFBPmMZuTmcVdDqyMwVUqOoTJ5hq5HQ45vUO7cFrcqr0yFftUTMfeJgxiY1hVl5lh2BEyzfma0DLTepZGOatkGrk4MvPGGIkDdoPPOi6kAujy79DefUW4cBrSKECSFdsCgWg/2LE/DZCIPetgCPsZNVCYHHmdzSwp2f/pMXyiJacrMBwVpX9LK5mQ3c4fh2nnYeyvs8YNtlSi9AIUJOFWktX/dGDFpaEWjv52Og5HfLnGqBdW03Gvithqsy3tcmRL6J9JIYWJi6zi5TYhOhM61kzx4qPNzaXKmUrITb0hWpY8JxeMsV4qVlnOG52Qd/XGhessz7lYIHCNMxP8uHCVqQUXsZE1yFjVj80lnFcJed9hG9wPDSWjJiECnlxUrpkqSvkv3iQka4xEEMWDk8PD8n6Cgg8QcNORtnIhIC5ZYYLuycu84ovlKcBRKSilLoUHoyVSteTCMOXhGV0tlGxEnpCL4tp+XzMdg64fd3eHMAz27CVLWwNv8oieXdvvC/zI9+0ZB1rIaYehpm09/bvqeikaRt3gsXPq9EvrG9X3u5tboWNPNCyYw8g6n9rPvDO4e7PufPZuYJ7BbzTmX8EXo2ctBW5wNcZswEleMvWzNhzzMY0SX32by0o0+HcXM6rxk9KdWTK6eiX+rDc2lkYPiuGlwRSNQs6goZjx6fvfP9gG65CsZN6UQL+R/MXQA43V6GGf0TqQ3cM5td/cfwR641HfbwwTujNlhVrk3uHTCGX+8ob1g9zJaOLOocui/X90F1hu

组件中的样式是相互隔离的，如下：

![1699497759769](./assets/1699497759769.png)

## 四，Vue3深入指南之深入组件

### 1，组件的v-model

在Vue2中，v-model 写在组件上，等价于 :value + @input ；在Vue3中，v-model 等价于 :modelValue + @update:modelValue 。上代码：

![1699500722721](./assets/1699500722721.png)

![1699500760704](./assets/1699500760704.png)

在一个组件上，可以写多个v-model，如下：

App.vue:

```vue
<template>
  <div>
    <h1>App页面</h1>
    <hr />

    <!-- update:modelValue 叫自定义事件   $event是子触发自定义事件传递过来的数据-->
    <!-- <Demo :modelValue="lang" @update:modelValue="lang = $event"></Demo> -->

    <!-- v-model = :modelValue + @update:modelValue -->
    <!-- v-model:gender  = :gender + @update:gender -->
    <!-- v-model:xxx    =  :xxx  +  @update:xxx -->

    <Demo v-model="lang" v-model:gender="gender" v-model:xxx="ok"></Demo>

    <!-- <Demo
      :modelValue="lang"
      @update:modelValue="lang = $event"
      :gender="gender"
      @update:gender="gender = $event"
    ></Demo> -->
  </div>
</template>

<script setup>
import { ref } from "vue";
import Demo from "./components/Demo.vue";

const lang = ref("en");
const gender = ref("unknow");
</script>

```

Demo.vue:

```vue
<template>
  <div>
    <div class="lang">
      <span
        @click="langChange(item)"
        :class="{ on: item.value === modelValue }"
        v-for="item in langs"
        :key="item.id"
      >
        {{ item.label }}
      </span>
    </div>
    <hr />
    <div>
      <!-- <input type="radio" value="man" :checked="gender==='man'" @change="$emit('update:gender',$event.target.value)"> 男
      <input type="radio" value="woman" :checked="gender==='woman'" @change="$emit('update:gender',$event.target.value)"> 女
      <input type="radio" value="unknow" :checked="gender==='unknow'" @change="$emit('update:gender',$event.target.value)"> 保密 -->
      <input type="radio" value="man" v-model="g" /> 男
      <input type="radio" value="woman" v-model="g" /> 女
      <input type="radio" value="unknow" v-model="g" /> 保密

      <input type="text" v-model="userName" />
    </div>
  </div>
</template>

<script setup>
import { reactive, ref, computed } from "vue";
const langs = reactive([
  { id: 1, value: "zh", label: "中文" },
  { id: 2, value: "en", label: "英文" },
  { id: 3, value: "fr", label: "法语" },
]);
const userName = ref("xx666");

const props = defineProps({
  modelValue: { type: String, default: "zh" },
  gender: { type: String, default: "man" },
});

const emit = defineEmits(["update:modelValue", "update:gender"]);

let g = computed({
  get() {
    return props.gender;
  },
  set(val) {
    console.log("val:", val);
    emit("update:gender", val);
  },
});

let langChange = (item) => {
  emit("update:modelValue", item.value);
};
</script>

<style>
.lang span {
  cursor: pointer;
  padding: 20px;
}
.lang span.on {
  color: red;
}
</style>
```

效果如下：

![1699513291775](./assets/1699513291775.png)

v-model的修饰符，如下：

![1699513805251](./assets/1699513805251.png)

App.vue:

```vue
<template>
  <div>
    <h1>App页面</h1>
    <hr />
    <Demo v-model.trim.sort="lang"></Demo>
  </div>
</template>

<script setup>
import { ref } from "vue";
import Demo from "./components/Demo.vue";

const lang = ref("en");
</script>
```

Demo.vue:

```vue
<template>
  <div>
    <div class="lang">
      <span
        @click="langChange(item)"
        :class="{ on: item.value === modelValue }"
        v-for="item in langs"
        :key="item.id"
      >
        {{ item.label }}
      </span>
    </div>
  </div>
</template>

<script setup>
import { reactive, ref, computed } from "vue";
const langs = reactive([
  { id: 1, value: "zh", label: "中文" },
  { id: 2, value: "en", label: "英文" },
  { id: 3, value: "fr", label: "法语" },
]);
const userName = ref("xx666");

const props = defineProps({
  modelValue: { type: String, default: "zh" },
  modelModifiers: { default: () => ({}) },
});

const emit = defineEmits(["update:modelValue"]);

let langChange = (item) => {
  const { sort, trim, aaa } = props.modelModifiers;
  //  console.log(sort,trim,aaa);
  // 如果sort为真，先处理排序，再回传给父组件
  //  // 如果trim为真，把字符串首尾空字符删除，再回传父组件
  emit("update:modelValue", item.value);
};
</script>

<style>
.lang span {
  cursor: pointer;
  padding: 20px;
}
.lang span.on {
  color: red;
}
</style>
```

来上一个案例，如下：

![1699515395250](./assets/1699515395250.png)

GoodFilter.vue:

```vue
<template>
  <div>
    <h1>GoodFilter</h1>
    <span>请选择商家（多选）：</span>
    <span v-for="s in shopArr" :key="s.id">
      <input
        @change="shopChange"
        :checked="shop.includes(s.value)"
        type="checkbox"
        :value="s.value"
      />
      <span>{{ s.label }}</span>
    </span>
    <hr />
    <span>请选择价格（单选）：</span>
    <span v-for="p in priceArr" :key="p.id">
      <input
        @change="priceChange"
        :checked="p.value === price"
        type="radio"
        :value="p.value"
      />
      <span>{{ p.label }}</span>
    </span>
  </div>
</template>

<script setup>
import { reactive, ref, computed, toRefs } from "vue";

const props = defineProps({
  shop: { type: Array, default: [] },
  // 接收v-model:shop的自定义修饰符
  shopModifiers: { default: () => ({}) },
  price: { type: Number, default: 500 },
  // 接收v-model:price的自定义修饰符
  priceModifiers: { default: () => ({}) },
});
// toRefs 把一个对象中的属性变成ref
const { shop, price } = toRefs(props);

// 接收v-model的自定义事件
const emit = defineEmits(["update:shop", "update:price"]);

const shopArr = reactive([
  { id: 1, label: "华为", value: "huawei" },
  { id: 2, label: "小米", value: "mi" },
  { id: 3, label: "魅族", value: "meizu" },
  { id: 4, label: "三星", value: "samsung" },
]);

const priceArr = reactive([
  { id: 1, label: "1000以下", value: 500 },
  { id: 2, label: "1000~2000", value: 1500 },
  { id: 3, label: "2000~3000", value: 2500 },
  { id: 4, label: "3000以上", value: 3500 },
]);

const shopChange = (ev) => {
  const { checked, value } = ev.target;
  const { sort } = props.shopModifiers;

  let newShop = checked
    ? [...shop.value, value]
    : shop.value.filter((e) => e !== value);

  if (sort) newShop = newShop.sort();
  emit("update:shop", newShop);
};

let priceChange = (ev) => {
  emit("update:price", Number(ev.target.value));
};
</script>
```

App.vue:

```vue
<template>
  <div>
    <h1>App页面</h1>
    <hr />
    <!--  v-model:shop  =   :shop + shopModifiers + @update:shop-->
    <!-- v-model:price  =   :price + @update:price -->
    <GoodFilter v-model:shop.sort="shop" v-model:price="price"></GoodFilter>
  </div>
</template>

<script setup>
import { ref, watch } from "vue";
import GoodFilter from "./components/GoodFilter.vue";

const shop = ref(["mi","huawei"]);
const price = ref(500);
watch([shop, price], () => {
  console.log("changed", shop.value, price.value);
});
</script>
```

### 2，透传 Attributes

class透传：

![1699516582458](./assets/1699516582458.png)

透传的class不会覆盖原有的，如下：

![1699516659839](./assets/1699516659839.png)

事件也可以透传，如下：

![1699516850931](./assets/1699516850931.png)

深层透传，如下：

![1699517038864](./assets/1699517038864.png)

禁止透传：

![1699517209160](./assets/1699517209160.png)

$attrs，如下：

![1699517356463](./assets/1699517356463.png)

这个 `$attrs` 对象包含了除组件所声明的 `props` 和 `emits` 之外的所有其他 attribute，例如 `class` ， `style` ， `v-on` 监听器等等。

![1699517525324](./assets/1699517525324.png)

透传到非根组件上，如下：

![1699517683956](./assets/1699517683956.png)

在 JavaScript 中访问透传 Attributes，如下：

![1699517901668](./assets/1699517901668.png)

### 3，插槽

大家自行学习。

### 4，依赖注入

看写代码如下：

![1699518365948](./assets/1699518365948.png)

一个组件可以多次调用 `provide()` ：

![1699518514093](./assets/1699518514093.png)

### 5，整理vue3组合式API和vue3的变化

参考：https://yujingbo1023.github.io/feblog/Framework/vue3/01.html#%E4%B8%80%E3%80%81vue3%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D

## 五，路由

### 1，安装路由

创建一个没有路由的项目，如下：

![1699578684169](./assets/1699578684169.png)

安装依赖，启动项目，如下：

![1699578722156](./assets/1699578722156.png)

浏览器测试之，如下：

![1699578744806](./assets/1699578744806.png)

精简代码：

![1699578864154](./assets/1699578864154.png)

安装路由，如下：

![1699578897206](./assets/1699578897206.png)

操作：

![1699578931688](./assets/1699578931688.png)

### 2，使用路由

创建一个router文件夹，在router文件夹下，创建index.js，如下 ：

![1699579257100](./assets/1699579257100.png)

routes中的规则和vue2中路由的规则是一样的，创建一些组件，如下：

![1699579404614](./assets/1699579404614.png)

配置路由规则，如下：

![1699580716646](./assets/1699580716646.png)

参考代码：

```js
import {
    createRouter,
    createWebHashHistory
} from "vue-router"
import Home from "../views/Home.vue"
const router = createRouter({
    history: createWebHashHistory(),
    routes: [{
            path: "/",
            redirect: "/home"
        },
        {
            path: "/home",
            component: Home,
            name: "home",
            meta: {
                title: "首页"
            }
        },
        {
            path: "/category",
            component: () => import('../views/Category.vue'),
            name: "category",
            meta: {
                title: "分类"
            }
        },
        {
            path: "/cart",
            component: () => import('../views/Cart.vue'),
            name: "cart",
            meta: {
                title: "购物车",
                needLogin: true
            }
        },
        {
            path: "/user",
            component: () => import('../views/User.vue'),
            name: "user",
            meta: {
                title: "我的"
            }
        },
        {
            path: "/login",
            component: () => import('../views/Login.vue'),
            name: "login",
            meta: {
                title: "登录"
            }
        },
        {
            path: "/detail/:id",
            component: () => import('../views/Detail.vue'),
            name: "detail",
            meta: {
                title: "详情"
            }
        },
        {
            path: "/search",
            component: () => import('../views/Search.vue'),
            name: "sarch",
            meta: {
                title: "搜索"
            }
        },
    ]
})

export default router;
```

在main.js中使用router，如下：

![1699580770099](./assets/1699580770099.png)

在App路由中指定路由出口，如下：

![1699580806010](./assets/1699580806010.png)

### 3，路由守卫

和之前有点不一样的，如下：

![1699580949075](./assets/1699580949075.png)

### 4，$router 和 $route

直接上代码，从首页面跳到分类页，如下：

![1699581392024](./assets/1699581392024.png)

## 六，pinia状态管理

### 1，pinia介绍

官方地址：https://pinia.vuejs.org/zh/introduction.html

安装之，如下：

```shell
npm i pinia
npm i axios@0.27.2
```

操作：

![1699582892410](./assets/1699582892410.png)

### 2，pinia的使用

创建仓库，如下：

![1699583140489](./assets/1699583140489.png)

参考代码：

```js
import {
    defineStore
} from "pinia"

const useCountStore = defineStore("Count", {
    state: () => {
        return {
            num: 1
        }
    },
    getters: {
        total1() {
            return this.num * 10
        },
        total2() {
            return this.total1 * 2;
        }
    },
    // 这里的actions，可以直接修改state数据，无论是同步代码，还是异步代码。
    actions: {
        addNum(step = 1) {
            this.num += step;
        }
    }
})

export default useCountStore
```

在main.js中使用之，如下：

![1699583257609](./assets/1699583257609.png)

在组件中就可以使用之，如下：

![1699583434797](./assets/1699583434797.png)

修改仓库中的状态，如下：

![1699583525404](./assets/1699583525404.png)

再定义一个仓库，写点异步代码，写ajax发请求的代码，可能会产生跨域问题，前端通过代码解决跨域，如下：

```js
// vite.config.js

import {
    fileURLToPath,
    URL
} from 'node:url'

import {
    defineConfig
} from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
    plugins: [
        vue(),
    ],
    resolve: {
        alias: {
            '@': fileURLToPath(new URL('./src',
                import.meta.url))
        }
    },
    server: {
        port: 8888,
        proxy: {
            '/api': {
                target: 'https://cnodejs.org/',
                changeOrigin: true
            }
        }
    }
})
```

在action中发请求，如下：

![1699584015158](./assets/1699584015158.png)

在组件中，使用之，如下：

![1699584142380](./assets/1699584142380.png)

浏览器测试之，看仓库中有没有数据，如下：

![1699584312256](./assets/1699584312256.png)

在模板中渲染之，如下：

![1699584508939](./assets/1699584508939.png)

完整代码：

```vue
<template>
  <h1>Home</h1>
  <p>{{ store.num }}</p>
  <p>{{ store.total1 }}</p>
  <p>{{ store.total2 }}</p>
  <button @click="change">change</button>
  <hr />
  <button @click="pageHandle(-1)">上一页</button>
  <button @click="pageHandle(1)">下一页</button>
  <div v-for="(row, idx) in store2.list" :key="row.id">
    <span v-text="idx"></span>：
    <span v-text="row.title"></span>
  </div>
</template>

<script setup>
import { onMounted, watchEffect, ref } from "vue";
import useCountStore from "../store/useCountStore";
import useCnodeStore from "../store/useCnodeStore";

let store = useCountStore();
let store2 = useCnodeStore();

const page = ref(1);

let change = () => {
  store.addNum(2);
};

let pageHandle = (num) => {
  if (page.value === 1 && num === -1) return;
  page.value += num;
};

watchEffect(
  () => {
    store2.getList({ page: page.value, limit: 5, tab: "ask" });
  },
  { flush: "pre" }
);
</script>
```

### 3，解构时造成响应式丢失

解构状态或计算属性时，可能造成响应式丢失，通过storeToRefs解决，如下：

![1699584839195](./assets/1699584839195.png)

### 4，组合式写法

前写我们写的是选项式写法：

![1699584974449](./assets/1699584974449.png)

在Pinia中还有一种写法，组合式写法，如下：

![1699585329769](./assets/1699585329769.png)

Home.vue参考代码：

```vue
<template>
  <h1>Home</h1>
  <p>{{ num }}</p>
  <p>{{ total1 }}</p>
  <button @click="change">change</button>
</template>

<script setup>
import { onMounted, watchEffect, ref } from "vue";
import { storeToRefs } from "pinia";
import useCountStore from "../store/useCountStore";
import useCnodeStore from "../store/useCnodeStore";

let store = useCountStore();
const { num, total1 } = storeToRefs(store);

let change = () => {
  store.addNum(2);
};
</script>
```

仓库：

```js
import {
    defineStore
} from "pinia"
import {
    ref,
    computed
} from "vue"

const useCountStore = defineStore("Count", () => {
    let num = ref(1)

    let total1 = computed(() => num.value * 10)
    let total2 = computed(() => total1.value * 10)

    let addNum = (step) => {
        num.value += step;
    }

    return {
        num,
        addNum
    }
})

export default useCountStore
```

### 5，其它API

$reset

$subscribe

## 七，vue3项目

### 1，配置REM

安装lib-flexible和postcss-pxtorem，如下：

![1699586479206](./assets/1699586479206.png)

创建一个postcss.config.cjs，如下：

![1699586567547](./assets/1699586567547.png)

参考代码：

```js
module.exports = {
    plugins: {
        'postcss-pxtorem': {
            rootValue: 37.5,
            propList: ['*']
        }
    }
}
```

在main.js中，引入lib-flexible，如下：

![1699586670752](./assets/1699586670752.png)

写代码测试之，如下：

![1699587089503](./assets/1699587089503.png)

### 2，配置vant

官方地址：https://vant-contrib.gitee.io/vant/#/zh-CN/home

如何配置，直接看文档，如下：

![1699587174058](./assets/1699587174058.png)

安装vant，如下：

![1699587199674](./assets/1699587199674.png)

操作：

![1699587222572](./assets/1699587222572.png)

配置按需引入，如下：

![1699587270559](./assets/1699587270559.png)

安装插件，如下：

![1699587319112](./assets/1699587319112.png)

操作：

![1699587340108](./assets/1699587340108.png)

配置插件，如下：

![1699587380744](./assets/1699587380744.png)

操作：

![1699587484220](./assets/1699587484220.png)

使用组件，如下：

![1699587528242](./assets/1699587528242.png)

操作：

![1699587598173](./assets/1699587598173.png)

 处理个别组件，并把一些组件挂载到应用上，如下：

![1699587651184](./assets/1699587651184.png)

操作：

![1699587954618](./assets/1699587954618.png)

参考代码：

```js
import {
    showToast,
    showDialog,
    showNotify,
    showImagePreview,
    showConfirmDialog,
    Lazyload
} from 'vant'

import 'vant/es/toast/style'
import 'vant/es/dialog/style'
import 'vant/es/notify/style'
import 'vant/es/image-preview/style'

export function installVant(app) {
    app.config.globalProperties.$showToast = showToast
    app.config.globalProperties.$showDialog = showDialog
    app.config.globalProperties.$showNotify = showNotify
    app.config.globalProperties.$showImagePreview = showImagePreview
    app.config.globalProperties.$showConfirmDialog = showConfirmDialog

    app.use(Lazyload)
}
```

在main.js中使用之，如下：

![1699588070250](./assets/1699588070250.png)

测试之，如下：

![1699588449738](./assets/1699588449738.png)

### 3，配置方法自动导入

安装一个插件，如下：

![1699596588322](./assets/1699596588322.png)

参考：

```shell
npm i unplugin-auto-import
```

配置：

![1699596749256](./assets/1699596749256.png)

参考：

```js
import AutoImport from 'unplugin-auto-import/vite'

AutoImport({
    imports: ['vue', 'vue-router', 'pinia'],
    eslintrc: {
        enabled: false
    }
})
```

浏览器测试之，如下：

![1699596815451](./assets/1699596815451.png)

### 4，配置主题

![1699597556755](./assets/1699597556755.png)

安装less，如下：

![1699596868996](./assets/1699596868996.png)

先在assets下面创建一个theme.css，如下：

![1699597783320](./assets/1699597783320.png)

在main.js中引入之，如下：

![1699597808004](./assets/1699597808004.png)

可以把主题色定义成一个变量，后面里哪里使用，直接使用变量，如下：

![1699597883507](./assets/1699597883507.png)

在vite.confnig.js中配置，加载上面的var.less，如下：

![1699597949926](./assets/1699597949926.png)

参考：

```js
css: {
    preprocessorOptions: {
        less: {
            additionalData: '@import "/src/assets/var.less";'
        }
    }
}
```

测试：

![1699598026575](./assets/1699598026575.png)

### 5，Tabbar

创建Tabbar组件，如下：

![1699598291390](./assets/1699598291390.png)

在App.vue中使用之，如下：

![1699598399569](./assets/1699598399569.png)

在App.vue中定义状态，控制Tabbar是否显示，如下：

![1699599012929](./assets/1699599012929.png)

在Tabbar组件中，接收，使用之，如下：

![1699599034832](./assets/1699599034832.png)

浏览器效果：

![1699599307566](./assets/1699599307566.png)

给有tabbar的页面添加一个padding-bottom，如下：

![1699600416300](./assets/1699600416300.png)

### 6，SvgIcon

iconfont官网：https://www.iconfont.cn/

使用步骤：

![1699600540649](./assets/1699600540649.png)

![1699600564442](./assets/1699600564442.png)

![1699600603438](./assets/1699600603438.png)

![1699600628648](./assets/1699600628648.png)

![1699600703888](./assets/1699600703888.png)

下载解压：

![1699600758232](./assets/1699600758232.png)

点击html文件，如下：

![1699600846075](./assets/1699600846075.png)

项目中引入iconfont.js，如下：

![1699600904416](./assets/1699600904416.png)

在main.js中直接引入，如下：

![1699600967606](./assets/1699600967606.png)

第二步：

![1699601016317](./assets/1699601016317.png)

第三步：

![1699601124873](./assets/1699601124873.png)

然后，封装一个SvgIcon组件，如下：

![1699601475005](./assets/1699601475005.png)

大家使用我的iconfont.js或者自己去找图标，如下：

![1699601679325](./assets/1699601679325.png)

参考代码：

```vue
<template>
  <!-- <van-tabbar v-if="visible" route> -->
  <van-tabbar v-if="props.visible" route>
    <van-tabbar-item to="/home">
      <template #icon>
        <SvgIcon icon-class="home"></SvgIcon>
      </template>
      首页
    </van-tabbar-item>
    <van-tabbar-item to="/category">
      <template #icon>
        <SvgIcon icon-class="category"></SvgIcon>
      </template>
      分类
    </van-tabbar-item>
    <van-tabbar-item to="/cart">
      <template #icon>
        <SvgIcon icon-class="cart"></SvgIcon>
      </template>
      购物车
    </van-tabbar-item>
    <van-tabbar-item to="/user">
      <template #icon>
        <SvgIcon icon-class="user"></SvgIcon>
      </template>
      我的
    </van-tabbar-item>
  </van-tabbar>
</template>

<script setup>
// const isVisible = ref(true);
const route = useRoute();

import { watchEffect } from "vue";

const props = defineProps(["visible"]);
const emit = defineEmits(["update:visible"]);

watchEffect(() => {
  const paths = ["/home", "/category", "/cart", "/user"];
  emit("update:visible", paths.includes(route.path));
});
</script>
```

### 7，首页面

直接把之前的项目的api文件夹copy过来，如下：

![1699601861613](./assets/1699601861613.png)

安装依赖：

```shell
npm i blueimp-md5
```

操作：

![1699602164372](./assets/1699602164372.png)

配置代理：

![1699604006316](./assets/1699604006316.png)

参考：

```js
 proxy: {
     '/api': {
         target: 'http://backend-api-01.newbee.ltd/api/v1',
         changeOrigin: true,
         // pathRewrite: { '^/api': '' }  // 错的
         rewrite: (path) => path.replace(/^\/api/, ""),
     }
 }
```

在组件中调用接口如下：

![1699604026230](./assets/1699604026230.png)

查看：

![1699604076647](./assets/1699604076647.png)

直接上代码：

```vue
<template>
  <div
    style="
      background-color: gold;
      position: absolute;
      z-index: 1000;
      width: 100%;
    "
  >
    <!-- 头部 -->
    <van-sticky @scroll="handleScorll">
      <div class="home-header">
        <div class="menu">
          <router-link to="/category">
            <van-icon name="wap-nav" />
          </router-link>
        </div>
        <div class="search">
          <span>新峰商城</span>
          <van-icon name="search" />
          <router-link to="/search">山河无恙，人间皆安</router-link>
        </div>
        <div class="login">
          <router-link to="/login">登录</router-link>
        </div>
      </div>
    </van-sticky>
  </div>
  <!-- 轮播图 -->
  <van-swipe class="swipe" :autoplay="3000" indicator-color="@theme">
    <template v-for="(item, index) of carousels" :key="index">
      <van-swipe-item>
        <img :src="item.carouselUrl" />
      </van-swipe-item>
    </template>
  </van-swipe>
  <!-- 宫格 -->
  <van-grid :column-num="5" :border="false">
    <van-grid-item
      v-for="menu in menuList"
      :key="menu.name"
      :icon="menu.imgUrl"
      :text="menu.name"
      @click="$showToast('敬请期待')"
    />
  </van-grid>

  <!-- 商品 -->
  <van-skeleton :row="5" v-if="hotGoodses.length === 0"></van-skeleton>
  <div v-else>
    <HomeGoodsItem title="新品上线" :goods-list="hotGoodses"></HomeGoodsItem>
    <HomeGoodsItem title="热门商品" :goods-list="newGoodses"></HomeGoodsItem>
    <HomeGoodsItem
      title="最新推荐"
      :goods-list="recommendGoodses"
    ></HomeGoodsItem>
  </div>
</template>

<script setup>
import API from "../api/index.js";
import menuList from "../assets/category";

const carousels = ref([]);
const hotGoodses = ref([]);
const newGoodses = ref([]);
const recommendGoodses = ref([]);

onMounted(async () => {
  try {
    let { resultCode, data } = await API.queryIndexInfo();
    if (+resultCode === 200) {
      carousels.value = data.carousels; // 轮播图的数据获取成功
      hotGoodses.value = data.hotGoodses;
      newGoodses.value = data.newGoodses;
      recommendGoodses.value = data.recommendGoodses;
    }
  } catch (_) {}
});

let handleScorll = () => {};
</script>

<style scoped lang="less">
.home-header {
  padding: 0 20px;
  display: flex;
  background: rgba(255, 255, 255, 0.7);
  justify-content: space-between;
  align-items: center;
  a {
    color: #444;
  }
  &.active {
    background: @theme;
    span {
      color: #fff;
    }
    a {
      color: #fff;
    }
  }
}
.search {
  width: 255px;
}
.van-icon {
  font-size: 20px;
}
.search {
  span {
    color: @theme;
    font-size: 22px;
    padding-right: 20px;
    font-weight: bold;
  }
  line-height: 50px;
  display: flex;
  align-items: center;
}
.swipe {
  height: 172px;
  img {
    width: 100%;
    height: 100%;
  }
}
</style>
```

HomeGoodsItem.vue:

```vue
<script setup>
defineProps(["title", "goodsList"]);
</script>

<template>
  <div class="title">{{ title }}</div>
  <van-grid :column-num="2" :border="false">
    <van-grid-item v-for="goods in goodsList" :key="goods.goodsId">
      <router-link
        :to="`/detail/${goods.goodsId}`"
        style="display: flex; flex-direction: column; align-items: center"
      >
        <van-image :src="goods.goodsCoverImg" lazy-load />
        <div class="desc">
          {{ goods.goodsIntro }}
        </div>
        <div class="price">
          {{ goods.sellingPrice }}
        </div>
      </router-link>
    </van-grid-item>
  </van-grid>
</template>
<style scoped lang="less">
.title {
  color: @theme;
  font-size: 20px;
  text-align: center;
  font-weight: bold;
  padding: 10px 0;
}
.van-image {
  :deep(.van-image__img) {
    width: 120px;
    height: 140px;
  }
}
.desc {
  font-size: 14px;
  color: #555;
}
.price {
  color: @theme;
  font-size: 16px;
}
</style>
```

到此首页面就开发完毕了。如下：

![1699605208142](./assets/1699605208142.png)

在渲染首页面数据时，后端接口，有些图片的路径是不全的，需要前端处理。还需要给价格添加一个 ￥ 符号，在vue2中处理如下：

![1699838573010](./assets/1699838573010.png)

在vue3中直接定义一个工具方法来处理，如下：

![1699839081177](./assets/1699839081177.png)

在HomeGoodsItem.vue中使用之，如下：

![1699839344059](./assets/1699839344059.png)

### 8，分类模块

把分类的数据存储到pinia中，创建仓库如下：

![1699839757709](./assets/1699839757709.png)

在main.js中应用仓库，如下：

![1699839817589](./assets/1699839817589.png)

在分类组件中就要调用上面的action，如下：

![1699840203205](./assets/1699840203205.png)

浏览器测试之，如下：

![1699840253537](./assets/1699840253537.png)

在渲染分类数据之前，先封装一个NavBar，有人叫TopBar，如下：

![1699840555169](./assets/1699840555169.png)

参考代码：

```vue
<template>
  <van-nav-bar left-arrow @click-left="router.back()">
    <template #title>
      <slot name="title">
        {{ title || $route.meta.title }}
      </slot>
    </template>
    <template #right>
      <slot name="right"></slot>
    </template>
  </van-nav-bar>
</template>

<script setup>
defineProps(["title"]);
</script>
```

在分类组件中使用之，如下：

![1699840719316](./assets/1699840719316.png)

然后就开始绘制分类数据了，数据已经存储到了pinia中了，存储到pinia中的数据，它是在内存中的，一刷新就没有了，但是一刷新，它又调用了onMounted函数，在这个函数中又去调用接口，获取数据，放到pinia中了。开始渲染数据，如下：

```vue
<template>
  <my-nav-bar>
    <template #title>
      <van-search
        placeholder="搜索需要的产品"
        @click="$router.push('/search')"
      ></van-search>
    </template>
  </my-nav-bar>

  <div class="main">
    <!-- 左边 -->
    <van-sidebar v-model="activeKey">
      <van-sidebar-item
        v-for="item in list"
        :key="item.categoryId"
        :title="item.categoryName"
      />
    </van-sidebar>
    <!-- 右边 -->
    <div class="content" v-if="contentArr && contentArr.length > 0">
      <div v-for="content in contentArr" :key="content.categoryId">
        <h3 class="title">{{ content.categoryName }}</h3>
        <div class="list">
          <router-link
            :to="{ path: '/search', query: { categoryId: item.categoryId } }"
            v-for="item in content.thirdLevelCategoryVOS"
            :key="item.categoryId"
          >
            <van-image :src="classify" />
            <span>{{ item.categoryName }}</span>
          </router-link>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, onMounted } from "vue";
import useCategoryStore from "../store/useCategoryStore";
import { storeToRefs } from "pinia";
import MyNavBar from "../components/MyNavBar.vue";
import classify from "@/assets/images/classify.png";

const store = useCategoryStore(); // 得到仓库了
// store.list
const { list } = storeToRefs(store);

const activeKey = ref(0);

const contentArr = computed(() => {
  return list.value[activeKey.value]?.secondLevelCategoryVOS;
});

onMounted(async () => {
  if (list.value.length == 0) {
    await store.getCategories();
  }
});
</script>

<style lang="less" scope>
.van-search {
  .van-search__content {
    border-radius: 19px;
  }
}
.main {
  height: calc(100vh - 96px);
  display: flex;
}
.van-sidebar {
  height: 100%;
  width: 120px;
  background-color: #f7f8fa;
}
.van-sidebar-item {
  padding: 15px 10px;
}

.content {
  height: 100%;
  width: 255px;
  overflow-x: hidden;
  overflow-y: auto;
  .title {
    padding-left: 15px;
    font-size: 16px;
    line-height: 40px;
    margin-bottom: 15px;
  }
  .list {
    display: flex;
    flex-wrap: wrap;
    padding: 0 10px;
    a {
      margin-right: 2%;
      margin-bottom: 10px;
      width: 32%;
      .van-image {
        width: 30px;
        height: 30px;
        display: block;
        margin: 0 auto;
      }
      span {
        display: block;
        text-align: center;
        line-height: 30px;
        color: #555;
      }
      &:nth-child(3n) {
        // border: 1px solid red;
        margin-right: 0;
      }
    }
  }
}
</style>
```

浏览器效果如下：

![1699843933390](./assets/1699843933390.png)

### 9，登录注册 

路由已配置OK，对应的组件也创建好了：

![1699844015184](./assets/1699844015184.png)

封装验证码组件，如下：

![1699844295291](./assets/1699844295291.png)

参考代码：

```vue
<script setup>
const width = 120;
const height = 30;
const canvasBox = ref(null);
const emit = defineEmits(["update:text"]);  // 8a9i
const createRandomCaptcha = (num = 4) => {
  const chars =
    "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let captcha = "",
    i = 0;
  while (i < num) {
    let random = Math.round(Math.random() * 61);
    captcha += chars[random];
    i++;
  }
  return captcha;
};
function generateCaptcha() {
  const context = canvasBox.value.getContext("2d");
  var captchaText = createRandomCaptcha();
  // 清空画布
  context.clearRect(0, 0, width, height);
  context.fillStyle = "#000";
  context.font = "30px Arial, sans-serif";
  context.textBaseline = "top";
  context.fillText(captchaText, 20, 0);

  for (var i = 0; i < 5; i++) {
    context.beginPath();
    context.moveTo(Math.random() * width, Math.random() * height);
    context.lineTo(Math.random() * width, Math.random() * height);
    context.strokeStyle = "#999";
    context.stroke();
  }
  emit("update:text", captchaText);
}
onMounted(() => {
  generateCaptcha();
});
defineExpose({
  reset: generateCaptcha,
});
</script>
<template>
  <canvas
    :width="width"
    :height="height"
    ref="canvasBox"
    @click="generateCaptcha"
  ></canvas>
</template>
```

有了验证码组件，就开始绘制登录注册页面，如下：

![1699845298059](./assets/1699845298059.png)

参考代码：

```vue
<template>
  <div class="login">
    <my-nav-bar :title="isLogin ? '登录' : '注册'"></my-nav-bar>
    <img :src="logo" class="logo" />
    <van-form @submit="submit">
      <van-field
        v-model.trim="ruleForm.loginName"
        name="loginName"
        placeholder="请输入用户名"
        label="手机号"
        :rules="[{ pattern: /^1\d{10}$/, message: '手机号格式有误' }]"
      />
      <van-field
        v-model.trim="ruleForm.password"
        name="password"
        placeholder="请输入密码"
        label="密码"
        :rules="[{ required: true, message: '密码是必填项' }]"
      />
      <van-field
        v-model.trim="ruleForm.captcha"
        name="captcha"
        label="验证码"
        :rules="[{ validator: validatorCaptcha, message: '验证码输入有误' }]"
      >
        <template #button>
          <Captcha v-model:text="captchaImgText" ref="captcha"></Captcha>
        </template>
      </van-field>
      <a class="text" @click="changeLogin">
        {{ isLogin ? "还没账号,请点此注册" : "已有账号,请点此登录" }}
      </a>
      <div style="margin: 16px">
        <van-button round block color="#1baeae" native-type="submit"> 确认提交 </van-button>
      </div>
    </van-form>
  </div>
</template>

<script setup>
import logo from "@/assets/images/newbee-mall-vue3-app-logo.png";
const isLogin = ref(true);
const captcha = ref(null);
const ruleForm = reactive({
  loginName: "", // 用户名
  password: "", // 密码
  captcha: "", // 验证码
});

const changeLogin = () => {
  isLogin.value = !isLogin.value;
  ruleForm.loginName = "";
  ruleForm.password = "";
  ruleForm.captcha = "";
  captcha.value.reset();
};
const submit = async () => {};
</script>

<style scoped lang="less">
.login {
  padding: 0 20px;
  .logo {
    display: block;
    margin: 20px auto 20px;
    width: 140px;
    height: 140px;
  }
}
.text {
  display: inline-block;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 0 15px;
  color: #1989fa;
  font-size: 14px;
}
</style>
```

到此，登录注册的界面就绘制完毕了。点击提交时，需要调用接口，如下：

![1699845387547](./assets/1699845387547.png)

点击提交，区别出是登录还是注册如下：

![1699845502066](./assets/1699845502066.png)

在组件中引入接口，调用之，如下：

```vue
<template>
  <div class="login">
    <my-nav-bar :title="isLogin ? '登录' : '注册'"></my-nav-bar>
    <img :src="logo" class="logo" />
    <van-form @submit="submit">
      <van-field
        v-model.trim="ruleForm.loginName"
        name="loginName"
        placeholder="请输入用户名"
        label="手机号"
        :rules="[{ pattern: /^1\d{10}$/, message: '手机号格式有误' }]"
      />
      <van-field
        v-model.trim="ruleForm.password"
        name="password"
        placeholder="请输入密码"
        label="密码"
        :rules="[{ required: true, message: '密码是必填项' }]"
      />
      <van-field
        v-model.trim="ruleForm.captcha"
        name="captcha"
        label="验证码"
        :rules="[{ validator: validatorCaptcha, message: '验证码输入有误' }]"
      >
        <template #button>
          <Captcha v-model:text="captchaImgText" ref="captcha"></Captcha>
        </template>
      </van-field>
      <a class="text" @click="changeLogin">
        {{ isLogin ? "还没账号,请点此注册" : "已有账号,请点此登录" }}
      </a>
      <div style="margin: 16px">
        <van-button round block color="#1baeae" native-type="submit">
          确认提交
        </van-button>
      </div>
    </van-form>
  </div>
</template>

<script setup>
import logo from "@/assets/images/newbee-mall-vue3-app-logo.png";
import API from "../api/index.js";
import _ from "@/assets/utils";

const { proxy } = getCurrentInstance(); // 得到组件实例
const router = useRouter();

const isLogin = ref(true);
const captcha = ref(null);
const ruleForm = reactive({
  loginName: "", // 用户名
  password: "", // 密码
  captcha: "", // 验证码
});

const changeLogin = () => {
  isLogin.value = !isLogin.value;
  ruleForm.loginName = "";
  ruleForm.password = "";
  ruleForm.captcha = "";
  captcha.value.reset();
};
const submit = async () => {
  if (isLogin.value) {
    // 登录
    // console.log("登录成功了");
    try {
      let { resultCode, data } = await API.userLogin(
        ruleForm.loginName,
        ruleForm.password
      );
      if (+resultCode === 200) {
        proxy.$showToast("登录成功");
        _.storage.set("TK", data);
        // 去购物车时，没有登录，跳到登录页了，登录成功后，需要跳到购物车
        //  /login?redirect='/cart'    登录成功后，获取参数redirect='/cart'
        // 不要router.push("/");   你要push到/cart
        // ........?????????
        router.push("/");
      }
    } catch (e) {
      proxy.$showToast(e.message);
    }
  } else {
    // 注册
    // console.log("注册成功了");
    try {
      let { resultCode, message } = await API.userRegister(
        ruleForm.loginName,
        ruleForm.password
      );
      if (+resultCode === 200) {
        proxy.$showToast("注册成功");
        changeLogin();
      } else {
        proxy.$showToast(message);
      }
    } catch (e) {
      proxy.$showToast(e.message);
    }
  }
};
</script>

<style scoped lang="less">
.login {
  padding: 0 20px;
  .logo {
    display: block;
    margin: 20px auto 20px;
    width: 140px;
    height: 140px;
  }
}
.text {
  display: inline-block;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 0 15px;
  color: #1989fa;
  font-size: 14px;
}
</style>
```

测试之，如下：

![1699846408492](./assets/1699846408492.png)

路由守卫：

```js
// 不管要访问哪个路由，都要经过这个守卫
router.beforeEach(to => {
    // 判断localstorage中有没有token，如果有，表示已登录
    // 也就是说，登录了，localstorage中一直会有token。
    // 但是你要知道，token是有生存周期，如果后端设置token只能存活7天，那么第8天，你的token就失效了

    // localstoreage.getItem("TK")
    let token = _.storage.get("TK");
    if (token) {
        if (to.name === 'login') {
            // 表示你登录了，你又访问登录页面
            return {
                path: '/'
            }
        }
    } else {
        // 没有登录
        if (to.matched.some(item => item.meta.needLogin)) {
            // 没有登录，但是此路由需要登录
            return {
                path: "/login",
                query: {
                    // 跳到登录页面，并告诉登录页面稍后回调回来
                    redirect: to.path,
                    ...to.query, // 当前页面的其它参数也添加进行
                }
            }
        }
    }
})
```

浏览器效果如下：

![1699847464419](./assets/1699847464419.png)

再处理一下登录成功，如下：

![1699847629920](./assets/1699847629920.png)

浏览器测试之，如下：

![1699847702927](./assets/1699847702927.png)

上午在实现登录注册时，没有对验证码进行校验：

![1699857095219](./assets/1699857095219.png)

需要实现上面的校验函数：

![1699862044437](./assets/1699862044437.png)

浏览器测试之，如下：

![1699857314317](./assets/1699857314317.png)

### 10，搜索模块

路由也配置好了：

![1699857405579](./assets/1699857405579.png)

接口也封装好了：

![1699857475501](./assets/1699857475501.png)

开始绘制搜索页面的navbar，如下：

![1699857610253](./assets/1699857610253.png)

绘制操作栏，如下：

![1699858015823](./assets/1699858015823.png)

在第1个操作栏中，需要把所有的三级分类都计算出来，如下：

![1699859231981](./assets/1699859231981.png)

然后需要实现商品的展示，封装GoodsItem组件如下：

![1699860844814](./assets/1699860844814.png)

参考代码：

```vue
<template>
  <div :class="{ 'goods-item-box': true, 'goods-cart': cart }">
    <router-link :to="`/detail/${info.goodsId}`">
      <van-image :src="utils.processURL(info.goodsCoverImg)" />
      <div class="desc" v-if="!cart">
        <h3 class="title">{{ info.goodsName }}</h3>
        <p class="info">商品介绍</p>
        <p class="price">{{ info.sellingPrice }}</p>
      </div>
      <div class="cart-desc" v-else>
        <h3 class="title">{{ info.goodsName }}</h3>
        <p class="info">
          <span>{{ info.sellingPrice }}</span>
          <van-stepper max="5" :modelValue="info.goodsCount" @change="handle" />
        </p>
      </div>
    </router-link>
  </div>
</template>
<script setup>
// import { useCartStore } from "../stores/cart";
import utils from "../assets/utils";

const props = defineProps(["cart", "info"]);
// const store = useCartStore();
// function handle(value) {
//   store.setShopCartItem(props.info.cartItemId, value);
// }
</script>

<style lang="less" scoped>
.clip {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
}

.goods-item-box {
  padding: 10px;
  border-bottom: 1px solid #eee;

  a {
    display: flex;

    .van-image {
      margin-right: 10px;
      width: 120px;
      height: 120px;
      flex: 0 0 auto;
    }

    .desc {
      color: #555;
      flex: 1 0;

      .title {
        .clip;
        font-size: 14px;
        font-weight: normal;
        line-height: 20px;
        max-height: 40px;
      }

      .info {
        .clip;
        padding: 8px 0;
        color: #999;
        font-size: 12px;
        line-height: 16px;
        max-height: 32px;
      }

      .price {
        color: @theme;
        font-size: 14px;
      }
    }
  }

  /* 购物车独有 */
  &.goods-cart {
    border-bottom: none;

    a {
      .van-image {
        width: 100px;
        height: 100px;
      }

      .cart-desc {
        box-sizing: border-box;
        padding: 10px;
        min-width: 220px;
        color: #555;
        flex: 1 0;

        .title {
          .clip;
          font-size: 14px;
          font-weight: normal;
          line-height: 20px;
          max-height: 40px;
        }

        .info {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 10px;
          line-height: 28px;

          span {
            font-size: 14px;
            color: #ee0a24;
          }
        }
      }
    }
  }
}
</style>
```

搜索模块功能实现：

```vue
<template>
  <div class="search-box">
    <!-- 头部 -->
    <my-nav-bar>
      <template #title>
        <van-search v-model.trim="keyword" />
      </template>
      <template #right>
        <van-button type="primary" size="small" @click="searchHandle">
          搜索
        </van-button>
      </template>
    </my-nav-bar>
    <!-- 操作栏 -->
    <van-dropdown-menu active-color="#1baeae">
      <van-dropdown-item
        v-model="goodsCategoryId"
        :options="categoryOptions"
        @change="dropDownChange"
      ></van-dropdown-item>
      <van-dropdown-item
        v-model="orderBy"
        :options="sortOptions"
        @change="dropDownChange"
      ></van-dropdown-item>
    </van-dropdown-menu>
    <!-- 商品列表 -->
    <div class="content">
      <van-empty
        :image="search"
        description="赶快搜索你想要的产品吧"
        v-if="!searchList"
      />

      <van-empty
        description="非常抱歉，没有搜索到相关数据"
        v-if="searchList && searchList.length === 0"
      >
        <van-button plain color="#1baeae" @click="reset">
          重置搜索条件
        </van-button>
      </van-empty>

      <van-list
        v-if="searchList && searchList.length > 0"
        v-model="loading"
        :finished="finished"
        finished-text="数据已经加载完毕"
        loading-text="正要努力加载中..."
        @load="loadMore"
      >
        <goods-item
          v-for="item in searchList"
          :key="item.goodsId"
          :info="item"
        ></goods-item>
      </van-list>
    </div>
  </div>
</template>

<script setup>
import { onMounted, toRaw } from "vue";
import API from "../api/index.js";
import search from "../assets/images/kesrtd.png";
import GoodsItem from "../components/GoodsItem.vue";
import useCategoryStore from "../store/useCategoryStore.js";

const route = useRoute();
const store = useCategoryStore();
const { list } = storeToRefs(store);

const categoryOptions = ref([{ text: "全部分类", value: "" }]);
const goodsCategoryId = ref(parseInt(route.query.categoryId) || "");
const sortOptions = [
  { text: "综合排序", value: "" },
  { text: "时间排序", value: "new" },
  { text: "价格排序", value: "price" },
];
const orderBy = ref("");

onMounted(async () => {
  if (list.value.length == 0) {
    await store.getCategories();
  }
  // 写一个算法，计算出所有的三级分类
  const result = [];
  const rawList = toRaw(list.value);
  let index = 0;
  let current;
  // let a = 1;
  // a = 1  整体也有一个值  左值  a的值  1
  // a = 1;  a的值是1  a=1整体的值也是1
  while ((current = rawList[index++]) != null) {
    if (current.categoryLevel == 1) {
      rawList.push(...current.secondLevelCategoryVOS);
    } else if (current.categoryLevel == 2) {
      rawList.push(...current.thirdLevelCategoryVOS);
    } else {
      result.push({ text: current.categoryName, value: current.categoryId });
    }
  }
  categoryOptions.value.push(...result);
});

// =====================================================

const searchList = ref(null);
const loading = ref(false);
const finished = ref(false);
const pageNumber = ref(1);
const keyword = ref("");

const { proxy } = getCurrentInstance();

onMounted(async () => {
  if (goodsCategoryId.value == "" && keyword.value == "") {
    proxy.$showToast("请您先输入搜索关键词");
    return;
  }
  getList();
});

let getList = async () => {
  let { resultCode, data } = await API.querySearchList(
    pageNumber.value,
    keyword.value,
    orderBy.value,
    goodsCategoryId.value
  );

  if (+resultCode === 200) {
    let { list, totalPage } = data;
    if (searchList.value != null) {
      searchList.value = [...searchList.value, ...list];
    } else {
      searchList.value = [...list];
    }
    loading.value = false;
    if (pageNumber.value >= totalPage) {
      finished.value = true;
    }
  }
};

const reset = () => {
  pageNumber.value = 1;
  searchList.value = null;
  finished.value = false;
};

const dropDownChange = () => {
  reset();
  getList();
};

const loadMore = () => {
  pageNumber.value++;
  getList();
};

const searchHandle = () => {
  dropDownChange();
};
</script>

<style scoped>
.content {
  height: calc(100vh - 94px);
  overflow: scroll;
}
</style>

```

浏览器效果：

![1699862867571](./assets/1699862867571.png)

### 11，详情模块

路由也配置好了：

![1699862924229](./assets/1699862924229.png)

API接口，也封装好了：

![1699862958036](./assets/1699862958036.png)

有两个地方可以跳到商品详情，一个是首页面，一个是搜索页面，如下：

![1699863013423](./assets/1699863013423.png)

![1699863032797](./assets/1699863032797.png)

在详情页面中，需要获取商品的ID，如下：

![1699863141840](./assets/1699863141840.png)

拿着上面的id，发ajax请求，获取详情数据，如下：

![1699863328020](./assets/1699863328020.png)

开始写结构和样式，渲染数据：

![1699863515347](./assets/1699863515347.png)

参考代码：

```vue
<template>
  <div class="detail-box">
    <!-- 导航 -->
    <TopBar title="商品详情"></TopBar>

    <!-- 商品详情 -->
    <van-skeleton v-if="!goodsInfo" :row="5" title />
    <div class="info" v-if="goodsInfo">
      <van-image lazy-load :src="utils.processURL(goodsInfo.goodsCoverImg)" />
      <div class="desc">
        <h3 class="title">{{ goodsInfo.goodsName }}</h3>
        <p class="tag">{{ goodsInfo.goodsIntro }}</p>
        <p class="price">¥ {{ goodsInfo.sellingPrice }}</p>
      </div>
      <div class="tab">
        <a href="javascript:;">概述</a>
        <span>|</span>
        <a href="javascript:;">参数</a>
        <span>|</span>
        <a href="javascript:;">安装服务</a>
        <span>|</span>
        <a href="javascript:;">常见问题</a>
      </div>
      <div class="content" v-html="goodsInfo.goodsDetailContent"></div>
    </div>

    <!-- 相关操作 -->
    <van-action-bar style="max-width: 540px" v-if="goodsInfo">
      <van-action-bar-icon icon="chat-o" text="客服" />
      <van-action-bar-icon
        icon="cart-o"
        text="购物车"
        @click="$router.push('/cart')"
      />
      <!-- <van-goods-action-icon
        icon="cart-o"
        text="购物车"
        v-else
        :badge="badge"
        @click="$router.push('/cart')"
      /> -->
      <van-action-bar-button
        color="linear-gradient(90deg,#6bd8d8,#1baeae)"
        text="加入购物车"
        @click="handle('add')"
      />
      <van-action-bar-button
        color="linear-gradient(90deg,#0dc3c3,#098888)"
        text="立即购买"
        @click="handle('buy')"
      />
    </van-action-bar>
  </div>
</template>

<script setup>
import API from "../api/index.js";
import utils from "../assets/utils";

const route = useRoute();
const goodsId = ref(route.params.id);
const goodsInfo = ref(null);

onMounted(async () => {
  let { resultCode, data } = await API.queryGoodsInfo(goodsId.value);
  if (+resultCode === 200) {
    goodsInfo.value = data;
    return;
  }
  this.$toast.fail("当前网络繁忙，请您稍后再试");
});
</script>

<style lang="less" scoped>
.detail-box {
  padding-top: 46px;
  padding-bottom: 50px;
  .info {
    padding: 0 10px;
  }
}
.desc {
  .title {
    font-size: 18px;
    color: #555;
    font-weight: normal;
  }

  .tag {
    padding: 10px 0;
    font-size: 14px;
    color: #999;
  }

  .price {
    font-size: 18px;
    color: #f63515;
  }
}
.tab {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 0;
  a,
  span {
    font-size: 15px;
    color: #555;
  }
  a {
    padding: 0 10px;
  }
}
</style>
```

### 12，购物车模块
