---
title: 22-React精讲
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - js
categories:
 - base
---

## 一，React介绍



### 1，React介绍

目前市面上主流的前端框架：

- Vue
- React
- Angular
- ....



主流思想：不需要去操作DOM，而是**数据驱动视图**。



**直接操作DOM：**

- 直接操作DOM，会导致性能消耗大一点，可能会导致DOM的重排和重绘。
- 操作DOM，相对来说，会麻烦一点



**数据驱动视图：**

- 不需要直接操作DOM
- 操作数据（状态），数据变了，框架会按相关的流程，让页面重新渲染
  - Vue：数据是响应式的，改变数据，模板重新渲染
  - 小程序：通过setData这个API，就可以达到改变数据，并重新渲染页面
  - React：通过setState这个API，达到更新页面的效果
- 框架底层在实现页面时，也是需要操作DOM的，只不过会尽可能少的操作DOM
  - 构建了一套 虚拟DOM=>真实DOM的渲染体系
  - 尽可能少的操作DOM，这样会尽可能减少重排和重绘。
- 提高开发效率，性能也会好很多



​	**React** 是一个用于构建用户界面的 JavaScript 库。React 从诞生之初就是可被逐步采用的，因而**你可以按需引入或多或少的 React 特性**。React特点：

![1710984171505](./assets/1710984171505.png)



**什么是声明式：**

- 前面学习的html标签就是声明式的。在vue中，要实现一个轮播图的功能，也是可以把轮播图封装成一个组件。声明式编程的对立面是命令式编程。

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  <body>
      <h1>今天学习React~</h1>
      <p>我是一个孤独的P标签</p>
      <img src="./imgs/01.png" alt="">
  
      <div class="carousel">
          <ul>
              <li><img src="1.png" alt=""></li>
              <li><img src="2.png" alt=""></li>
              <li><img src="3.png" alt=""></li>
          </ul>
      </div>
      <script>
          // 这种编程，叫命令式编程
          // 还有一堆的JS逻辑，还需要写很多样式
      </script>
  
  
      <hr>
  
      <!-- 声明式，组件化编译 -->
      <Carousel imgs="[1.png,2.png,3.png]"></Carousel>
  </body>
  </html>
  ```

  





官网：

- 老版 [已过时——React 中文文档 (reactjs.org)](https://zh-hans.legacy.reactjs.org/)

  ![1710984101515](./assets/1710984101515.png)

- 新版 [React 官方中文文档 (docschina.org)](https://react.docschina.org/)

  ![1710984122445](./assets/1710984122445.png)



**React版本：**

- 很早之前，是15版本，不用了。
- 16版本，项目用的还是比较多的。
- 17版本，语法和16相比，没有什么变化，只是在底层处理机制上，有所升级。
- 18版本，当前最新版本，不管是语法还是底层机制，都有变化。





### 2，React版本的HelloWorld



直接上代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- react.js  production 表示生产环境  会对代码进行压缩和混淆-->
    <!-- let userName = "malu"   let a = "malu" -->
    <script src="https://unpkg.com/react@^16/umd/react.production.min.js"></script>
    <!-- react-dom.js 和浏览器相关的，操作DOM -->
    <script src="https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js"></script>
    <!-- babel.js 是编译js代码 Babel 是一个 JavaScript 编译器。 -->
    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>
</head>
<body>
    <div id="root"></div>
    <!-- <script>
        console.log(React)
        console.log(ReactDOM)
    </script> -->

    <!-- script标签中的type的默认值是：text/javascript -->
    <script type="text/babel">
        // 定义了一个React组件
        class App extends React.Component{
            render(){
                return <h1>Hello React~</h1>
            }
        }

        ReactDOM.render(<App/>,document.getElementById("root"))
    </script>
</body>
</html>
```



效果如下：

![1710985637174](./assets/1710985637174.png)



为什么script标签中写的是text/babel？我们在组件中写的html标签，并不会直接渲染，会把你写的代码转化成js方法去执行。

![1710985845207](./assets/1710985845207.png)



我们是可以直接写方法的，不需要写标签：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/react@^16/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>
</head>
<body>
    <div id="root"></div>
    <script> 
        class App extends React.Component{
            render(){
                // 第一个参数是必填，传入的是似HTML标签名称，eg: ul, li 
                // 第二个参数是选填 对象，表示的是标签属性，
                // 第三个参数以后是选填, 子节点
                return React.createElement("h1",null,"Hello React~")
            }
        }
        ReactDOM.render(React.createElement(App,null),document.getElementById("root"))
    </script>
</body>
</html>
```



效果：

![1710986153952](./assets/1710986153952.png)





再次看一下babel官网：

![1710987121456](./assets/1710987121456.png)



书写的代码：

```jsx
class App extends React.Component{
     render(){
         return (
             <div className="app">
                 <h1>hello react!</h1>
                 <h1>hello react!</h1>
                 <h1>hello react!</h1>
                 <p>
                     <span>span</span>
                 </p>
             </div>
         )
     }
 }
```



通过babel编译后的代码：

```js
        class App extends React.Component {
            render() {
                return /*#__PURE__*/React.createElement("div", 
                {
                    className: "app"
                }, 
                /*#__PURE__*/React.createElement("h1", null, "hello react!"), 
                /*#__PURE__*/React.createElement("h1", null, "hello react!"), 
                /*#__PURE__*/React.createElement("h1", null, "hello react!"), 
                /*#__PURE__*/React.createElement("p", null, 
                                                /*#__PURE__*/React.createElement("span", null, "span")));
            }
        }
```



小小的作业：把下面标签的形式，转化成React.createElement的形式。

```html
<div className="App">
     <ul className='url_wrap'>
         <li className='item'>商城</li>
         <li className='item'>购物车</li>
         <li className='item'>订单</li>
         <li className='item'>
             <span>我的</span>
         </li>
     </ul>
</div>
```





### 3，脚手架

​	现在开发项目，都是组件化，工程化的。我们可以基于webpack自己去搭建一套工程化的架子，样这非常麻烦，复杂。React官方为我们提供了一个脚手架，叫create-react-app。默认情况下，就把webpack相关的配置就处理好了。只需要基于这个脚手架，去开发项目就OK。

 

安装脚手架：

```
npm i create-react-app -g 
```

![1710987391831](./assets/1710987391831.png)



验证是否安装成功：

![1710987436456](./assets/1710987436456.png)



安装后完，就可以创建一个项目：

```
create-react-app demo
```

![1710987488859](./assets/1710987488859.png)



安装完后，进入项目，启动项目，如下：

![1710987561017](./assets/1710987561017.png)

![1710987592725](./assets/1710987592725.png)

![1710987660176](./assets/1710987660176.png)



访问之：

![1710987695106](./assets/1710987695106.png)



默认会安装

- react，是React框架的核心，默认安装的是最新版本，学的话，就学习最新版本。
- react-dom，React视图渲染的核心。基于React构建WebApp。
- react-native，构建渲染原生App的。



使用vscode打开项目，如下：

![1710987774933](./assets/1710987774933.png)





打开package.json文件，如下：

![1710986689494](./assets/1710986689494.png)

![1710986696821](./assets/1710986696821.png)

![1710986703631](./assets/1710986703631.png)

![1710986712846](./assets/1710986712846.png)





去简化一下代码，如下：

![1710988284802](./assets/1710988284802.png)



目录结构：

```
demo 
  |- node_modules   项目的依赖
  |- src   我们写的代码基本上都是放在src下面。webpack打包时，只对src目录进行打包
      |- index.js  项目的入口
  |- public  入页面的模板
      |- index.html 
  |- package.json
  |- ....
```



## 二，JSX

​	

### 1，什么是JSX

​	jsx是用来给组件提供视图的，类似于vue中的模板。就是js和html标签混合在一起，并不是我们之前玩的字符串拼接。这种语法也会通过babel进编译，编译成js代码。JSX可以生成React元素。说白了，就是React.createElement函数调用后得到一个React元素。

![1710988748204](./assets/1710988748204.png)





### 2，JSX细节1

在jsx中，可以通过{}胡子语法，嵌入表达式。任何有值的内容都是表达式。代码如下：

```js
import React from "react"
import ReactDOM from "react-dom"

let str = "今天学习React so easy~"
let age = 100;

let element = <div>
    <p>我是一个P标签</p>
    <p>{str}</p>
    <p>{age}</p>
</div>

// 之前你渲染的是<App/>标签，现在我直接渲染React元素
// 你写的jsx，最终也会变成React元素
ReactDOM.render(element,document.getElementById("root"))
```



效果：

![1710989050229](./assets/1710989050229.png)



在ReactDOM.render时，不能直接把HTML或BODY作为根容器，必须指定一个额外的盒子，如下：

![1710989174392](./assets/1710989174392.png)



![1710989318734](./assets/1710989318734.png)



也就是说，不能把html或body当成根容器。



### 3，JSX细节2

在构建视图时，必须要有一个唯一的根节点，如果没有，就报错，如下：

![1710989512442](./assets/1710989512442.png)





也可以指定一个空标签：

![1710989535852](./assets/1710989535852.png)

![1710989655098](./assets/1710989655098.png)



我们要么使用一个div包起来，这样就会多一个div嵌套。也可以使用React中帮我们提供的组件（React.Fragment），包起来。这样的话，最外层就没有多余的div。



React给我们提供的一个特殊的组件，叫Reat.Fragment，是一个空标签。作用：

- 保证了视图只有一个根标签
- 也不新增一个HTML层级结构



### 4，JSX细节3

在{}胡子语法中，可以嵌入不同的值，下面的语法，需要大记一下。如下：

- number / string 值是啥，就渲染出来什么

  ![1710989917202](./assets/1710989917202.png)

- boolean / null / und / Symbol / BigInt 渲染出来的内容是空

  ![1710989977617](./assets/1710989977617.png)

- 渲染对象，直接报错了，但是有特殊情况

  ![1710990097425](./assets/1710990097425.png)

  - jsx元素（本质也是一个对象，这个对象就不会报错）

    ![1710990183029](./assets/1710990183029.png)

  - 给标签设置style行内样式时，也必须写成对象

    ![1710990219587](./assets/1710990219587.png)

- 渲染数组，会把数组中的每一项分别拿出来渲染，并不是变为字符串渲染，中间没有逗号

  - 数组中是number、 string，也是直接渲染

  - 数组中是boolean / null / und / Symbol / BigInt，渲染出来的内容是空

  - 数组中放jsx元素也是会被渲染的

    ![1710990291819](./assets/1710990291819.png)

- 渲染函数，不支持在{}中渲染函数的，但是函数也可以是组件，要渲染组件通过标签的形式渲染。

  ![1710991184463](./assets/1710991184463.png)

- ....





### 5，JSX细节4

给标签设置行内样式，如下：

```js
import React from "react"
import ReactDOM from "react-dom/client"

const root = ReactDOM.createRoot(document.getElementById("root"))

let element = 
    <>
        {/* 行内样式：不能直接写字符串，样式需要放到对象中，基于对象的格式处理的 */}
        {/* 样式是多个单词时，在css中，使用中划线命名，在jsx中，使用小驼峰命名 */}
        {/* 给标签添加clsss属性时，不能使用class，要使用className, class是一个关键字 */}
        <div className="box" style={ {color:"red",fontSize:"20px"} }>我是一个小小的div</div>
    </>

root.render(element)
```



效果：

![1710991437430](./assets/1710991437430.png)





有一个数据，如果是true，就显示button按钮，否则就隐藏buton按钮，代码如下：

```js
import React from "react"
import ReactDOM from "react-dom/client"

const root = ReactDOM.createRoot(document.getElementById("root"))

let flag = true;

let element = 
    <>
       {/* 通过样式控制是否显示，但是button已经创建了 */}
       <button style={ {display:flag ? 'block':'none'} }>登录</button>

       {/* 控制它创建或销毁 */}
       { flag ? <button>注册</button> : null }
    </>

root.render(element)
```



![1710991672924](./assets/1710991672924.png)



再进一步，通过一个数据，控制button中的文本，如下：

![1710991778526](./assets/1710991778526.png)





从服务器调用接口，获取到一片数据，渲染数据，如下：

![1710992141500](./assets/1710992141500.png)

你循环创建的元素一定要设置key，表示唯一值，用于优化DOM-DIFF的。





我要循环出5个button按钮，如下：

![1710992364167](./assets/1710992364167.png)



### 6，JSX细节5



## 三，组件初识



### 1，无状态组件



### 2，有状态组件











































