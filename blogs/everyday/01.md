---
title: 01-每日一题
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - 每日一题
categories:
 - 每日一题
---

## 一，小程序登录(码路于老师)



### 1，流程分析

用户登录是微信小程序的重要内容，那么今天就讲用户登录的一个流程，当然微信官方文档也有相关的一个登录流程图，这里也给大家附上地址：[官方 | 小程序登录](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html) 。



用户登录流程可以用这一句话简单概括：3个角色，4个步骤 ，3个角色就是

- 小程序 (通过微信开发者工具创建)

- 开发者服务器 （本地的服务器来实现）

- 微信接口服务  （微信官方提供文档）

  

4个步骤就是：

1. 小程序获取code
2. 将code发送到开发者服务器
3. 开发者服务器通过微信接口服务校验登录凭证 
4. 开发者服务自定义登录的状态



![1713519457313](./assets/1713519457313.png)

**流程：**

1. 首先小程序通过wx.login()获取登录凭证code，每次调用code均不同，有效时间是5分钟，该code被微信接口服务验证一次就会失效了，
2. 小程序获取到code之后，通过wx.request()将code发送到开发者服务器，开发者服务器将appid，appSecret（密钥），和code发送给微信接口服务去校验登录凭证，成功会返回session_key(会话信息记录)和openid(用户唯一标识)
3. 用户登录成功后，开发者服务器可以将openid和session_key保存，生成一个自定义登录态的token(令牌)响应回去给小程序
4. 通过token可以查询openid和session_key，小程序下次请求只要携带着token就可以证明已经登录。



### 2，搭建开发者服务器

在实际开发中是去购买服务器的，那么这里仅限了解和搭建，那么就用本地localhost:3000作为服务器的端口，选用node.js来搭建开发者服务器 。创建服务器代码如下：

```js
const express = require('express') 				
const bodyParser = require('body-parser')		
const request = require('request')	
const app = express()		

app.use(bodyParser.json())	

app.post('/login', (req, res) => {
    
})

app.listen(3000, () => {
    console.log('server running...');
})
```



### 3，获取code

创建小程序项目：

![1713521752866](./assets/1713521752866.png)





小程序通过wx.login()获取登录凭证code，那么在微信开发者工具中创建一个名为Login的小程序，在这里要实现一个小程序启动时自动执行登录的操作，在app.js文件中来编写代码，可以在onLaunch中进行触发；

![1713521911012](./assets/1713521911012.png)

```js
App({
    onLaunch:function(){
       this.login()  
    },
    login:function(){
        wx.login({
            success:(res)=>{
                console.log("code: " + res.code);
            }
        })
    }
})
```

以上就是获取code，此时可以在控制台上看到打印出来的code



### 3，将Code发送到开发服务器

通过wx.request()将code发送到开发者服务器

![1713522013828](./assets/1713522013828.png)

```js
login:function(){
    // wx.login()获取code
        wx.login({
            success:(res)=>{
                console.log("code: " + res.code);
                wx.request({
                    url:'http://127.0.0.1:3000/login',
                    method:'POST',
                    data:{
                        code : res.code
                    }
                })
            }
    })
}
```



在开发者服务器当中来个响应请求接口，请求的方式是post，那可以在index.js文件当中编写代码，这里如果你安装了nodemon的话可以不用重新启动，如果没有，则需要命令行重新输出node index.js重新运行。

![1713522075747](./assets/1713522075747.png)

```js
app.post('/login',(req,res)=>{
    console.log('code: '+req.body.code) 
})
```



可以看到小程序通过wx.request()的方式成功将code发送到开发者服务器上；



### 5，通过微信接口服务校验

​	开发者服务器将appid，appSecret（密钥），和code发送给微信接口服务去校验登录凭证，成功会返回session_key(会话信息记录)和openid(用户唯一标识)；这时主要是编写开发者服务器当中的代码，在此之间需要开发者将自己的appid和appSecret密钥准备好，这里也给大家将如何获取到；



获取appid和(用户唯一标识)，appSecret(用户密钥)，如下：

![1713522145771](./assets/1713522145771.png)

```
AppID(小程序ID)         wx154afd6feeabcd59
AppSecret(小程序密钥)	723d3311bd8d194789437b7b8e99ec33
```



现在编写开发者服务器当中的代码；有了code，appid，appsecret就可以进行微信接口服务校验了，附上这个官方链接用到复制即可，以防自己打错。连接：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html



代码：

![1713522340710](./assets/1713522340710.png)

```js
const express = require('express') 				
const bodyParser = require('body-parser')		
const request = require('request')			
const app = express()

app.use(bodyParser.json())

const wx = {
    appid: 'wx154afd6feeabcd59',  // 填写用户自己的appid
    secret: '723d3311bd8d194789437b7b8e99ec33'  // 填写用户自己的密钥
}

app.post('/login', (req, res) => {
    console.log('code: ' + req.body.code) // 打印一下code
    var url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + wx.appid + '&secret=' + wx.secret + '&js_code=' + req.body.code + '&grant_type=authorization_code'
    request(url, (err, response, body) => {
        //	可以获取到 session_key(会话信息) 、 openid(用户唯一标识)
        console.log('session: ' + body)
        //  上面的session信息是字符串数据，通过JSON.parse()转成js对象
        var session = JSON.parse(body)
        console.log(session);
    })
})

app.listen(3000, () => {
    console.log('server running...');
})

```



成功之后会返回openid和session_key，openid是用户在这个小程序上唯一的id，不同小程序用户的id都不一样，session_key是用户的会话信息记录；将结果打印出来，可以在开发者服务器当中看到如下：

![1713522389192](./assets/1713522389192.png)

以上就是校验成功之后所返回的session_key和openid；这里注意的是账户不得是测试的账户，否则获取不到code，获取不到code，则校验不能通过；



### 6，开发者服务器自定义登录态

​	通过校验成功后返回的session_key和openid进行保存，实际开发中，通常会使用数据库来保存数据，比如可以用MongoDB，这里就不搭建数据库来存数据，将其作为数据保存到我们的变量当中；openid是用户的唯一标识，所以可以判断session中是否存有openid，如果有我们才返回一个token回去，返回去的token不能是固定的，固定存在一定的分析，这时可以用这个时间戳生成token，当然再实际开发中是推荐使用比较成熟模块生成token，避免token被伪造带来不好的影响，这里我们就通过时间戳的方式来生成token给大家演示这个过程；

```js
const express = require('express') 				
const bodyParser = require('body-parser')		
const request = require('request')				
const app = express()

app.use(bodyParser.json())

const wx = {
    appid: 'wx154afd6feeabcd59',  // 填写用户自己的appid
    secret: '723d3311bd8d194789437b7b8e99ec33'  // 填写用户自己的密钥
}

// 模拟数据库存放数据
var db = {
	user: {},		// userInfo
    session: {}		// 保存 openid 和session_key会话信息 
}

app.post('/login', (req, res) => {
    console.log('code: ' + req.body.code) // 打印一下code
    var url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + wx.appid + '&secret=' + wx.secret + '&js_code=' + req.body.code + '&grant_type=authorization_code'
    request(url, (err, response, body) => {
        //	可以获取到 session_key(会话信息) 、 openid(用户唯一标识)
        console.log('session: ' + body)
        //  上面的session信息是字符串数据，通过JSON.parse()转成js对象
        var session = JSON.parse(body)
        console.log(session);
        // 将openid和session_key保存后响应token回去,openid是用户的唯一标识
        if(session.openid){
            var token = 'token_' + new Date().getTime() 
            db.session[token] = session
            if(!db.user[session.openid]) {
                db.user[session.openid] = {
                    state:1  // 成功登录可以获取
                }
            }
            console.log(db);
        }
        res.json({
            token: token  // 返回token
        })
    })
})

app.listen(3000, () => {
    console.log('server running...');
})
```



打印结果测试：

![1713522934586](./assets/1713522934586.png)



成功之后返回token，可以在小程序当中的wx.request()请求校验当中添加请求成功之后将返回的数据进行打印到小程序的控制台上；

![1713523033531](./assets/1713523033531.png)

```js
App({
  onLaunch: function () {
    this.login()
  },
  login: function () {
    wx.login({
      success: (res) => {
        console.log("code: " + res.code);
        wx.request({
          url: 'http://127.0.0.1:3000/login',
          method: 'POST',
          data: {
            code: res.code
          },
          success: (res) => {
            // 将请求成功的token打印
            console.log("token : " + res.data.token);
          }
        })
      }
    })
  }
})
```



将返回到小程序的token进行一个缓存，小程序的下次请求时只要携带token，就可以证明用户已经登录，那么我们在进入小程序之前就需要将检查是否登录。



### 7，检查用户是否登录

在检查用户登录之前，将返回的token进行数据缓存，token是公共数据，是多个页面当中需要用到的，可以定义为全局的globalData；数据缓存可以用wx.setStorage()。

```js
App({
  globalData: {
    token: "",
  },
  onLaunch: function () {
    // 这样写，每次刷新，都是重新获取token，都去调接口了
    this.login()
  },
  login: function () {
    wx.login({
      success: (res) => {
        console.log("code: " + res.code);
        wx.request({
          url: 'http://127.0.0.1:3000/login',
          method: 'POST',
          data: {
            code: res.code
          },
          success: (res) => {
            // 将请求成功的token打印
            console.log("token : " + res.data.token);
            // 将token保存为公共数据（多页面使用->全局globalData）
            this.globalData.token = res.data.token
            // 将token保存在数据缓存中（下次无需重新获取token）
            wx.setStorage({
              key: 'token',
              data: res.data.token
            })
          }
        })
      }
    })
  }
})
```



可以查看是否已经缓存下来，打开控制台查看，如下图：

![1713523269679](./assets/1713523269679.png)



上述内容将返回token缓存下来，那么检查的是否需要先从缓存当中看是否有token，如果有则可以请求服务器去检验token是否有效，如果没有token，则按照原来的方式去调用login()来获取token；

```js
App({
  globalData: {
    token: "",
  },
  onLaunch: function () {
    // 检测用户是否登录
    this.checkLogin(res => {
      console.log('is_login : ', res.is_login);
      // 未登录 -> login()
      if (!res.is_login) {
        // 调用Login
        this.login();
      }
    })
    // this.login()
  },
  checkLogin:function(callback){
    var token = this.globalData.token
    if(!token){
      // 从缓存中获取token
      token = wx.getStorageSync('token')
      if(token){
        this.globalData.token = token
      }else{
        callback({ is_login : false })
      }
    }
     // 发送请求检验token是否存在
     wx.request({
      url: 'http://127.0.0.1:3000/checklogin',
      data:{
        token : token
      },
      success:(res)=>{
        console.log(res);
        callback({
          is_login:res.data.is_login
        })
      }
    }) 
  },
  login: function () {
    wx.login({
      success: (res) => {
        console.log("code: " + res.code);
        wx.request({
          url: 'http://127.0.0.1:3000/login',
          method: 'POST',
          data: {
            code: res.code
          },
          success: (res) => {
            // 将请求成功的token打印
            console.log("token : " + res.data.token);
            // 将token保存为公共数据（多页面使用->全局globalData）
            this.globalData.token = res.data.token
            // 将token保存在数据缓存中（下次无需重新获取token）
            wx.setStorage({
              key: 'token',
              data: res.data.token
            })
          }
        })
      }
    })
  }
})
```



响应接口请求，查询保存的数据库当中是否有该token的存在，判断取出的session是否为undefined，如是则表示token值已经失效了，如有缓存token且token有效则表示用户已经登录；

```js
const express = require('express') 				
const bodyParser = require('body-parser')		
const request = require('request')				
const app = express()

app.use(bodyParser.json())

const wx = {
    appid: 'wx154afd6feeabcd59',  // 填写用户自己的appid
    secret: '723d3311bd8d194789437b7b8e99ec33'  // 填写用户自己的密钥
}

// 模拟数据库存放数据
var db = {
	user: {},		// userInfo
    session: {}		// 保存 openid 和session_key会话信息 
}

app.post('/login', (req, res) => {
    console.log('code: ' + req.body.code) // 打印一下code
    var url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + wx.appid + '&secret=' + wx.secret + '&js_code=' + req.body.code + '&grant_type=authorization_code'
    request(url, (err, response, body) => {
        //	可以获取到 session_key(会话信息) 、 openid(用户唯一标识)
        console.log('session: ' + body)
        //  上面的session信息是字符串数据，通过JSON.parse()转成js对象
        var session = JSON.parse(body)
        console.log(session);
        // 将openid和session_key保存后响应token回去,openid是用户的唯一标识
        if(session.openid){
            var token = 'token_' + new Date().getTime() 
            db.session[token] = session
            // console.log(db);
            if(!db.user[session.openid]) {
                db.user[session.openid] = {
                    state:1  // 成功登录可以获取
                }
            }
            console.log(db);
        }
        res.json({
            token: token  // 返回token
        })
    })
})


app.get('/checklogin', (req, res) => {
    var session = db.session[req.query.token]
    console.log('checklogin: ', session)
    // 将用户是否已经登录的布尔值返回给客户端
    res.json({
        is_login: session !== undefined
    })
})

app.listen(3000, () => {
    console.log('server running...');
})
```



现在缓存当中有了token值，我们重新编译一下，此时缓存当中是有token值的，is_login的值为 true ，证明用户已经登录；

![1713523777457](./assets/1713523777457.png)



完整代码，客户端：

```js
App({
  globalData: {
    token: "",
  },
  onLaunch: function () {
    // 检测用户是否登录
    this.checkLogin(res => {
      console.log('is_login : ', res.is_login);
      // 未登录 -> login()
      if (!res.is_login) {
        // 调用Login
        this.login();
      }
    })
    // this.login()
  },
  checkLogin:function(callback){
    var token = this.globalData.token
    if(!token){
      // 从缓存中获取token
      token = wx.getStorageSync('token')
      if(token){
        this.globalData.token = token
      }else{
        callback({ is_login : false })
      }
    }
     // 发送请求检验token是否存在
     wx.request({
      url: 'http://127.0.0.1:3000/checklogin',
      data:{
        token : token
      },
      success:(res)=>{
        console.log(res);
        callback({
          is_login:res.data.is_login
        })
      }
    }) 
  },
  login: function () {
    wx.login({
      success: (res) => {
        console.log("code: " + res.code);
        wx.request({
          url: 'http://127.0.0.1:3000/login',
          method: 'POST',
          data: {
            code: res.code
          },
          success: (res) => {
            // 将请求成功的token打印
            console.log("token : " + res.data.token);
            // 将token保存为公共数据（多页面使用->全局globalData）
            this.globalData.token = res.data.token
            // 将token保存在数据缓存中（下次无需重新获取token）
            wx.setStorage({
              key: 'token',
              data: res.data.token
            })
          }
        })
      }
    })
  }
})
```



服务器：

```js
const express = require('express') 				
const bodyParser = require('body-parser')		
const request = require('request')				
const app = express()

app.use(bodyParser.json())

const wx = {
    appid: 'wx154afd6feeabcd59',  // 填写用户自己的appid
    secret: '723d3311bd8d194789437b7b8e99ec33'  // 填写用户自己的密钥
}

// 模拟数据库存放数据
var db = {
	user: {},		// userInfo
    session: {}		// 保存 openid 和session_key会话信息 
}

app.post('/login', (req, res) => {
    console.log('code: ' + req.body.code) // 打印一下code
    var url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + wx.appid + '&secret=' + wx.secret + '&js_code=' + req.body.code + '&grant_type=authorization_code'
    request(url, (err, response, body) => {
        //	可以获取到 session_key(会话信息) 、 openid(用户唯一标识)
        console.log('session: ' + body)
        //  上面的session信息是字符串数据，通过JSON.parse()转成js对象
        var session = JSON.parse(body)
        console.log(session);
        // 将openid和session_key保存后响应token回去,openid是用户的唯一标识
        if(session.openid){
            var token = 'token_' + new Date().getTime() 
            db.session[token] = session
            // console.log(db);
            if(!db.user[session.openid]) {
                db.user[session.openid] = {
                    state:1  // 成功登录可以获取
                }
            }
            console.log(db);
        }
        res.json({
            token: token  // 返回token
        })
    })
})


app.get('/checklogin', (req, res) => {
    var session = db.session[req.query.token]
    console.log('checklogin: ', session)
    // 将用户是否已经登录的布尔值返回给客户端
    res.json({
        is_login: session !== undefined
    })
})

app.listen(3000, () => {
    console.log('server running...');
})
```



项目中用到的依赖：

```json
"dependencies": {
    "body-parser": "^1.20.0",
    "express": "^4.18.1",
    "request": "^2.88.2"
}
```





## 二，前端到底死没死



### 1，互联网就业行情我的感受

关于目前互联网就业行情我的感受：

- 国家层面统计的就业情况我就不想去讨论，跟我们普通人没啥关系，只想说来自身边的真实感受。
- 2019年之前，随便投个简历就能有一大堆面试。
- 2023年开始，除了华为od、外包就真的没有好工作了。大量公司裁员，倒闭。
- 口罩之后，好像Jing Ji也并没有恢复，也没有出现类似互联网这种提供大量高薪的就业岗位。
- AI，半导体、新能源汽车行业有不错发展，终究难以创造大量的新增就业岗位。并且待遇相较于以前的互联网也是有着巨大差距。
- 半导体、新能源汽车行业，需要大量的前期资产投入，小微公司没法入场，只能是大公司和大资本的内部游戏。
- 这2年随着互联网红利的逐渐消失，大量普通公司所产生的高薪岗位消失了，叠加上大厂战略的收缩，涌出了大量的程序员和其它从业人员。



### 2，前端岗位依然存在，岗位减少了90%



除了个别职业，很少有职业能在短时间内彻底玩完的。总归有人能继续在行业里生存。都2024年了，jQuery代码现在还有人要写呢，python的django也有人在写。



土木工程现在依然存在，但现在还有谁会对土木抱有预期？



国企大下岗的时，同样有很多人依旧拿着铁饭碗。总会有能力高超、运气极好的人能在行业里生存下去。所以说，前端行业中依然会有一些人坚守下去，只是很多人已经入局不了了。



### 3，我是如何感觉前端已死



当**互联网、短视频** 上冒出来一堆自称很牛的人，吹嘘自己很厉害的人，出来拍 **短视频** ，或者出来唱衰互联网，引流的。无论是 **卖课** 也好，创业也罢，都无一证明着，前端这条路变难走了。



搞自媒体或短视频，需要学习拍摄、剪辑、配音、文案的功夫来赌一个不确定的自媒体行业，显然，对前端开发来说，**努力** 已经换不来收获了。



### 4，现在的行情

如果前端没死，你可以裸辞试一下，感受一下：

- 感受一下 **1%** 的投递回复率；
- 感受一下 **5%** 的面试邀请率；
- 感觉一下企业对学历的要求;
- 你有营业执照的话，你去发布一个岗位试2个小时，200份的简历;



### 5，未来

- 主前端：持续学习后端，争取在公司转型到后端开发，同时保持较高的前端开发能力
- 主后端：在后端深耕，前端要会但不要太把精力放在这里

- 前端能力强的：持续在前端深耕、尝试后端转向、尝试副业
- 前端能力弱的：尽早直接转后端，尽早尝试副业
- 拥抱自媒体，独立开发



## 三，IT岗位那么多，如何选择？



我的偏见：**适合写程序的人并不多**



### 1，语言的选择/岗位的选择



Java后端：

- 由美国SUN公司发明于1995年，是目前业界应用最广泛、使用人数最多的语言，连续多年排名世界第一，可以称之为“计算机语言界的英语”
- Java广泛应用于企业级软件开发、安卓移动开发、大数据云计算等领域，几乎涉及IT所有行业。
- 再怎么抨击Java，但目前仍是需要最大的开发岗，就业首选，易学，门槛低，天花板高。
- 培训机构输出了大量的Java程序员，导致Java非常卷。
- 专科直接放弃，至少本科起步（除非技术确实吊）
- 本科（二本以上）本专业，学Java还是可以的，不学Java你能做什么



前端（JS/TS）

- 2023年开始，已经被攻击的体无完肤了，大形式不好，先裁的就是测试和前端
- 前端的需求，要么压到一个人身上，要么后端程序员代替了
- 目前如果是本科学习，直接上全栈。专科直接放弃
- 研究生以上学历，不如直接上AI算法，大数据方法



Python AI方向

- 国内做AI的公司不多，岗位不多。

- 不是研究生以上学历，直接放弃，学历这一关就直接Pass掉了
- Python是一门万能语言，所以一直在排行榜最前面。
- AI方向，算法和大模型占95%，Python就占5%而已。



Python 爬虫方向

- 暂时不怎么吃学历，找工作岗位相对来说还可以的也就爬虫/逆向。
- 好的爬虫程序员待遇是非常高的
- 稍有不当，容易被叫去写保证书（注意法律风险）



Python数据分析

- 也是比较吃学历，建议也是研究生起



大数据方向：

- 本科玩不了，目前岗位也不多
- 有大数据的公司，不多



Go语言：

- Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易
- Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言
- 对于高性能分布式系统领域而言，Go语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。
- 大厂使用或初创小公司使用，开发效率高，岗位不多。
- 很多大厂主要的后端还是Java，可以个别系统会使用Go。
- PHP，C++程序员很多都在转Go。



C语言：

- C语言诞生于1972年，可称为现在高级语言的鼻祖，由著名的贝尔实验室发明。
- C语言是人为追求结构化，模块化，高效率的语言之花。
- 在底层编程，如嵌入式，病毒开发等应用，可以替代汇编语言来开发系统程序。
- 在高层应用，也可以开发从操作系统到各种应用软件。
- 嵌入式，网安，驱动开发等。



C++开发：

- 作为C语言的扩展，C++是贝尔实验室于80年代推出的。C++是一种混合语言，既可以实现面向对象编程，也可以开发C语言面向过程风格的程序。
- C++语言在科学计算、操作系统、网络通讯、系统开发、引擎开发中仍然被大量使
- 对开发者要求比较高，相当来说并不是特别卷，岗位不多
- 什么都能做，效率非常底，性能高。
- 游戏开发早期可能使用C++，现在有些会使用Go。
- 待遇非常高，比较难学。



C#开发：

- C#是微软公司发布的一种面向对象的、运行于.NET Framework之上的高级程序设计语言。
- C#在基于windows操作系统的应用开发这一领域在取代C++，占据主导地
- Unity3D开发游戏时，使用C#和avascript
- 国内用的不多，项目部署在window上。
- 上位机



PHP开发：

- 一般用于WEB开发领域
- 大量的中小型网站以及某些大型网站使用PHP开发
- 国内很少了已经。



Rust语言：

- Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言
- Rust 语言可以用于开发
  - 传统命令行程序- Rust 编译器可以直接生成目标可执行程序，不需要任何解释程序。
  - Web 应用- Rust 可以被编译成 WebAssembly，WebAssembly 是一种JavaScript 的高效替代品。
  - 网络服务器-Rust 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。
  - 嵌入式设备-Rust同时具有avaScript一般的高效开发语法和C语言的执行效率，支持底层平台的开发。



测试：

- 自动化测试，性能测试，测试平台开发
- 待遇比开发低一些

- 走测开，走自动化测试
- 岗位少，公司裁人，先裁测试



运维：

- 中不公司，很少有运维，运维的事都是程序员自己做了
- 专科起步就可以，但不要迷信抖音某个博主所谓的运维（云计算）形式大好
- Python在运维方向仅仅是一个工具



嵌入式或网安（最近火一点）：

- 岗位并不多，网安/Zhong Mei关系（大环境）/护网
- 大专就可以干，网安学的东西特别杂，起薪比较低。当然网络安全专家就另说了。
- 2023年开始，大量的人开始搞嵌入式和网安，现在也比较卷，慢慢也和java和前端差不多了，也会开始卡学历。
- 中国不缺人，每年都有上千万的大生学毕业



游戏：

- 现在走下坡路
- 待遇也非常高



区块链/web3/元宇宙

- 炒作，没有什么特别落地的东西出来
- 公司说被端了就被端了
- 国外会有一些职位



## 四，大屏适配(码路于老师)



### 1，移动端适配

前面设置视口的目的是防止盒子压缩，说白了，就是让一个盒子在所有的手机上显示的大小是一样的。那这样合理呢？

答：不合理，手机屏幕有大有小，我们想的效果是，屏幕大的手机，盒子显示的大一点，屏幕小的手机，盒子显示的小一点。这就需要我们进行适配。所谓的适配就是同一个盒子，在大屏上显示大一点，在小屏上显示小一点。

#### 1）rem+媒体查询做适配

先说一下，rem这个单位，如下：

![1714287632872](assets/1714287632872.png)

参考代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        html {
            /* rem  root 的意思   rem是一个相对单位，是相对于根标签（html）中的fonts-size来说的 */
            /* font-size: 16px; */
            /* 1rem = 16px  2rem = 32px  3rem = 48px */

            font-size: 18px;
            /* 1rem = 18px  2rem = 36px */
        }

        div {
            /* width: 100px; */
            /* height: 100px; */

            width: 10rem;
            height: 10rem;
            background-color: gold;
        }
    </style>
    <title>Document</title>
</head>

<body>
    <div>
        我是一个孤独的div
    </div>
</body>

</html>
```

然后，使用rem+媒体查询做适配，代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        @media only screen and (device-width: 750px) {
            html {
                /* 1rem = 100px  75px = 0.75rem   375px = xxrem */
                font-size: 100px;
            }
        }

        @media only screen and (device-width: 375px) {
            html {
                font-size: 50px;
            }
        }

        @media only screen and (device-width: 320px) {
            html {
                font-size: 42.666px;
            }
        }

        @media only screen and (device-width: 414px) {
            html {
                font-size: 55.2px;
            }
        }

        div {
            font-size: 0.75rem
        }

        img {
            width: 3.75rem;
            border: 1px solid red;
        }
    </style>
    <title>Document</title>
</head>

<body>
    <div>牧童骑黄牛歌声振林樾</div>
    <img src="https://yujingbo1023.github.io/javablog/public/avatar.png" alt="">
</body>

</html>
```

上面通过媒体查询就适配了4块屏，如下：

![1714287863676](assets/1714287863676.png)

![1714287838837](assets/1714287838837.png)

![1714287880249](assets/1714287880249.png)

![1714287894552](assets/1714287894552.png)



缺点：

* 需要适配市面上很多的屏幕，非常麻烦
* 需要计算不同屏的html的font-size

上面的代码是以750屏为主，把750的屏的html的fontsize定了100px，现在把375的屏的fontsize定成100，如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        @media only screen and (device-width: 375px) {
            html {
                /* 1rem = 100px */
                font-size: 100px;
            }
        }

        @media only screen and (device-width: 320px) {
            html {
                font-size: 85.33px;
            }
        }

        div {
            /* 1个字是37.5px */
            font-size: 0.375rem;
        }

        img {
            /* img是375/2 = 187.5 */
            width: 1.875rem;
            border: 1px solid red;
        }

        img {}
    </style>
    <title>Document</title>
</head>

<body>
    <div>牧童骑黄牛歌声振林樾</div>
    <img src="https://yujingbo1023.github.io/javablog/public/avatar.png" alt="">
</body>

</html>
```

上面的代码适配了两个块屏，如下：

![1714287998663](assets/1714287998663.png)

![1714288017182](assets/1714288017182.png)



总结：给你一张750的设计图

1. 得到设计图 一般情况下，大部分的设计图，宽度是750px。
2. 通常我会把浏览器的模拟器，也调整成750px。
3. 严格按照设计图，去还原设计图，需要适配的盒子，都使用rem做单位。
4. 开始写样式，对于750模拟器，我通常会调整它的html标签的font-size是100px。叫基准值。如：一个盒子，宽度是30px，高度是55px。换成rem，w=0.3rem   h=0.55rem。
5. 说白了，最设计图，量出尺寸，需要适配的盒子，换成rem，就是px / 100 就是rem的数值。
6. 到此，你不要去管其它屏，你就老才实实地，在750的屏上，把设计图还原。
7. 等你页面写完后，开始适配，你需要把你写的750的页面，迁移到其它屏，这个过程，适配。
8. 说白了，就是设置其它屏的html的font-size大小。

开始适配：

- iPhone6 手机宽度： 375px html标签的font-size:50px; 1rem = 50px
- iPhone5 手机宽度： 320px html标签的font-size:42.66666px; 1rem = 42.6666px
- iPhone6P 手机宽度： 414px html标签的font-size:55.2px; 1rem = 55.2px
- 一个安卓手机，宽度520，那它的html标签的font-size  750/520 = 100/x  求x。

通过媒体查询实现：

- @media only screen and (device-width: 750px){ html{ font-size: 100px; } }
- @media only screen and (device-width: 375px){ html{ font-size: 50px; } }
- @media only screen and (device-width: 320px){ html{ font-size: 42.6666px; } }
- @media only screen and (device-width: 414px){ html{ font-size: 55.2px; } }



除了上面的算法之，还有一种算法，如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }

        @media only screen and (device-width: 750px) {
            html {
                font-size: 75px;
            }
        }

        @media only screen and (device-width: 375px) {
            html {
                font-size: 37.5px;
            }
        }

        @media only screen and (device-width: 320px) {
            html {
                font-size: 32px;
            }
        }

        @media only screen and (device-width: 414px) {
            html {
                font-size: 41.4px;
            }
        }

        div {
            font-size: 1rem;
        }

        img {
            width: 5rem;
            border: 1px solid red;
        }
    </style>
    <title>Document</title>
</head>

<body>
    <div>牧童骑黄牛歌声振林樾</div>
    <img src="https://yujingbo1023.github.io/javablog/public/avatar.png" alt="">
</body>

</html>
```

浏览器效果：

![1714287863676](assets/1714287863676.png)

![1714287838837](assets/1714287838837.png)

![1714287880249](assets/1714287880249.png)

![1714287894552](assets/1714287894552.png)





#### 3）rem + js做适配

再回顾一下上面的讲的两套算法：

![1714288161454](assets/1714288161454.png)

直接上代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./xx.js"></script>
    <style>
        * {
            margin: 0px;
            padding: 0px;
        }
        div {
           font-size: 1rem;
        }
        img{
            width: 5rem;
            border: 1px solid red;
        }
    </style>
    <title>Document</title>
</head>

<body>
    <div>牧童骑黄牛歌声振林樾</div>
    <img src="https://yujingbo1023.github.io/javablog/public/avatar.png" alt="">
</body>

</html>
```

```js
window.onload = function () {
    let htmlEle = document.documentElement;

    function setRem() {
        let htmlWidth = htmlEle.clientWidth;
        let htmlFs = htmlWidth / 10;
        htmlEle.style.fontSize = htmlFs + "px";
    }

    setRem();

    window.addEventListener("resize", setRem)
}
```



这样，所有屏都适配了，不截图，如果在750的设计图中量出一个盒子w:111px， h:123px，需要让你转成rem，如何呢？

答：w:111/75   h:123/75，代码如下：

```html

```



使用vscode做自动计算，如下：

![1714288468009](assets/1714288468009.png)

还需要设置，如下：

![1714288476584](assets/1714288476584.png)

![1714288485743](assets/1714288485743.png)

现在这个插件就可以自动计算了，如下：

![1714288498403](assets/1714288498403.png)

上面的JS是我们自己写的，淘宝开了一个适配的JS库，如下：

```js
(function flexible(window, document) {
    var docEl = document.documentElement
    var dpr = window.devicePixelRatio || 1

    // adjust body font size
    function setBodyFontSize() {
        if (document.body) {
            document.body.style.fontSize = (12 * dpr) + 'px'
        } else {
            document.addEventListener('DOMContentLoaded', setBodyFontSize)
        }
    }
    setBodyFontSize();

    // set 1rem = viewWidth / 10
    function setRemUnit() {
        var rem = docEl.clientWidth / 10
        docEl.style.fontSize = rem + 'px'
    }

    setRemUnit()

    // reset rem unit on page resize
    window.addEventListener('resize', setRemUnit)
    window.addEventListener('pageshow', function(e) {
        if (e.persisted) {
            setRemUnit()
        }
    })

    // detect 0.5px supports
    if (dpr >= 2) {
        var fakeBody = document.createElement('body')
        var testElement = document.createElement('div')
        testElement.style.border = '.5px solid transparent'
        fakeBody.appendChild(testElement)
        docEl.appendChild(fakeBody)
        if (testElement.offsetHeight === 1) {
            docEl.classList.add('hairlines')
        }
        docEl.removeChild(fakeBody)
    }
}(window, document))
```

使用上面的库，如下：

![1714288559689](assets/1714288559689.png)

浏览器测试之，OK。



#### 4）vw vh适配

**在flexible GitHub上已经有写过这样的一句话：**

![1714288570360](assets/1714288570360.png)

前面不管是我们自己编写的js，还是flexible的来适配，特点：

* 都是将1rem等同于屏的1/10     750屏 1rem = 75px   320屏 1rem = 32px

* 然后，再去计算你量出来的盒子的大小  w:111px  w:111/75   h:123px  h:123/75  这个计算是交给vscode的插件来做了。

* 总之：1rem等同于屏的1/10。正好有一个单位，叫vw，1vw正好是屏的1/100

* 不管在什么屏上，1vw始终是屏的1/100。

  


使用vw来适配，如下：

![1714288652414](assets/1714288652414.png)

  **vw相比于rem的优势：**

1. 优势一：不需要去计算html的font-size大小，也不需要给html设置这样一个font-size；
2. 优势二：不会因为设置html的font-size大小，而必须给body再设置一个font-size，防止继承；
3. 优势三：因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱；
4. 优势四：vw相比于rem更加语义化，1vw刚才是1/100的viewport的大小;
5. 优势五：可以具备rem之前所有的优点；

**vw我们只面临一个问题，将尺寸换算成vw的单位即可；** **所以，目前相比于rem，更加推荐大家使用vw（但是理解rem依然很重要）**

此时还有一个换算问题：

* 有一个盒子w:111px   h:123px; 设计图是375。    
* 100vw = 375px    111px = ???vw   111/3.75   29.6vw  
* h:123px   h:123/3.75  h:32.8vw

代码演示：

![1714288791932](assets/1714288791932.png)

浏览器效果：

![1714288715108](assets/1714288715108.png)

肯定也有一个插件，可以帮我们计算，如下：

![1714288807342](assets/1714288807342.png)



### 2，认识大屏



开发网页，常见适配的屏：

- PC端电脑：1920px * 1080px （当然也有少部分电脑是支持输出4k屏， 比如：小米笔记本等）
- 移动设备： 750px * auto       375 * auto        320 * auto



常见的大屏(1920*1080以上的屏)：

- 指挥大厅
- 展厅
- 展会中的大屏
- ....



大屏应用：

- 通常用在数据可视化，借助于图形化手段，清晰有效地传达与沟通信息



大屏硬件设备：

- 拼接屏
- LED屏
- 投影
- ...



拼接屏：

- 1920px * 1080px，即 1 * 1 个 显示屏（16 : 9）
- 3840 * 2160（4k 屏 ），即 2 * 2 个显示屏（16 : 9）
- 5760 * 3240，即 3 * 3 个显示屏（16 : 9）
- 7680 * 3240，即 4 * 3 个显示屏（64 : 27）
- 9600 * 3240，即 5 * 3 个显示屏（80 : 27）

![1714290294313](assets/1714290294313.png)

![1714290318038](assets/1714290318038.png)



LED屏：

- 由若干单体屏幕模块组成的，它的像素点计算及拼接方式与拼接屏有很大区别

![1714290456557](assets/1714290456557.png)





关于大屏，如何定设计稿：

- 假定一块屏的分辨率是 1920 *1080，比如6 * 3的拼接屏，横向分辨率为 6 * 1920=11520px。竖向分辨率为 

  3*1080=3240px。那么它的尺寸就是11520px * 3240px。

- 尺寸超过4K后，现有硬件会产生很多问题，例如：卡顿，GPU 压力过大，高负荷运行等等。最好是保持在 4K 内。最好最好的设计原则就是保持大屏的比例等比缩放即可。



如：

- 1920px * 1080px（1*1），设计搞尺寸 ：1920px * 1080px 。
- 3840 * 2160（2*2 4k 屏 ），设计搞尺寸 ： 3840 * 2160 。
- 5760 * 3240（3*3），设计搞尺寸 ： 5760 * 3240 。
- 7680 * 3240（4*3），设计搞尺寸 ： （ 3840 * 1620 需要出 1倍图 和 2倍图， 7680 * 3240 ）
- 9600 * 3240（5*3），设计搞尺寸 ： 比如：4800 * 1620，需要出 1倍图 和 2倍图
- ...







### 3，大屏适配



大屏适配核心：

- 设计尺寸建议按照输出分辨率设计。
- 拼接后像素在 4k 左右直接按照总和设计就行。
- 特殊尺寸不要考虑适配电脑屏幕又适配拼接屏，因为完全没有必要，也不可能一稿既适配电脑也适配各种尺寸大屏。
- 优先考虑目标屏幕的适配，要针对性设计，而在小屏根据等比例缩放显示



常见的大屏适配方案：

- 方案一：百分比设置
- 方案二：rem 单位 + 动态设置 html 的 font-size；
- 方案三：vw 单位；
- 方案四：flex 弹性布局；
- 方案五：scale 等比例缩放（推荐）



#### 1）大屏适配方案一：rem+js做适配

套路和移动端中的rem+js做适配是一样的。



没有适配的情况：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body, ul{
      margin: 0;
      padding: 0;
    }
    body{
      width: 1920px;
      height: 1080px;  
      box-sizing: border-box;
      border: 3px solid red;
    }

    ul{
      width: 100%;
      height: 100%;
      list-style: none;

      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
    }

    li{
      width: 33.333%;
      height: 50%;
      box-sizing: border-box;
      border: 2px solid green;
      font-size: 30px;
    }
  </style>
</head>
<body>

  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
  </ul>


</body>
</html>
```



rem+js适配：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body, ul{
      margin: 0;
      padding: 0;
    }
    body{
      width: 24rem;
      height: 13.5rem;
      box-sizing: border-box;
      border: 3px solid red;
    }

    ul{
      width: 100%;
      height: 100%;
      list-style: none;

      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
    }

    li{
      width: 33.333%;
      height: 50%;
      box-sizing: border-box;
      border: 2px solid green;
      font-size: .375rem;
    }
  </style>
</head>
<body>

  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
  </ul>

  <script src="./lib_flexible.js"></script>
</body>
</html>
```



lib_flexible.js

```js
(function flexible(window, document) {
  var docEl = document.documentElement;
  var dpr = window.devicePixelRatio || 1;

  // adjust body font size
  function setBodyFontSize() {
    if (document.body) {
      // body 字体大小默认为 16px
      document.body.style.fontSize = 16 * dpr + "px";
    } else {
      document.addEventListener("DOMContentLoaded", setBodyFontSize);
    }
  }
  setBodyFontSize();

  // 这里默认平均分成 10 等分(适用移动端)
  // set 1rem = viewWidth / 24 ；（使用pc端）
  function setRemUnit() {
    var rem = docEl.clientWidth / 24;  // 1920 / 24 = 80 
    docEl.style.fontSize = rem + "px"; // 设置 html字体的大小 80px
  }

  setRemUnit();

  // reset rem unit on page resize
  window.addEventListener("resize", setRemUnit);
  window.addEventListener("pageshow", function (e) {
    if (e.persisted) {
      setRemUnit();
    }
  });

  // detect 0.5px supports
  if (dpr >= 2) {
    var fakeBody = document.createElement("body");
    var testElement = document.createElement("div");
    testElement.style.border = ".5px solid transparent";
    fakeBody.appendChild(testElement);
    docEl.appendChild(fakeBody);
    if (testElement.offsetHeight === 1) {
      docEl.classList.add("hairlines");
    }
    docEl.removeChild(fakeBody);
  }
})(window, document);
```





#### 2）大屏适配方案二：vw适配 

屏幕的宽默认为 100vw，那么100vw = 1920px， 1vw = 19.2px 。



vw适配：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body, ul{
      margin: 0;
      padding: 0;
    }
    body{
      width: 100vw;
      height: 56.25vw;
      box-sizing: border-box;
      border: 3px solid red;
    }

    ul{
      width: 100%;
      height: 100%;
      list-style: none;

      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
    }

    li{
      width: 33.333%;
      height: 50%;
      box-sizing: border-box;
      border: 2px solid green;
      font-size: 1.5625vw;
    }
  </style>
</head>
<body>

  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
  </ul>
</body>
</html>
```





#### 3）大屏适配方案三（推荐）：scale

使用CSS3中的scale函数来缩放网页，这里我们将使用两种方案来实现：

- 方案一：直接根据宽度的比率进行缩放。（宽度比率=网页当前宽 / 设计稿宽）

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      body, ul{
        margin: 0;
        padding: 0;
      }
      body{
        width: 1920px;
        height: 1080px;
        box-sizing: border-box;
        border: 3px solid red;
  
        /* 指定缩放的原点在左上角 */
        transform-origin: left top;
      }
  
      ul{
        width: 100%;
        height: 100%;
        list-style: none;
  
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }
  
      li{
        width: 33.333%;
        height: 50%;
        box-sizing: border-box;
        border: 2px solid green;
        font-size: 30px;
      }
    </style>
  </head>
  <body>
  
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
      <li>4</li>
      <li>5</li>
      <li>6</li>
    </ul>
  
    <script>
  
      // 设计稿:  1920 * 1080
      // 目标适配:  1920 * 1080   3840 * 2160 ( 2 * 2 ) ;  7680 * 2160( 4 * 2)
  
      // 1.设计稿的尺寸
      let targetX = 1920
      // let targetY = 1080
      // let targetRatio = 16 / 9 // 宽高比率
  
      // 2.拿到当前设备(浏览器)的宽度
      let currentX = document.documentElement.clientWidth || document.body.clientWidth
      //  1920 * 1080  -> 3840 * 2160
  
      // 3.计算缩放比例
      let scaleRatio = currentX / targetX; // 参照宽度进行缩放
  
      // 4.开始缩放网页
      document.body.style = `transform: scale(${scaleRatio})`
  
  
        
    </script>
  </body>
  </html>
  ```

  

- 方案二：动态计算网页宽高比，决定是是否按照宽度的比率进行缩放。

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      body, ul{
        margin: 0;
        padding: 0;
      }
      body{
        position: relative;
        width: 1920px;
        height: 1080px;
        box-sizing: border-box;
        border: 3px solid red;
  
        /* 指定缩放的原点在左上角 */
        transform-origin: left top;
      }
  
      ul{
        width: 100%;
        height: 100%;
        list-style: none;
  
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }
  
      li{
        width: 33.333%;
        height: 50%;
        box-sizing: border-box;
        border: 2px solid green;
        font-size: 30px;
      }
    </style>
  </head>
  <body>
  
    <ul>
      <li>1</li>
      <li>2</li>
      <li>3</li>
      <li>4</li>
      <li>5</li>
      <li>6</li>
    </ul>
  
    <script>
  
      // 设计稿:  1920 * 1080
      // 目标适配:  1920 * 1080   3840 * 2160 ( 2 * 2 ) ;  7680 * 2160( 4 * 2)
  
      // 1.设计稿的尺寸
      let targetX = 1920
      let targetY = 1080
      let targetRatio = 16 / 9 // 宽高比率
  
      // 2.拿到当前设备(浏览器)的宽度
      let currentX = document.documentElement.clientWidth || document.body.clientWidth
      let currentY = document.documentElement.clientHeight || document.body.clientHeight
      //  1920 * 1080  -> 3840 * 2160
  
      // 3.计算缩放比例
      let scaleRatio = currentX / targetX; // 参照宽度进行缩放 ( 默认情况 )
      let currentRatio = currentX / currentY // 宽高比率
  
      // 超宽屏
      if(currentRatio > targetRatio) {
        scaleRatio = currentY / targetY // 参照高度进行缩放
        document.body.style = `width:${targetX}px; height:${targetY}px;transform: scale(${scaleRatio}) translateX(-50%); left: 50%`
      } else {
        // 4.开始缩放网页
        document.body.style = `width:${targetX}px; height:${targetY}px; transform: scale(${scaleRatio})`
      }
        
    </script>
  </body>
  </html>
  ```

  

vw相比于rem的优势：

- 不需要去计算html的font-size大小，不需要给html设置font-size，也不需要设置body的font-size，防止继承；
- 因为不依赖font-size的尺寸，所以不用担心某些原因html的font-size尺寸被篡改，页面尺寸混乱；
- vw相比于rem更加语义化，1vw是1/100的viewport大小（即将屏幕分成100份）; 并且具备 rem 之前所有的优点；



vw和rem存在的问题：

- 如果使用rem或vw单位时，在JS中添加样式时，单位需要手动设置rem或vw。
- 第三方库的字体等默认的都是px单位，比如：element、echarts，因此通常需要层叠第三方库的样式。
- 当大屏比例更大时，有些字体还需要相应的调整字号。



scale相比vw和rem的优势

- 相比于vw 和 rem，使用起来更加简单，不需要对单位进行转换。
- 因为不需要对单位进行转换，在使用第三方库时，不需要考虑单位转换问题。
- 由于浏览器的字体默认最小是不能小于12px，导致rem或vw无法设置小于12px的字体，缩放没有这个问题。



## 四，Vue权限管理上



## 五，Vue权限管理中



## 六，Vue权限管理下



## 七，Vue的.sync的使用



## 八，Grid网络布局



## 九，粘性定位



## 十一，滑动门



## 十二，瀑布流



## 十三，放大镜



## 十四，防抖和节流



## 十五，工厂模式



## 十六，单例模式



## 十七，原型模式



## 十八，适配器模式



## 十九，代理模式



## 二十，策略模式



## 二十一，迭代器模式



## 二十二，观察者模式



## 二十三，命令模式



## 二十四，状态模式



## 二十五，Fetch发请求[讲师：码路于老师/LY]



## URL和URI的区别



### 1，什么是URL

Uniform Resource Locator或者简称URL，是对于某种Web资源的引用(标识)，并且使用它可以定位互联网上某个资源（包含了如何获取该资源的方式）。

- https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png

  ![1714822464483](assets/1714822464483.png)

- https://img.alicdn.com/imgextra/i4/O1CN01c7XPbb1HcN5p9c5Dk_!!6000000000778-1-tps-480-144.gif

  ![1714822482175](assets/1714822482175.png)

- ....



参数：

- 协议：通常是https或http
- 主机名：可以是一个已经在DNS服务器注册过的域名，也可以是一个IP地址，域名就表示背后的IP地址
- 资源路径：用于表示资源在主机上的文件系统路径



### 2，什么是URI

与URL相似的部分是，Uniform Resource Identifier同样定义了资源的标识，但不同点在于URI通常不会包含获取资源的方式。如图书的ISBN。

![1714816902193](assets/1714816902193.png)



区别：

![1714816957455](assets/1714816957455.png)



## 关于TCP的粘包问题

- **面试官：**如果想实现即时通信功能，应该采取哪些方案？

- **我：**既然要实现即时通信，肯定需要使用TCP协议来支持

- **面试官：**为什么不能使用UDP？

- **我：**既然是即时通信，消息一定是需要可靠性及连续性，这是UDP所不具有的。

- **面试官：**那么TCP有什么样的缺点?

- **我：**相对于UDP来说TCP传输速度略慢，同时还要考虑网络粘包问题。

- **面试官：**详细说说什么是网络粘包

- **我：**一般来说，粘包问题和半包问题是一起讨论的，先说粘包，粘包问题是指数据在传输时，在一条消息中读取到了另一条消息的部分数据，这种现象就叫做粘包。比如发送了两条消息，分别为“ABC”和“DEF”，那么正常情况下接收端也应该收到两条消息“ABC”和“DEF”，但接收端却收到的是“ABCD”，像这种情况就叫做粘包。

  ![1714817374496](assets/1714817374496.png)

  半包问题是指接收端只收到了部分数据，而非完整的数据的情况就叫做半包。比如发送了一条消息是“ABC”，而接收端却收到的是“AB”和“C”两条信息，这种情况就叫做半包。

  ![1714817450189](assets/1714817450189.png)

  大部分情况下都把粘包问题和半包问题看成同一个问题

  

- **面试官：**为什么会产生粘包现象?

- **我：**首先，粘包现象仅仅存在于TCP之中，UDP是没有的，而TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。其中跟粘包关系最大的就是基于字节流这个特点。字节流可以理解为一个双向的通道里流淌的数据这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01串。这些01串之间没有任何边界。

  ![1714817639451](assets/1714817639451.png)

  应用层传到 TCP 协议的数据，是以字节流的方式发送到下游，这些数据可能被切割和组装成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。

- **面试官：**那么，为什么不直接按照消息条数去发，而是要重新组装呢?

- **我：**最终目的是提高效率，因为如果一条消息仅仅几个字节的话，单独发送会极度浪费网络IO资源，一般来说，TCP为了避免发送小包消息，都会重新组装，来提高I0利用率。

- **面试官：**那么，如果遇到TCP粘包问题的时候，又该怎么解决呢?

- **我：**由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，常见的解决方案有三种

  - 消息定长
  - 以指定字符为包的结束标志
  - 包头和包体



**消息定长**

顾名思义，即每个协议包的长度都是固定的。举个例子，例如我们可以规定每个协议包的大小是 64 个字节，每次收满 64 个字节，就取出来解析。这种通信协议的格式简单但灵活性差。如果包内容不足指定的字节数，剩余的空间需要填充特殊的信息，如空格

![1714820619269](assets/1714820619269.png)

**以指定字符为包的结束标志**
这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP 协议，一个命令或者一段数据后面加上"\r\n"表示一个包的结束。对端收到后，每遇到一个“\r\n“就把之前的数据当做一个数据包。这种协议一般用于一些包含各种命令控制的应用中，其不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。

![1714820790927](assets/1714820790927.png)



**包头和包体**

这种格式的消息一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大，同时，最好还有个标识符，用于检测是否为包头。

![1714821505296](assets/1714821505296.png)



整体解析流程：

![1714822035705](assets/1714822035705.png)







## JS框架语特性对比




































