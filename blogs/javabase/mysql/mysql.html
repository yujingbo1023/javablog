<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>mysql(新版)</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 0px 2px; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }





 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h3><a name='header-n3' class='md-header-anchor '></a>1，数据库基本概念</h3><ol start='' ><li><p><strong>数据</strong></p><p>数据（Data）是指对客观事物进行描述并可以鉴别的符号，这些符号是可识别的、抽象的。它不仅指狭义上的数字，而是有多种表现形式：字母、文字、文本、图形、音频、视频等。</p></li><li><p><strong>数据库</strong></p><p>数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。</p></li><li><p><strong>数据库管理系统</strong></p><p>数据库管理系统（Database Management System，DBMS）是用来定义和管理数据的软件。电脑上安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的MySQL数据库其实是MySQL数据库管理系统。</p></li><li><p><strong>数据库管理员</strong></p><p>数据库管理员（Database Administrator，DBA）是指对数据库管理系统进行操作的人员，其主要负责数据库的运营和维护。</p><p>&nbsp;</p></li></ol><p>常见的数据库管理系统：</p><p><img src='./assets/1718058438327.png' alt='1718058438327' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>数据库分类：</strong></p><ul><li>关系型数据库</li><li>非关系型数据库</li></ul><p><img src='./assets/1718058747335.png' alt='1718058747335' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>关系型数据库：</strong>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组 织。可以采用结构化查询语言（SQL）对数据库进行操作。</p><ul><li><p>优点：</p><ul><li>易于维护：都是使用表结构，格式一致；</li><li>使用方便：SQL语言通用，可用于复杂查询；</li><li>复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</li></ul></li><li><p>缺点：</p><ul><li>读写性能比较差，尤其是海量数据的高效率读写；</li><li>固定的表结构，灵活度稍欠；</li><li>高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</li></ul></li></ul><p>&nbsp;</p><p><strong>非关系型数据库：</strong>非关系型数据库也称之为NoSQL数据库，是一种数据结构化存储方法的集合，可以是文档或者键值对等。</p><ul><li><p>优点：</p><ul><li>格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li><li>速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；</li><li>高扩展性；</li><li>成本低：nosql数据库部署简单，基本都是开源软件。</li></ul></li><li><p>缺点：</p><ul><li>不提供sql支持，学习和使用成本较高；</li><li>无事务处理；</li><li>数据结构相对复杂，复杂查询方面稍欠。</li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n74' class='md-header-anchor '></a>2，MySQL介绍与安装</h3><p>MySQL 是一个关系型数据库管理系统， 由瑞典 MySQL AB 公司开发， 目前属于 Oracle 公司。MySQL 是一种关系型数据库管理系统，关系型数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><p>&nbsp;</p><p><strong>关系型数据库：</strong></p><ul><li>关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库</li><li>关系型数据库都可以通过SQL进行操作，所以使用方便。</li><li>数据存储在磁盘中，安全。</li></ul><p>&nbsp;</p><p><code>订单信息表</code> 和 <code>客户信息表</code> 都是有行有列二维表我们将这样的称为关系型数据库。如下：</p><p><img src='./assets/1718058918398.png' alt='1718058918398' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>数据模型：</strong></p><p><img src='./assets/1718059255297.png' alt='1718059255297' referrerPolicy='no-referrer' /></p><p>通过客户端可以通过数据库管理系统创建数据库，在数据库中创建表，在表中添加数据。创建的每一个数据库对应到磁盘上都是一个文件夹。一个数据库下可以创建多张表，我们到MySQL中自带的mysql数据库的文件夹目录下：<code>db.frm</code> 是表文件， <code>db.MYD</code> 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。</p><p>&nbsp;</p><p><strong>MySQL特点：</strong></p><ul><li>MySQL 是开源的。</li><li>MySQL 支持大型系统的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。</li><li>MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C 、C++、 Python 、Java 、Perl 、PHP 等。</li><li>MySQL 存储数据量较大，32 位系统表文件最大可支持 4GB ，64 位系统支持最大的 表文件为 8TB。</li><li>MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系 统。</li></ul><p>&nbsp;</p><p><strong>MySQL分类：</strong></p><ul><li>MySQL分为社区版，社区版是完全开源免费的，社区版也支持多种数据类型和标准的SQL查询语言，能够对数据进行各种查询、增加、删除、修改等操作，所以一般情况下社区版就可以满足开发需求了。</li><li>企业版，企业版是收费的。即使在开发中需要用到一些付费的附加功能，价格相对于昂贵的 Oracle、DB2等也是有很大优势的。对数据库可靠性要求比较高的企业可以选择企业版。</li></ul><p>&nbsp;</p><p><strong>MySQL的安装：</strong>大家直接安装小皮就行，简单粗暴，这个小皮软件中，内置了很多的软件，其中就包含mysql。如果我们直接下载mysql安装的话，过程比较烦索。如下：</p><p><img src='./assets/1718059108160.png' alt='1718059108160' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>Navicat for MySQL安装：</strong>安装了mysql，我后我们可以安装Navicat for MySQL软件，这个软件是用来连接mysql管理系统的。连接上后，可以通过可视化操作mysql。</p><p><img src='./assets/1718059392985.png' alt='1718059392985' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n120' class='md-header-anchor '></a>3，SQL语言介绍</h3><p>结构化查询语言(Structured Query Language)简称 SQL(发音：sequal[&#39;si:kwəl])，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><p><img src='./assets/1718059491071.png' alt='1718059491071' referrerPolicy='no-referrer' /></p><p>SQL能做什么：</p><ul><li>SQL 面向数据库执行查询</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可从数据库删除记录</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可以设置表、存储过程和视图的权限</li></ul><p>&nbsp;</p><p>&nbsp;</p><p><strong>SQL语言分类：</strong></p><ol start='' ><li><p>数据查询语言（DQL：Data Query Language）其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。关键字 SELECT 是 DQL（也是所有 SQL）用得最多的动词。（对数据进行查询操作，从数据库表中查询到我们想要的数据）</p><ul><li>SELECT</li><li>FROM</li><li>WHERE</li><li>ORDER BY</li><li>HAVING</li></ul></li><li><p>数据操作语言（DML：Data Manipulation Language）其语句包括动词 INSERT，UPDATE 和 DELETE。它们分别用于添加，修改和删除表中的行（对表中数据进行增删改的）。</p><ul><li>INSERT：添加数据</li><li>UPDATE：更新数据</li><li>DELETE：删除数据</li></ul><p><img src='./assets/1718059634139.png' alt='1718059634139' referrerPolicy='no-referrer' /></p></li><li><p>数据定义语言（DDL：Data Definition Language）定义数据库对象语言，其语句包括动词 CREATE 和 DROP 等。（就是用来操作数据库，表等）</p><ul><li><p>CREATE：创建数据库对象</p></li><li><p>ALTER：修改数据库对象</p></li><li><p>DROP：删除数据库对象</p><p><img src='./assets/1718059694547.png' alt='1718059694547' referrerPolicy='no-referrer' /></p></li></ul></li><li><p>数据控制语言（DCL：Data Control Language）它的语句通过 GRANT 或 REVOKE 获得许可，确定用户对数据库对象的访问。</p><ul><li>GRANT：授予用户某种权限</li><li>REVOKE：回收授予的某种权限</li></ul></li><li><p>事务控制语言（TCL ：Transaction Control Language）它的语句能确保被 DML 语句影响的表的所有行及时得以更新。</p><ul><li>COMMIT：提交事务</li><li>ROLLBACK：回滚事务</li><li>SAVEPOINT：设置回滚点</li></ul></li></ol><p>&nbsp;</p><p>&nbsp;</p><p><strong>SQL语言的语法：</strong></p><ul><li>SQL语句不区分大小写，关键字建议大写。</li><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>单行注释: -- 注释内容 或 #注释内容(MySQL 特有)。使用-- 添加单行注释时，--后面一定要加空格，而#没有要求。</li><li>多行注释: /* 注释 */</li></ul><p>&nbsp;</p><h3><a name='header-n209' class='md-header-anchor '></a>4，DDL操作数据库</h3><p>使用DDL语句创建数据库：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">CREATE</span> DATABASE  数据库名 DEFAULT CHARACTER <span class="cm-keyword">SET</span>  字符编码;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>&nbsp;</p><p>创建一个test 的数据库，并查看该数据库，以及该数据库的编码。创建数据库：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">create</span> database test default character <span class="cm-keyword">set</span> utf8;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p><img src='./assets/1718071539779.png' alt='1718071539779' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查看数据库：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">show databases;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p><img src='./assets/1718071603745.png' alt='1718071603745' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查看数据库编码：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">select</span> schema_name,default_character_set_name <span class="cm-keyword">from</span> information_schema<span class="cm-variable-2">.schemata</span> </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">where</span> schema_name = <span class="cm-string">'test'</span>;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;"></div><div class="CodeMirror-gutters" style="display: none; height: 46px;"></div></div></div></pre><p><img src='./assets/1718072443525.png' alt='1718072443525' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>使用DDL语言删除数据库:</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">DROP</span> DATABASE  数据库名称;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>&nbsp;</p><p>删除 test 数据库，删除完后需要刷新一下:</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">drop</span> database test;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>&nbsp;</p><p>在创建表时，需要先选择数据库:</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">USE 数据库名;</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p>&nbsp;</p><p>创建一个名称为 malu 的数据库，编码为 utf8。并选择该数据库：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sql"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sql"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 7.88193px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">create</span> database malu default character <span class="cm-keyword">set</span> utf8;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">use malu;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;"></div><div class="CodeMirror-gutters" style="display: none; height: 46px;"></div></div></div></pre><p>&nbsp;</p><p>已经有了malu数据库，再去创建时，就会报错，如下：</p><p><img src='./assets/1718072709733.png' alt='1718072709733' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n241" mdtype="fences">CREATE DATABASE IF NOT EXISTS malu DEFAULT CHARACTER SET utf8;
</pre><p><img src='./assets/1718072758617.png' alt='1718072758617' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>同理，在删除数据库时，也可以做一个判断：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n245" mdtype="fences">DROP DATABASE IF EXISTS malu;
</pre><p>&nbsp;</p><p><img src='./assets/1718072849548.png' alt='1718072849548' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n250" mdtype="fences">create database malu default character set utf8;
use malu;
</pre><p>&nbsp;</p><p>查看当前使用的数据库：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n253" mdtype="fences">SELECT DATABASE();
</pre><p><img src='./assets/1718072948173.png' alt='1718072948173' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n258' class='md-header-anchor '></a>5，MYSQL中的数据类型</h3><p>&nbsp;</p><p>不同的数据，要开辟不同的存储空间，目的就是为了更加合理地使用存储空间。</p><p>&nbsp;</p><p><strong>整数类型：</strong></p><figure><table><thead><tr><th><strong>MySQL数据类型</strong></th><th><strong>含义（有符号）</strong></th></tr></thead><tbody><tr><td>tinyint(m)</td><td>1个字节 范围(-128~127)</td></tr><tr><td>smallint(m)</td><td>2个字节 范围(-32768~32767)</td></tr><tr><td>mediumint(m)</td><td>3个字节 范围(-8388608~8388607)</td></tr><tr><td>int(m)</td><td>4个字节 范围(-2147483648~2147483647)</td></tr><tr><td>bigint(m)</td><td>8个字节 范围(+-9.22*10的18次方)</td></tr></tbody></table></figure><p>数值类型中的长度 m 是指显示长度，并不表示存储长度，只有字段指定 zerofill 时有用。例如： int(3) ，如果实际值是 2 ，如果列指定了 zerofill ，查询结果就是 002 ，左边用 0 来 填充</p><p>&nbsp;</p><p>使用最多的：tinyint和int</p><ul><li>tinyint : 小整数型，占一个字节</li><li>int： 大整数类型，占四个字节。eg： age int</li></ul><p>&nbsp;</p><p>&nbsp;</p><p><strong>浮点类型：</strong></p><figure><table><thead><tr><th><strong>MySQL数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>float(m,d)</td><td>单精度浮点型 8位精度(4字节) m总个数，d小数位</td></tr><tr><td>double(m,d)</td><td>双精度浮点型 16位精度(8字节) m总个数，d小数位</td></tr></tbody></table></figure><p>double ： 浮点类型，使用格式： 字段名 double(总长度, 小数点后保留的位数)。eg： score double(5, 2)</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>字符类型：</strong></p><figure><table><thead><tr><th><strong>MySQL数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度，最多255个字符</td></tr><tr><td>tinytext</td><td>可变长度，最多255个字符</td></tr><tr><td>varchar(n)</td><td>可变长度，最多65535个字符</td></tr><tr><td>text</td><td>可变长度，最多65535个字符</td></tr><tr><td>mediumtext</td><td>可变长度，最多2的24次方-1个字符</td></tr><tr><td>longtext</td><td>可变长度，最多2的32次方-1个字符</td></tr></tbody></table></figure><p>char和varchar：</p><ol start='' ><li>char长度固定， 即每条数据占用等长字节空间；适合用在身份证号码、手机号码等定长。</li><li>varchar可变长度，可以设置最大长度；适合用在长度可变的属性。</li><li>text不设置长度， 当不知道属性的最大长度时，适合用text。</li><li>按照查询速度： char最快， varchar次之，text最慢。</li></ol><p>&nbsp;</p><p>总结 char和varchar：</p><ul><li>char： 定长字符串。优点：存储性能高。缺点：浪费空间。eg： name char(10) 如果存储的数据字符个数不足10个，也会占10个的空间</li><li>varchar： 变长字符串。优点：节约空间。缺点：存储性能底。eg： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间</li></ul><p>&nbsp;</p><p>字符串型使用建议：</p><ol start='' ><li>经常变化的字段用varchar</li><li>知道固定长度的用char</li><li>尽量用varchar</li><li>超过255字符的只能用varchar或者text</li><li>能用varchar的地方不用text</li></ol><p>&nbsp;</p><p><strong>日期类型：</strong></p><figure><table><thead><tr><th><strong>MySQL数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>date</td><td>日期 YYYY-MM-DD</td></tr><tr><td>time</td><td>时间 HH:MM:SS</td></tr><tr><td>datetime</td><td>日期时间 YYYY-MM-DD HH:MM:SS</td></tr><tr><td>timestamp</td><td>时间戳YYYYMMDD HHMMSS</td></tr></tbody></table></figure><ul><li>date：日期值。只包含年月日。eg：birthday date ：</li><li>datetime ： 混合日期和时间值。包含年月日时分秒</li></ul><p>&nbsp;</p><p><strong>二进制数据(BLOB)：</strong></p><ol start='' ><li>BLOB和TEXT存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。</li><li>BLOB存储的数据只能整体读出。</li><li>TEXT可以指定字符集，BLOB不用指定字符集。</li></ol><p>&nbsp;</p><p>总结：</p><p><img src='./assets/1718060762837.png' alt='1718060762837' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h3><a name='header-n395' class='md-header-anchor '></a>5，DDL操作表</h3><p>&nbsp;</p><p>使用DDL语句创建表：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n398" mdtype="fences">CREATE TABLE 表名(列名 类型,列名 类型......);
</pre><p>&nbsp;</p><p>创建一个 employees 表包含雇员 ID ，雇员名字，雇员薪水:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n401" mdtype="fences">create table employees(employee_id int,employee_name varchar(10),salary float(8,2));
</pre><p><img src='./assets/1718074022419.png' alt='1718074022419' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查看已创建的表:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n405" mdtype="fences">show tables;
</pre><p><img src='./assets/1718074050707.png' alt='1718074050707' referrerPolicy='no-referrer' /></p><p>使用DDL语句删除表：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n408" mdtype="fences">DROP TABLE 表名;
</pre><p>&nbsp;</p><p>删除 employees 表:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n411" mdtype="fences">drop table employees;
</pre><p>&nbsp;</p><p>使用DDL语句修改表:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n414" mdtype="fences">ALTER TABLE  旧表名 RENAME  新表名;
</pre><p>&nbsp;</p><p>创建一个 employees 表包含雇员 ID ，雇员名字，雇员薪水:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n417" mdtype="fences">create table employees(employee_id int,employee_name varchar(10),salary float(8,2));
</pre><p>&nbsp;</p><p>将 employees 表名修改为 emp:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n420" mdtype="fences">alter table employees rename emp;
</pre><p>&nbsp;</p><p>使用DDL语句修改列名:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n423" mdtype="fences">ALTER TABLE  表名 CHANGE COLUMN  旧列名 新列名 类型;
</pre><p>&nbsp;</p><p>将 emp 表中的 employee_name 修改为 name:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n426" mdtype="fences">alter table emp change column employee_name name varchar(20);
</pre><p>&nbsp;</p><p>使用DDL语句修改列类型:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n429" mdtype="fences">ALTER TABLE  表名 MODIFY  列名 新类型;
</pre><p>&nbsp;</p><p>将 emp 表中的 name 的长度指定为 40:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n432" mdtype="fences">alter table emp modify name varchar(40);
</pre><p>&nbsp;</p><p>使用DDL语句添加新列:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n435" mdtype="fences">ALTER TABLE  表名 ADD COLUMN  新列名 类型;
</pre><p>&nbsp;</p><p>在 emp 表中添加佣金列，列名为 commission_pct:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n438" mdtype="fences">alter table emp add column commission_pct float(4,2);
</pre><p>&nbsp;</p><p>使用DDL语句删除指定的列:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n441" mdtype="fences">ALTER TABLE  表名 DROP COLUMN  列名;
</pre><p>&nbsp;</p><p>删除 emp 表中的 commission_pct:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n444" mdtype="fences">alter table emp drop column commission_pct;
</pre><p>&nbsp;</p><h3><a name='header-n446' class='md-header-anchor '></a>6，MySQL中的约束</h3><p>&nbsp;</p><p>看如下表：</p><p><img src='./assets/1718061428571.png' alt='1718061428571' referrerPolicy='no-referrer' /></p><p>上面表存在的一些问题：</p><ul><li><p>id 列一般是用标示数据的唯一性的，而上述表中的id为1的有三条数据，并且 <code>马花疼</code> 没有id进行标示</p></li><li><p><code>柳白</code> 这条数据的age列的数据是3000，而人也不可能活到3000岁</p></li><li><p><code>马运</code> 这条数据的math数学成绩是-5，而数学学得再不好也不可能出现负分</p></li><li><p><code>柳青</code> 这条数据的english列（英文成绩）值为null，而成绩即使没考也得是0分</p><p>&nbsp;</p></li></ul><p>针对上面的遇到的问题，从数据库层面在添加数据的时候进行限制，这个就是约束。约束是作用于表中列上的规则，用于限制加入表的数据。例如：我们可以给id列加约束，让其值不能重复，不能为null值。</p><p>&nbsp;</p><p>约束的存在保证了数据库中数据的正确性、有效性和完整性。添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。</p><p>&nbsp;</p><p>数据库约束是对表中的数据进行进一步的限制，保证数据的正确性、有效性和完整性。</p><ul><li><p>主键约束(Primary Key) PK</p><blockquote><p>主键约束是使用最频繁的约束。在设计数据表时，一般情况下，都会要求表中设置一个主键。 主键是表的一个特殊字段，该字段能唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。</p><p>主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。</p><p>例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。</p></blockquote></li><li><p>外键约束(Foreign Key) FK</p><blockquote><p>外键约束经常和主键约束一起使用，用来确保数据的一致性。</p><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>外键约束现在可能还不太好理解，后面我们会重点进行讲解。</p></blockquote></li><li><p>唯一性约束(Unique)</p><blockquote><p>唯一约束与主键约束有一个相似的地方，就是它们都能够确保列的唯一性。与主键约束不同的是，唯一约束在一个表中可以有多个，并且设置唯一约束的列是允许有空值的。</p><p>保证列中所有数据各不相同。</p><p>例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。</p></blockquote></li><li><p>非空约束(Not Null)</p><blockquote><p>非空约束用来约束表中的字段不能为空。</p><p>保证列中所有的数据不能有null值。</p><p>例如：id列在添加 <code>马花疼</code> 这条数据时就不能添加成功。</p></blockquote></li><li><p>检查约束(Check)</p><blockquote><p>检查约束也叫用户自定义约束，是用来检查数据表中，字段值是否有效的一个手段，但目前 MySQL 数据库不支持检查约束。</p><p>保证列中的值满足某一条件。</p><p>例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。</p><p>MySQL不支持检查约束。从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。</p></blockquote></li><li><p>默认约束： 关键字是 DEFAULT</p><blockquote><p>保存数据时，未指定值则采用默认值。</p><p>例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。</p></blockquote></li></ul><p>&nbsp;</p><h4><a name='header-n504' class='md-header-anchor '></a>a）非空约束</h4><p>非空约束用于保证列中所有数据不能有NULL值。添加约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n506" mdtype="fences">-- 创建表时添加非空约束
CREATE TABLE 表名(
   列名 数据类型 NOT NULL,
   …
); 

-- 建完表后添加非空约束
ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;
</pre><p>&nbsp;</p><p>操作一下：</p><p><img src='./assets/1718088543226.png' alt='1718088543226' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>删除约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n512" mdtype="fences">ALTER TABLE 表名 MODIFY 字段名 数据类型;
</pre><p>&nbsp;</p><h4><a name='header-n514' class='md-header-anchor '></a>b）唯一约束</h4><p>唯一约束用于保证列中所有数据各不相同。添加约束语法：  id:1   id:2   id:3 </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n516" mdtype="fences" style="break-inside: unset;">-- 创建表时添加唯一约束
CREATE TABLE 表名(
   列名 数据类型 UNIQUE [AUTO_INCREMENT],
   -- AUTO_INCREMENT: 当不指定值时自动增长
   …
); 
CREATE TABLE 表名(
   列名 数据类型,
   …
   [CONSTRAINT] [约束名称] UNIQUE(列名)
); 

-- 建完表后添加唯一约束
ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;
</pre><p><img src='./assets/1718088812791.png' alt='1718088812791' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>删除约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n520" mdtype="fences">ALTER TABLE 表名 DROP INDEX 字段名;
</pre><p>&nbsp;</p><h4><a name='header-n522' class='md-header-anchor '></a>c）主键约束</h4><p>键是一行数据的唯一标识，要求非空且唯一。一张表只能有一个主键。添加约束语法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n524" mdtype="fences">-- 创建表时添加主键约束
CREATE TABLE 表名(
   列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],
   …
); 
CREATE TABLE 表名(
   列名 数据类型,
   [CONSTRAINT] [约束名称] PRIMARY KEY(列名)
); 

-- 建完表后添加主键约束
ALTER TABLE 表名 ADD PRIMARY KEY(字段名);
</pre><p><img src='./assets/1718088993473.png' alt='1718088993473' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>删除约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n528" mdtype="fences">ALTER TABLE 表名 DROP PRIMARY KEY;
</pre><p>&nbsp;</p><h4><a name='header-n530' class='md-header-anchor '></a>d）默认约束</h4><p>保存数据时，未指定值则采用默认值，添加约束语法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n532" mdtype="fences">-- 创建表时添加默认约束
CREATE TABLE 表名(
   列名 数据类型 DEFAULT 默认值,
   …
); 

-- 建完表后添加默认约束
ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;
</pre><p><img src='./assets/1718089084434.png' alt='1718089084434' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>删除约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n536" mdtype="fences">ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;
</pre><p>&nbsp;</p><h4><a name='header-n538' class='md-header-anchor '></a>e）约束练习</h4><p>需求：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n540" mdtype="fences">-- 员工表
CREATE TABLE emp (
	id INT,  -- 员工id，主键且自增长
    ename VARCHAR(50), -- 员工姓名，非空且唯一
    joindate DATE,  -- 入职日期，非空
    salary DOUBLE(7,2),  -- 工资，非空
    bonus DOUBLE(7,2)  -- 奖金，如果没有将近默认为0
);
</pre><p>&nbsp;</p><p>上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n543" mdtype="fences">-- 员工表
CREATE TABLE emp (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 员工id，主键且自增长
    ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空且唯一
    joindate DATE NOT NULL,  -- 入职日期，非空
    salary DOUBLE(7,2) NOT NULL,  -- 工资，非空
    bonus DOUBLE(7,2) DEFAULT 0  -- 奖金，如果没有将近默认为0
);
</pre><p>&nbsp;</p><p>通过上面语句可以创建带有约束的 <code>emp</code> 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n546" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) values(1,'张三','1999-11-11',8800,5000);
</pre><p><img src='./assets/1718089329274.png' alt='1718089329274' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>验证主键约束，非空且唯一：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n550" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'malu','1999-11-11',8800,5000);
</pre><p><img src='./assets/1718089427545.png' alt='1718089427545' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>从上面的结果可以看到，字段 <code>id</code> 不能为null。那我们重新添加一条数据，如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n555" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) values(1,'wc','1999-11-11',8800,5000);
</pre><p><img src='./assets/1718089482830.png' alt='1718089482830' referrerPolicy='no-referrer' /></p><p>从上面结果可以看到，1这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n558" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) values(3,'李四','1999-11-11',8800,5000);
</pre><p><img src='./assets/1718089544321.png' alt='1718089544321' referrerPolicy='no-referrer' /></p><p>验证非空约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n561" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) values(null,null,'1999-11-11',8800,5000);
</pre><p><img src='./assets/1718089599086.png' alt='1718089599086' referrerPolicy='no-referrer' /></p><p>从上面结果可以看到， <code>ename</code> 字段的非空约束生效了。</p><p>&nbsp;</p><p>&nbsp;</p><p>验证唯一约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n567" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) VALUES(NULL,'李四','1999-11-11',8800,5000);
</pre><p><img src='./assets/1718089661552.png' alt='1718089661552' referrerPolicy='no-referrer' /></p><p>从上面结果可以看到， <code>ename</code> 字段的唯一约束生效了。</p><p>&nbsp;</p><p>验证默认约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n572" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary) values(null,'王五','1999-11-11',8800);
</pre><p><img src='./assets/1718089767190.png' alt='1718089767190' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n576" mdtype="fences">INSERT INTO emp(id,ename,joindate,salary,bonus) values(null,'赵六','1999-11-11',8800,null);
</pre><p><img src='./assets/1718089817868.png' alt='1718089817868' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h3><a name='header-n579' class='md-header-anchor '></a>7，DQL(非常重要)</h3><p>准备数据：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n581" mdtype="fences" style="break-inside: unset;">/*
 Navicat Premium Data Transfer

 Source Server         : mysql
 Source Server Type    : MySQL
 Source Server Version : 50712
 Source Host           : localhost:3306
 Source Schema         : test

 Target Server Type    : MySQL
 Target Server Version : 50712
 File Encoding         : 65001

 Date: 08/11/2021 15:11:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for countries
-- ----------------------------
DROP TABLE IF EXISTS `countries`;
CREATE TABLE `countries`  (
  `COUNTRY_ID` char(2) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Primary key of countries table.',
  `COUNTRY_NAME` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'Country name',
  `REGION_ID` int NULL DEFAULT NULL COMMENT 'Region ID for the country. Foreign key to region_id column in the departments table.',
  PRIMARY KEY (`COUNTRY_ID`) USING BTREE,
  INDEX `COUNTR_REG_FK`(`REGION_ID`) USING BTREE,
  CONSTRAINT `COUNTR_REG_FK` FOREIGN KEY (`REGION_ID`) REFERENCES `regions` (`REGION_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'country table. Contains 25 rows. References with locations table.' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of countries
-- ----------------------------
INSERT INTO `countries` VALUES ('AR', 'Argentina', 2.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('AU', 'Australia', 3.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('BE', 'Belgium', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('BR', 'Brazil', 2.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('CA', 'Canada', 2.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('CH', 'Switzerland', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('CN', 'China', 3.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('DE', 'Germany', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('DK', 'Denmark', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('EG', 'Egypt', 4.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('FR', 'France', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('IL', 'Israel', 4.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('IN', 'India', 3.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('IT', 'Italy', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('JP', 'Japan', 3.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('KW', 'Kuwait', 4.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('ML', 'Malaysia', 3.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('MX', 'Mexico', 2.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('NG', 'Nigeria', 4.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('NL', 'Netherlands', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('SG', 'Singapore', 3.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('UK', 'United Kingdom', 1.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('US', 'United States of America', 2.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('ZM', 'Zambia', 4.000000000000000000000000000000);
INSERT INTO `countries` VALUES ('ZW', 'Zimbabwe', 4.000000000000000000000000000000);

-- ----------------------------
-- Table structure for departments
-- ----------------------------
DROP TABLE IF EXISTS `departments`;
CREATE TABLE `departments`  (
  `DEPARTMENT_ID` int NOT NULL COMMENT 'Primary key column of departments table.',
  `DEPARTMENT_NAME` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'A not null column that shows name of a department. Administration,\nMarketing, Purchasing, Human Resources, Shipping, IT, Executive, Public\nRelations, Sales, Finance, and Accounting. ',
  `MANAGER_ID` int NULL DEFAULT NULL COMMENT 'Manager_id of a department. Foreign key to employee_id column of employees table. The manager_id column of the employee table references this column.',
  `LOCATION_ID` int NULL DEFAULT NULL COMMENT 'Location id where a department is located. Foreign key to location_id column of locations table.',
  PRIMARY KEY (`DEPARTMENT_ID`) USING BTREE,
  INDEX `DEPT_LOCATION_IX`(`LOCATION_ID`) USING BTREE,
  INDEX `DEPT_MGR_FK`(`MANAGER_ID`) USING BTREE,
  CONSTRAINT `DEPT_LOC_FK` FOREIGN KEY (`LOCATION_ID`) REFERENCES `locations` (`LOCATION_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `DEPT_MGR_FK` FOREIGN KEY (`MANAGER_ID`) REFERENCES `employees` (`EMPLOYEE_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'Departments table that shows details of departments where employees\nwork. Contains 27 rows; references with locations, employees, and job_history tables.' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of departments
-- ----------------------------
INSERT INTO `departments` VALUES (10, 'Administration', 200, 1700);
INSERT INTO `departments` VALUES (20, 'Marketing', 201, 1800);
INSERT INTO `departments` VALUES (30, 'Purchasing', 114, 1700);
INSERT INTO `departments` VALUES (40, 'Human Resources', 203, 2400);
INSERT INTO `departments` VALUES (50, 'Shipping', 121, 1500);
INSERT INTO `departments` VALUES (60, 'IT', 103, 1400);
INSERT INTO `departments` VALUES (70, 'Public Relations', 204, 2700);
INSERT INTO `departments` VALUES (80, 'Sales', 145, 2500);
INSERT INTO `departments` VALUES (90, 'Executive', 100, 1700);
INSERT INTO `departments` VALUES (100, 'Finance', 108, 1700);
INSERT INTO `departments` VALUES (110, 'Accounting', 205, 1700);
INSERT INTO `departments` VALUES (120, 'Treasury', NULL, 1700);
INSERT INTO `departments` VALUES (130, 'Corporate Tax', NULL, 1700);
INSERT INTO `departments` VALUES (140, 'Control And Credit', NULL, 1700);
INSERT INTO `departments` VALUES (150, 'Shareholder Services', NULL, 1700);
INSERT INTO `departments` VALUES (160, 'Benefits', NULL, 1700);
INSERT INTO `departments` VALUES (170, 'Manufacturing', NULL, 1700);
INSERT INTO `departments` VALUES (180, 'Construction', NULL, 1700);
INSERT INTO `departments` VALUES (190, 'Contracting', NULL, 1700);
INSERT INTO `departments` VALUES (200, 'Operations', NULL, 1700);
INSERT INTO `departments` VALUES (210, 'IT Support', NULL, 1700);
INSERT INTO `departments` VALUES (220, 'NOC', NULL, 1700);
INSERT INTO `departments` VALUES (230, 'IT Helpdesk', NULL, 1700);
INSERT INTO `departments` VALUES (240, 'Government Sales', NULL, 1700);
INSERT INTO `departments` VALUES (250, 'Retail Sales', NULL, 1700);
INSERT INTO `departments` VALUES (260, 'Recruiting', NULL, 1700);
INSERT INTO `departments` VALUES (270, 'Payroll', NULL, 1700);

-- ----------------------------
-- Table structure for employees
-- ----------------------------
DROP TABLE IF EXISTS `employees`;
CREATE TABLE `employees`  (
  `EMPLOYEE_ID` int NOT NULL COMMENT 'Primary key of employees table.',
  `FIRST_NAME` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'First name of the employee. A not null column.',
  `LAST_NAME` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Last name of the employee. A not null column.',
  `EMAIL` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Email id of the employee',
  `PHONE_NUMBER` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'Phone number of the employee; includes country code and area code',
  `HIRE_DATE` datetime NOT NULL COMMENT 'Date when the employee started on this job. A not null column.',
  `JOB_ID` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Current job of the employee; foreign key to job_id column of the\njobs table. A not null column.',
  `SALARY` float(8, 2) NULL DEFAULT NULL COMMENT 'Monthly salary of the employee. Must be greater\nthan zero (enforced by constraint emp_salary_min)',
  `COMMISSION_PCT` int NULL DEFAULT NULL COMMENT 'Commission percentage of the employee; Only employees in sales\ndepartment elgible for commission percentage',
  `MANAGER_ID` int NULL DEFAULT NULL COMMENT 'Manager id of the employee; has same domain as manager_id in\ndepartments table. Foreign key to employee_id column of employees table.\n(useful for reflexive joins and CONNECT BY query)',
  `DEPARTMENT_ID` int NULL DEFAULT NULL COMMENT 'Department id where employee works; foreign key to department_id\ncolumn of the departments table',
  PRIMARY KEY (`EMPLOYEE_ID`) USING BTREE,
  INDEX `EMP_DEPARTMENT_IX`(`DEPARTMENT_ID`) USING BTREE,
  INDEX `EMP_JOB_IX`(`JOB_ID`) USING BTREE,
  INDEX `EMP_MANAGER_IX`(`MANAGER_ID`) USING BTREE,
  INDEX `EMP_NAME_IX`(`LAST_NAME`, `FIRST_NAME`) USING BTREE,
  CONSTRAINT `EMP_DEPT_FK` FOREIGN KEY (`DEPARTMENT_ID`) REFERENCES `departments` (`DEPARTMENT_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `EMP_JOB_FK` FOREIGN KEY (`JOB_ID`) REFERENCES `jobs` (`JOB_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `EMP_MANAGER_FK` FOREIGN KEY (`MANAGER_ID`) REFERENCES `employees` (`EMPLOYEE_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'employees table. Contains 107 rows. References with departments,\njobs, job_history tables. Contains a self reference.' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of employees
-- ----------------------------
INSERT INTO `employees` VALUES (100, 'Steven', 'King', 'SKING', '515.123.4567', '2003-06-17 00:00:00', 'AD_PRES', 24000.00, NULL, NULL, 90);
INSERT INTO `employees` VALUES (101, 'Neena', 'Kochhar', 'NKOCHHAR', '515.123.4568', '2005-09-21 00:00:00', 'AD_VP', 17000.00, NULL, 100, 90);
INSERT INTO `employees` VALUES (102, 'Lex', 'De Haan', 'LDEHAAN', '515.123.4569', '2001-01-13 00:00:00', 'AD_VP', 17000.00, NULL, 100, 90);
INSERT INTO `employees` VALUES (103, 'Alexander', 'Hunold', 'AHUNOLD', '590.423.4567', '2006-01-03 00:00:00', 'IT_PROG', 9000.00, NULL, 102, 60);
INSERT INTO `employees` VALUES (104, 'Bruce', 'Ernst', 'BERNST', '590.423.4568', '2007-05-21 00:00:00', 'IT_PROG', 6000.00, NULL, 103, 60);
INSERT INTO `employees` VALUES (105, 'David', 'Austin', 'DAUSTIN', '590.423.4569', '2005-06-25 00:00:00', 'IT_PROG', 4800.00, NULL, 103, 60);
INSERT INTO `employees` VALUES (106, 'Valli', 'Pataballa', 'VPATABAL', '590.423.4560', '2006-02-05 00:00:00', 'IT_PROG', 4800.00, NULL, 103, 60);
INSERT INTO `employees` VALUES (107, 'Diana', 'Lorentz', 'DLORENTZ', '590.423.5567', '2007-02-07 00:00:00', 'IT_PROG', 4200.00, NULL, 103, 60);
INSERT INTO `employees` VALUES (108, 'Nancy', 'Greenberg', 'NGREENBE', '515.124.4569', '2002-08-17 00:00:00', 'FI_MGR', 12008.00, NULL, 101, 100);
INSERT INTO `employees` VALUES (109, 'Daniel', 'Faviet', 'DFAVIET', '515.124.4169', '2002-08-16 00:00:00', 'FI_ACCOUNT', 9000.00, NULL, 108, 100);
INSERT INTO `employees` VALUES (110, 'John', 'Chen', 'JCHEN', '515.124.4269', '2005-09-28 00:00:00', 'FI_ACCOUNT', 8200.00, NULL, 108, 100);
INSERT INTO `employees` VALUES (111, 'Ismael', 'Sciarra', 'ISCIARRA', '515.124.4369', '2005-09-30 00:00:00', 'FI_ACCOUNT', 7700.00, NULL, 108, 100);
INSERT INTO `employees` VALUES (112, 'Jose Manuel', 'Urman', 'JMURMAN', '515.124.4469', '2006-03-07 00:00:00', 'FI_ACCOUNT', 7800.00, NULL, 108, 100);
INSERT INTO `employees` VALUES (113, 'Luis', 'Popp', 'LPOPP', '515.124.4567', '2007-12-07 00:00:00', 'FI_ACCOUNT', 6900.00, NULL, 108, 100);
INSERT INTO `employees` VALUES (114, 'Den', 'Raphaely', 'DRAPHEAL', '515.127.4561', '2002-12-07 00:00:00', 'PU_MAN', 11000.00, NULL, 100, 30);
INSERT INTO `employees` VALUES (115, 'Alexander', 'Khoo', 'AKHOO', '515.127.4562', '2003-05-18 00:00:00', 'PU_CLERK', 3100.00, NULL, 114, 30);
INSERT INTO `employees` VALUES (116, 'Shelli', 'Baida', 'SBAIDA', '515.127.4563', '2005-12-24 00:00:00', 'PU_CLERK', 2900.00, NULL, 114, 30);
INSERT INTO `employees` VALUES (117, 'Sigal', 'Tobias', 'STOBIAS', '515.127.4564', '2005-07-24 00:00:00', 'PU_CLERK', 2800.00, NULL, 114, 30);
INSERT INTO `employees` VALUES (118, 'Guy', 'Himuro', 'GHIMURO', '515.127.4565', '2006-11-15 00:00:00', 'PU_CLERK', 2600.00, NULL, 114, 30);
INSERT INTO `employees` VALUES (119, 'Karen', 'Colmenares', 'KCOLMENA', '515.127.4566', '2007-08-10 00:00:00', 'PU_CLERK', 2500.00, NULL, 114, 30);
INSERT INTO `employees` VALUES (120, 'Matthew', 'Weiss', 'MWEISS', '650.123.1234', '2004-07-18 00:00:00', 'ST_MAN', 8000.00, NULL, 100, 50);
INSERT INTO `employees` VALUES (121, 'Adam', 'Fripp', 'AFRIPP', '650.123.2234', '2005-04-10 00:00:00', 'ST_MAN', 8200.00, NULL, 100, 50);
INSERT INTO `employees` VALUES (122, 'Payam', 'Kaufling', 'PKAUFLIN', '650.123.3234', '2003-05-01 00:00:00', 'ST_MAN', 7900.00, NULL, 100, 50);
INSERT INTO `employees` VALUES (123, 'Shanta', 'Vollman', 'SVOLLMAN', '650.123.4234', '2005-10-10 00:00:00', 'ST_MAN', 6500.00, NULL, 100, 50);
INSERT INTO `employees` VALUES (124, 'Kevin', 'Mourgos', 'KMOURGOS', '650.123.5234', '2007-11-16 00:00:00', 'ST_MAN', 5800.00, NULL, 100, 50);
INSERT INTO `employees` VALUES (125, 'Julia', 'Nayer', 'JNAYER', '650.124.1214', '2005-07-16 00:00:00', 'ST_CLERK', 3200.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (126, 'Irene', 'Mikkilineni', 'IMIKKILI', '650.124.1224', '2006-09-28 00:00:00', 'ST_CLERK', 2700.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (127, 'James', 'Landry', 'JLANDRY', '650.124.1334', '2007-01-14 00:00:00', 'ST_CLERK', 2400.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (128, 'Steven', 'Markle', 'SMARKLE', '650.124.1434', '2008-03-08 00:00:00', 'ST_CLERK', 2200.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (129, 'Laura', 'Bissot', 'LBISSOT', '650.124.5234', '2005-08-20 00:00:00', 'ST_CLERK', 3300.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (130, 'Mozhe', 'Atkinson', 'MATKINSO', '650.124.6234', '2005-10-30 00:00:00', 'ST_CLERK', 2800.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (131, 'James', 'Marlow', 'JAMRLOW', '650.124.7234', '2005-02-16 00:00:00', 'ST_CLERK', 2500.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (132, 'TJ', 'Olson', 'TJOLSON', '650.124.8234', '2007-04-10 00:00:00', 'ST_CLERK', 2100.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (133, 'Jason', 'Mallin', 'JMALLIN', '650.127.1934', '2004-06-14 00:00:00', 'ST_CLERK', 3300.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (134, 'Michael', 'Rogers', 'MROGERS', '650.127.1834', '2006-08-26 00:00:00', 'ST_CLERK', 2900.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (135, 'Ki', 'Gee', 'KGEE', '650.127.1734', '2007-12-12 00:00:00', 'ST_CLERK', 2400.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (136, 'Hazel', 'Philtanker', 'HPHILTAN', '650.127.1634', '2008-02-06 00:00:00', 'ST_CLERK', 2200.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (137, 'Renske', 'Ladwig', 'RLADWIG', '650.121.1234', '2003-07-14 00:00:00', 'ST_CLERK', 3600.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (138, 'Stephen', 'Stiles', 'SSTILES', '650.121.2034', '2005-10-26 00:00:00', 'ST_CLERK', 3200.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (139, 'John', 'Seo', 'JSEO', '650.121.2019', '2006-02-12 00:00:00', 'ST_CLERK', 2700.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (140, 'Joshua', 'Patel', 'JPATEL', '650.121.1834', '2006-04-06 00:00:00', 'ST_CLERK', 2500.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (141, 'Trenna', 'Rajs', 'TRAJS', '650.121.8009', '2003-10-17 00:00:00', 'ST_CLERK', 3500.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (142, 'Curtis', 'Davies', 'CDAVIES', '650.121.2994', '2005-01-29 00:00:00', 'ST_CLERK', 3100.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (143, 'Randall', 'Matos', 'RMATOS', '650.121.2874', '2006-03-15 00:00:00', 'ST_CLERK', 2600.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (144, 'Peter', 'Vargas', 'PVARGAS', '650.121.2004', '2006-07-09 00:00:00', 'ST_CLERK', 2500.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (145, 'John', 'Russell', 'JRUSSEL', '011.44.1344.429268', '2004-10-01 00:00:00', 'SA_MAN', 14000.00, 0.40, 100, 80);
INSERT INTO `employees` VALUES (146, 'Karen', 'Partners', 'KPARTNER', '011.44.1344.467268', '2005-01-05 00:00:00', 'SA_MAN', 13500.00, 0.30, 100, 80);
INSERT INTO `employees` VALUES (147, 'Alberto', 'Errazuriz', 'AERRAZUR', '011.44.1344.429278', '2005-03-10 00:00:00', 'SA_MAN', 12000.00, 0.30, 100, 80);
INSERT INTO `employees` VALUES (148, 'Gerald', 'Cambrault', 'GCAMBRAU', '011.44.1344.619268', '2007-10-15 00:00:00', 'SA_MAN', 11000.00, 0.30, 100, 80);
INSERT INTO `employees` VALUES (149, 'Eleni', 'Zlotkey', 'EZLOTKEY', '011.44.1344.429018', '2008-01-29 00:00:00', 'SA_MAN', 10500.00, 0.20, 100, 80);
INSERT INTO `employees` VALUES (150, 'Peter', 'Tucker', 'PTUCKER', '011.44.1344.129268', '2005-01-30 00:00:00', 'SA_REP', 10000.00, 0.30, 145, 80);
INSERT INTO `employees` VALUES (151, 'David', 'Bernstein', 'DBERNSTE', '011.44.1344.345268', '2005-03-24 00:00:00', 'SA_REP', 9500.00, 0.25, 145, 80);
INSERT INTO `employees` VALUES (152, 'Peter', 'Hall', 'PHALL', '011.44.1344.478968', '2005-08-20 00:00:00', 'SA_REP', 9000.00, 0.25, 145, 80);
INSERT INTO `employees` VALUES (153, 'Christopher', 'Olsen', 'COLSEN', '011.44.1344.498718', '2006-03-30 00:00:00', 'SA_REP', 8000.00, 0.20, 145, 80);
INSERT INTO `employees` VALUES (154, 'Nanette', 'Cambrault', 'NCAMBRAU', '011.44.1344.987668', '2006-12-09 00:00:00', 'SA_REP', 7500.00, 0.20, 145, 80);
INSERT INTO `employees` VALUES (155, 'Oliver', 'Tuvault', 'OTUVAULT', '011.44.1344.486508', '2007-11-23 00:00:00', 'SA_REP', 7000.00, 0.15, 145, 80);
INSERT INTO `employees` VALUES (156, 'Janette', 'King', 'JKING', '011.44.1345.429268', '2004-01-30 00:00:00', 'SA_REP', 10000.00, 0.35, 146, 80);
INSERT INTO `employees` VALUES (157, 'Patrick', 'Sully', 'PSULLY', '011.44.1345.929268', '2004-03-04 00:00:00', 'SA_REP', 9500.00, 0.35, 146, 80);
INSERT INTO `employees` VALUES (158, 'Allan', 'McEwen', 'AMCEWEN', '011.44.1345.829268', '2004-08-01 00:00:00', 'SA_REP', 9000.00, 0.35, 146, 80);
INSERT INTO `employees` VALUES (159, 'Lindsey', 'Smith', 'LSMITH', '011.44.1345.729268', '2005-03-10 00:00:00', 'SA_REP', 8000.00, 0.30, 146, 80);
INSERT INTO `employees` VALUES (160, 'Louise', 'Doran', 'LDORAN', '011.44.1345.629268', '2005-12-15 00:00:00', 'SA_REP', 7500.00, 0.30, 146, 80);
INSERT INTO `employees` VALUES (161, 'Sarath', 'Sewall', 'SSEWALL', '011.44.1345.529268', '2006-11-03 00:00:00', 'SA_REP', 7000.00, 0.25, 146, 80);
INSERT INTO `employees` VALUES (162, 'Clara', 'Vishney', 'CVISHNEY', '011.44.1346.129268', '2005-11-11 00:00:00', 'SA_REP', 10500.00, 0.25, 147, 80);
INSERT INTO `employees` VALUES (163, 'Danielle', 'Greene', 'DGREENE', '011.44.1346.229268', '2007-03-19 00:00:00', 'SA_REP', 9500.00, 0.15, 147, 80);
INSERT INTO `employees` VALUES (164, 'Mattea', 'Marvins', 'MMARVINS', '011.44.1346.329268', '2008-01-24 00:00:00', 'SA_REP', 7200.00, 0.10, 147, 80);
INSERT INTO `employees` VALUES (165, 'David', 'Lee', 'DLEE', '011.44.1346.529268', '2008-02-23 00:00:00', 'SA_REP', 6800.00, 0.10, 147, 80);
INSERT INTO `employees` VALUES (166, 'Sundar', 'Ande', 'SANDE', '011.44.1346.629268', '2008-03-24 00:00:00', 'SA_REP', 6400.00, 0.10, 147, 80);
INSERT INTO `employees` VALUES (167, 'Amit', 'Banda', 'ABANDA', '011.44.1346.729268', '2008-04-21 00:00:00', 'SA_REP', 6200.00, 0.10, 147, 80);
INSERT INTO `employees` VALUES (168, 'Lisa', 'Ozer', 'LOZER', '011.44.1343.929268', '2005-03-11 00:00:00', 'SA_REP', 11500.00, 0.25, 148, 80);
INSERT INTO `employees` VALUES (169, 'Harrison', 'Bloom', 'HBLOOM', '011.44.1343.829268', '2006-03-23 00:00:00', 'SA_REP', 10000.00, 0.20, 148, 80);
INSERT INTO `employees` VALUES (170, 'Tayler', 'Fox', 'TFOX', '011.44.1343.729268', '2006-01-24 00:00:00', 'SA_REP', 9600.00, 0.20, 148, 80);
INSERT INTO `employees` VALUES (171, 'William', 'Smith', 'WSMITH', '011.44.1343.629268', '2007-02-23 00:00:00', 'SA_REP', 7400.00, 0.15, 148, 80);
INSERT INTO `employees` VALUES (172, 'Elizabeth', 'Bates', 'EBATES', '011.44.1343.529268', '2007-03-24 00:00:00', 'SA_REP', 7300.00, 0.15, 148, 80);
INSERT INTO `employees` VALUES (173, 'Sundita', 'Kumar', 'SKUMAR', '011.44.1343.329268', '2008-04-21 00:00:00', 'SA_REP', 6100.00, 0.10, 148, 80);
INSERT INTO `employees` VALUES (174, 'Ellen', 'Abel', 'EABEL', '011.44.1644.429267', '2004-05-11 00:00:00', 'SA_REP', 11000.00, 0.30, 149, 80);
INSERT INTO `employees` VALUES (175, 'Alyssa', 'Hutton', 'AHUTTON', '011.44.1644.429266', '2005-03-19 00:00:00', 'SA_REP', 8800.00, 0.25, 149, 80);
INSERT INTO `employees` VALUES (176, 'Jonathon', 'Taylor', 'JTAYLOR', '011.44.1644.429265', '2006-03-24 00:00:00', 'SA_REP', 8600.00, 0.20, 149, 80);
INSERT INTO `employees` VALUES (177, 'Jack', 'Livingston', 'JLIVINGS', '011.44.1644.429264', '2006-04-23 00:00:00', 'SA_REP', 8400.00, 0.20, 149, 80);
INSERT INTO `employees` VALUES (178, 'Kimberely', 'Grant', 'KGRANT', '011.44.1644.429263', '2007-05-24 00:00:00', 'SA_REP', 7000.00, 0.15, 149, NULL);
INSERT INTO `employees` VALUES (179, 'Charles', 'Johnson', 'CJOHNSON', '011.44.1644.429262', '2008-01-04 00:00:00', 'SA_REP', 6200.00, 0.10, 149, 80);
INSERT INTO `employees` VALUES (180, 'Winston', 'Taylor', 'WTAYLOR', '650.507.9876', '2006-01-24 00:00:00', 'SH_CLERK', 3200.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (181, 'Jean', 'Fleaur', 'JFLEAUR', '650.507.9877', '2006-02-23 00:00:00', 'SH_CLERK', 3100.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (182, 'Martha', 'Sullivan', 'MSULLIVA', '650.507.9878', '2007-06-21 00:00:00', 'SH_CLERK', 2500.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (183, 'Girard', 'Geoni', 'GGEONI', '650.507.9879', '2008-02-03 00:00:00', 'SH_CLERK', 2800.00, NULL, 120, 50);
INSERT INTO `employees` VALUES (184, 'Nandita', 'Sarchand', 'NSARCHAN', '650.509.1876', '2004-01-27 00:00:00', 'SH_CLERK', 4200.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (185, 'Alexis', 'Bull', 'ABULL', '650.509.2876', '2005-02-20 00:00:00', 'SH_CLERK', 4100.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (186, 'Julia', 'Dellinger', 'JDELLING', '650.509.3876', '2006-06-24 00:00:00', 'SH_CLERK', 3400.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (187, 'Anthony', 'Cabrio', 'ACABRIO', '650.509.4876', '2007-02-07 00:00:00', 'SH_CLERK', 3000.00, NULL, 121, 50);
INSERT INTO `employees` VALUES (188, 'Kelly', 'Chung', 'KCHUNG', '650.505.1876', '2005-06-14 00:00:00', 'SH_CLERK', 3800.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (189, 'Jennifer', 'Dilly', 'JDILLY', '650.505.2876', '2005-08-13 00:00:00', 'SH_CLERK', 3600.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (190, 'Timothy', 'Gates', 'TGATES', '650.505.3876', '2006-07-11 00:00:00', 'SH_CLERK', 2900.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (191, 'Randall', 'Perkins', 'RPERKINS', '650.505.4876', '2007-12-19 00:00:00', 'SH_CLERK', 2500.00, NULL, 122, 50);
INSERT INTO `employees` VALUES (192, 'Sarah', 'Bell', 'SBELL', '650.501.1876', '2004-02-04 00:00:00', 'SH_CLERK', 4000.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (193, 'Britney', 'Everett', 'BEVERETT', '650.501.2876', '2005-03-03 00:00:00', 'SH_CLERK', 3900.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (194, 'Samuel', 'McCain', 'SMCCAIN', '650.501.3876', '2006-07-01 00:00:00', 'SH_CLERK', 3200.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (195, 'Vance', 'Jones', 'VJONES', '650.501.4876', '2007-03-17 00:00:00', 'SH_CLERK', 2800.00, NULL, 123, 50);
INSERT INTO `employees` VALUES (196, 'Alana', 'Walsh', 'AWALSH', '650.507.9811', '2006-04-24 00:00:00', 'SH_CLERK', 3100.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (197, 'Kevin', 'Feeney', 'KFEENEY', '650.507.9822', '2006-05-23 00:00:00', 'SH_CLERK', 3000.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (198, 'Donald', 'OConnell', 'DOCONNEL', '650.507.9833', '2007-06-21 00:00:00', 'SH_CLERK', 2600.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (199, 'Douglas', 'Grant', 'DGRANT', '650.507.9844', '2008-01-13 00:00:00', 'SH_CLERK', 2600.00, NULL, 124, 50);
INSERT INTO `employees` VALUES (200, 'Jennifer', 'Whalen', 'JWHALEN', '515.123.4444', '2003-09-17 00:00:00', 'AD_ASST', 4400.00, NULL, 101, 10);
INSERT INTO `employees` VALUES (201, 'Michael', 'Hartstein', 'MHARTSTE', '515.123.5555', '2004-02-17 00:00:00', 'MK_MAN', 13000.00, NULL, 100, 20);
INSERT INTO `employees` VALUES (202, 'Pat', 'Fay', 'PFAY', '603.123.6666', '2005-08-17 00:00:00', 'MK_REP', 6000.00, NULL, 201, 20);
INSERT INTO `employees` VALUES (203, 'Susan', 'Mavris', 'SMAVRIS', '515.123.7777', '2002-06-07 00:00:00', 'HR_REP', 6500.00, NULL, 101, 40);
INSERT INTO `employees` VALUES (204, 'Hermann', 'Baer', 'HBAER', '515.123.8888', '2002-06-07 00:00:00', 'PR_REP', 10000.00, NULL, 101, 70);
INSERT INTO `employees` VALUES (205, 'Shelley', 'Higgins', 'SHIGGINS', '515.123.8080', '2002-06-07 00:00:00', 'AC_MGR', 12008.00, NULL, 101, 110);
INSERT INTO `employees` VALUES (206, 'William', 'Gietz', 'WGIETZ', '515.123.8181', '2002-06-07 00:00:00', 'AC_ACCOUNT', 8300.00, NULL, 205, 110);

-- ----------------------------
-- Table structure for job_history
-- ----------------------------
DROP TABLE IF EXISTS `job_history`;
CREATE TABLE `job_history`  (
  `EMPLOYEE_ID` int NOT NULL COMMENT 'A not null column in the complex primary key employee_id+start_date.\nForeign key to employee_id column of the employee table',
  `START_DATE` datetime NOT NULL COMMENT 'A not null column in the complex primary key employee_id+start_date.\nMust be less than the end_date of the job_history table. (enforced by\nconstraint jhist_date_interval)',
  `END_DATE` datetime NOT NULL COMMENT 'Last day of the employee in this job role. A not null column. Must be\ngreater than the start_date of the job_history table.\n(enforced by constraint jhist_date_interval)',
  `JOB_ID` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Job role in which the employee worked in the past; foreign key to\njob_id column in the jobs table. A not null column.',
  `DEPARTMENT_ID` int NULL DEFAULT NULL COMMENT 'Department id in which the employee worked in the past; foreign key to deparment_id column in the departments table',
  PRIMARY KEY (`EMPLOYEE_ID`, `START_DATE`) USING BTREE,
  INDEX `JHIST_DEPARTMENT_IX`(`DEPARTMENT_ID`) USING BTREE,
  INDEX `JHIST_EMPLOYEE_IX`(`EMPLOYEE_ID`) USING BTREE,
  INDEX `JHIST_JOB_IX`(`JOB_ID`) USING BTREE,
  CONSTRAINT `JHIST_DEPT_FK` FOREIGN KEY (`DEPARTMENT_ID`) REFERENCES `departments` (`DEPARTMENT_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `JHIST_EMP_FK` FOREIGN KEY (`EMPLOYEE_ID`) REFERENCES `employees` (`EMPLOYEE_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `JHIST_JOB_FK` FOREIGN KEY (`JOB_ID`) REFERENCES `jobs` (`JOB_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'Table that stores job history of the employees. If an employee\nchanges departments within the job or changes jobs within the department,\nnew rows get inserted into this table with old job information of the\nemployee. Contains a complex primary key: employee_id+start_date.\nContains 25 rows. References with jobs, employees, and departments tables.' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of job_history
-- ----------------------------
INSERT INTO `job_history` VALUES (101, '1997-09-21 00:00:00', '2001-10-27 00:00:00', 'AC_ACCOUNT', 110);
INSERT INTO `job_history` VALUES (101, '2001-10-28 00:00:00', '2005-03-15 00:00:00', 'AC_MGR', 110);
INSERT INTO `job_history` VALUES (102, '2001-01-13 00:00:00', '2006-07-24 00:00:00', 'IT_PROG', 60);
INSERT INTO `job_history` VALUES (114, '2006-03-24 00:00:00', '2007-12-31 00:00:00', 'ST_CLERK', 50);
INSERT INTO `job_history` VALUES (122, '2007-01-01 00:00:00', '2007-12-31 00:00:00', 'ST_CLERK', 50);
INSERT INTO `job_history` VALUES (176, '2006-03-24 00:00:00', '2006-12-31 00:00:00', 'SA_REP', 80);
INSERT INTO `job_history` VALUES (176, '2007-01-01 00:00:00', '2007-12-31 00:00:00', 'SA_MAN', 80);
INSERT INTO `job_history` VALUES (200, '1995-09-17 00:00:00', '2001-06-17 00:00:00', 'AD_ASST', 90);
INSERT INTO `job_history` VALUES (200, '2002-07-01 00:00:00', '2006-12-31 00:00:00', 'AC_ACCOUNT', 90);
INSERT INTO `job_history` VALUES (201, '2004-02-17 00:00:00', '2007-12-19 00:00:00', 'MK_REP', 20);

-- ----------------------------
-- Table structure for jobs
-- ----------------------------
DROP TABLE IF EXISTS `jobs`;
CREATE TABLE `jobs`  (
  `JOB_ID` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'Primary key of jobs table.',
  `JOB_TITLE` varchar(35) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'A not null column that shows job title, e.g. AD_VP, FI_ACCOUNTANT',
  `MIN_SALARY` int NULL DEFAULT NULL COMMENT 'Minimum salary for a job title.',
  `MAX_SALARY` int NULL DEFAULT NULL COMMENT 'Maximum salary for a job title',
  PRIMARY KEY (`JOB_ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'jobs table with job titles and salary ranges. Contains 19 rows.\nReferences with employees and job_history table.' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of jobs
-- ----------------------------
INSERT INTO `jobs` VALUES ('AC_ACCOUNT', 'Public Accountant', 4200, 9000);
INSERT INTO `jobs` VALUES ('AC_MGR', 'Accounting Manager', 8200, 16000);
INSERT INTO `jobs` VALUES ('AD_ASST', 'Administration Assistant', 3000, 6000);
INSERT INTO `jobs` VALUES ('AD_PRES', 'President', 20080, 40000);
INSERT INTO `jobs` VALUES ('AD_VP', 'Administration Vice President', 15000, 30000);
INSERT INTO `jobs` VALUES ('FI_ACCOUNT', 'Accountant', 4200, 9000);
INSERT INTO `jobs` VALUES ('FI_MGR', 'Finance Manager', 8200, 16000);
INSERT INTO `jobs` VALUES ('HR_REP', 'Human Resources Representative', 4000, 9000);
INSERT INTO `jobs` VALUES ('IT_PROG', 'Programmer', 4000, 10000);
INSERT INTO `jobs` VALUES ('MK_MAN', 'Marketing Manager', 9000, 15000);
INSERT INTO `jobs` VALUES ('MK_REP', 'Marketing Representative', 4000, 9000);
INSERT INTO `jobs` VALUES ('PR_REP', 'Public Relations Representative', 4500, 10500);
INSERT INTO `jobs` VALUES ('PU_CLERK', 'Purchasing Clerk', 2500, 5500);
INSERT INTO `jobs` VALUES ('PU_MAN', 'Purchasing Manager', 8000, 15000);
INSERT INTO `jobs` VALUES ('SA_MAN', 'Sales Manager', 10000, 20080);
INSERT INTO `jobs` VALUES ('SA_REP', 'Sales Representative', 6000, 12008);
INSERT INTO `jobs` VALUES ('SH_CLERK', 'Shipping Clerk', 2500, 5500);
INSERT INTO `jobs` VALUES ('ST_CLERK', 'Stock Clerk', 2008, 5000);
INSERT INTO `jobs` VALUES ('ST_MAN', 'Stock Manager', 5500, 8500);

-- ----------------------------
-- Table structure for locations
-- ----------------------------
DROP TABLE IF EXISTS `locations`;
CREATE TABLE `locations`  (
  `LOCATION_ID` int NOT NULL COMMENT 'Primary key of locations table',
  `STREET_ADDRESS` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'Street address of an office, warehouse, or production site of a company.\nContains building number and street name',
  `POSTAL_CODE` varchar(12) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'Postal code of the location of an office, warehouse, or production site\nof a company. ',
  `CITY` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'A not null column that shows city where an office, warehouse, or\nproduction site of a company is located. ',
  `STATE_PROVINCE` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'State or Province where an office, warehouse, or production site of a\ncompany is located.',
  `COUNTRY_ID` char(2) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'Country where an office, warehouse, or production site of a company is\nlocated. Foreign key to country_id column of the countries table.',
  PRIMARY KEY (`LOCATION_ID`) USING BTREE,
  INDEX `LOC_CITY_IX`(`CITY`) USING BTREE,
  INDEX `LOC_COUNTRY_IX`(`COUNTRY_ID`) USING BTREE,
  INDEX `LOC_STATE_PROVINCE_IX`(`STATE_PROVINCE`) USING BTREE,
  CONSTRAINT `LOC_C_ID_FK` FOREIGN KEY (`COUNTRY_ID`) REFERENCES `countries` (`COUNTRY_ID`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = 'Locations table that contains specific address of a specific office,\nwarehouse, and/or production site of a company. Does not store addresses /\nlocations of customers. Contains 23 rows; references with the\ndepartments and countries tables. ' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of locations
-- ----------------------------
INSERT INTO `locations` VALUES (1000, '1297 Via Cola di Rie', '00989', 'Roma', NULL, 'IT');
INSERT INTO `locations` VALUES (1100, '93091 Calle della Testa', '10934', 'Venice', NULL, 'IT');
INSERT INTO `locations` VALUES (1200, '2017 Shinjuku-ku', '1689', 'Tokyo', 'Tokyo Prefecture', 'JP');
INSERT INTO `locations` VALUES (1300, '9450 Kamiya-cho', '6823', 'Hiroshima', NULL, 'JP');
INSERT INTO `locations` VALUES (1400, '2014 Jabberwocky Rd', '26192', 'Southlake', 'Texas', 'US');
INSERT INTO `locations` VALUES (1500, '2011 Interiors Blvd', '99236', 'South San Francisco', 'California', 'US');
INSERT INTO `locations` VALUES (1600, '2007 Zagora St', '50090', 'South Brunswick', 'New Jersey', 'US');
INSERT INTO `locations` VALUES (1700, '2004 Charade Rd', '98199', 'Seattle', 'Washington', 'US');
INSERT INTO `locations` VALUES (1800, '147 Spadina Ave', 'M5V 2L7', 'Toronto', 'Ontario', 'CA');
INSERT INTO `locations` VALUES (1900, '6092 Boxwood St', 'YSW 9T2', 'Whitehorse', 'Yukon', 'CA');
INSERT INTO `locations` VALUES (2000, '40-5-12 Laogianggen', '190518', 'Beijing', NULL, 'CN');
INSERT INTO `locations` VALUES (2100, '1298 Vileparle (E)', '490231', 'Bombay', 'Maharashtra', 'IN');
INSERT INTO `locations` VALUES (2200, '12-98 Victoria Street', '2901', 'Sydney', 'New South Wales', 'AU');
INSERT INTO `locations` VALUES (2300, '198 Clementi North', '540198', 'Singapore', NULL, 'SG');
INSERT INTO `locations` VALUES (2400, '8204 Arthur St', NULL, 'London', NULL, 'UK');
INSERT INTO `locations` VALUES (2500, 'Magdalen Centre, The Oxford Science Park', 'OX9 9ZB', 'Oxford', 'Oxford', 'UK');
INSERT INTO `locations` VALUES (2600, '9702 Chester Road', '09629850293', 'Stretford', 'Manchester', 'UK');
INSERT INTO `locations` VALUES (2700, 'Schwanthalerstr. 7031', '80925', 'Munich', 'Bavaria', 'DE');
INSERT INTO `locations` VALUES (2800, 'Rua Frei Caneca 1360 ', '01307-002', 'Sao Paulo', 'Sao Paulo', 'BR');
INSERT INTO `locations` VALUES (2900, '20 Rue des Corps-Saints', '1730', 'Geneva', 'Geneve', 'CH');
INSERT INTO `locations` VALUES (3000, 'Murtenstrasse 921', '3095', 'Bern', 'BE', 'CH');
INSERT INTO `locations` VALUES (3100, 'Pieter Breughelstraat 837', '3029SK', 'Utrecht', 'Utrecht', 'NL');
INSERT INTO `locations` VALUES (3200, 'Mariano Escobedo 9991', '11932', 'Mexico City', 'Distrito Federal,', 'MX');

-- ----------------------------
-- Table structure for regions
-- ----------------------------
DROP TABLE IF EXISTS `regions`;
CREATE TABLE `regions`  (
  `REGION_ID` int NOT NULL,
  `REGION_NAME` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`REGION_ID`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of regions
-- ----------------------------
INSERT INTO `regions` VALUES (1.000000000000000000000000000000, 'Europe');
INSERT INTO `regions` VALUES (2.000000000000000000000000000000, 'Americas');
INSERT INTO `regions` VALUES (3.000000000000000000000000000000, 'Asia');
INSERT INTO `regions` VALUES (4.000000000000000000000000000000, 'Middle East and Africa');

SET FOREIGN_KEY_CHECKS = 1;
</pre><p>&nbsp;</p><p>表：</p><p><img src='./assets/1718090687957.png' alt='1718090687957' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n587' class='md-header-anchor '></a>a）select基本查询介绍</h4><p><img src='./assets/1718061914243.png' alt='1718061914243' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>SELECT 语句从数据库中返回信息。使用一个 SELECT 语句，可以做下面的事：</p><ul><li><strong>列选择：</strong>能够使用 SELECT 语句的列选择功能选择表中的列，这些列是想要用查询返回的。当查询时，能够返回列中的数据。</li><li><strong>行选择：</strong>能够使用 SELECT 语句的行选择功能选择表中的行，这些行是想要用查询返回的。能够使用不同的标准限制看见的行。</li><li><strong>连接：</strong>能够使用 SELECT 语句的连接功能来集合数据，这些数据被存储在不同的表中，在它们之间可以创建连接，查询出我们所关心的数据。</li></ul><p>&nbsp;</p><p><strong>SELECT基本语法：</strong></p><p>在最简单的形式中，SELECT 语句必须包含下面的内容：</p><ul><li>一个 SELECT 子句，指定被显示的列</li><li>一个 FROM 子句，指定表，该表包含 SELECT 子句中的字段列表</li></ul><figure><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td>SELECT</td><td>是一个或多个字段的列表</td></tr><tr><td>*</td><td>选择所有的列</td></tr><tr><td>DISTINCT</td><td>禁止重复</td></tr><tr><td>column | expression</td><td>选择指定的字段或表达式</td></tr><tr><td>alias</td><td>给所选择的列不同的标题</td></tr><tr><td>FROM table</td><td>指定包含列的表</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n629' class='md-header-anchor '></a>b）选择所有列和指定列</h4><p>选择所有列：</p><p><img src='./assets/1718062227900.png' alt='1718062227900' referrerPolicy='no-referrer' /></p><p>用跟在 SELECT 关键字后面的星号 (*)，你能够显示表中数据的所有列。</p><p>示例：查询 departments 表中的所有数据。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n634" mdtype="fences">select * from departments;
</pre><p><img src='./assets/1718090967187.png' alt='1718090967187' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>选择指定列：</p><p><img src='./assets/1718062314733.png' alt='1718062314733' referrerPolicy='no-referrer' /></p><p>能够用 SELECT 语句来显示表的指定列，指定列名之间用逗号分隔。</p><p>示例：查询 departments 表中所有部门名称。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n641" mdtype="fences">select department_name from departments;
</pre><p><img src='./assets/1718091022175.png' alt='1718091022175' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n644' class='md-header-anchor '></a>c）查询中的算术表达式</h4><p><img src='./assets/1718062404398.png' alt='1718062404398' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>需要修改数据显示方式，如执行计算，或者作假定推测，这些都可能用到算术表达式。一个算术表达式可以包含列名、固定的数字值和算术运算符。</p><p><img src='./assets/1718062434384.png' alt='1718062434384' referrerPolicy='no-referrer' /></p><p>查询雇员的年薪，并显示他们的雇员ID，名字。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n650" mdtype="fences">select employees_id,last_name, 12*salary from employees;
</pre><p><img src='./assets/1718091251835.png' alt='1718091251835' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>运算符的优先级：</p><p><img src='./assets/1718062530856.png' alt='1718062530856' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>如果算术表达式包含有一个以上的运算，乘法和除法先计算。如果在一个表达式中的运算符优先级相同，计算从左到右进行。可以用圆括号强制其中的表达式先计算。</p><p>&nbsp;</p><p>计算 employees 表中的员工全年薪水加 100 以后的薪水是多少，并显示他们的员工ID与名字。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n659" mdtype="fences">select employees_id,last_name, 12*salary+100 from employees;
</pre><p><img src='./assets/1718091428707.png' alt='1718091428707' referrerPolicy='no-referrer' /></p><p>计算 employees 表中的员工薪水加 100 以后的全年薪水是多少，并显示他们的员工ID与名字。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n662" mdtype="fences">select employees_id,last_name, 12*(salary+100) from employees;
</pre><p><img src='./assets/1718091497320.png' alt='1718091497320' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n665' class='md-header-anchor '></a>d）mysql中定义空值</h4><p><img src='./assets/1718062601469.png' alt='1718062601469' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>如果一行中的某个列缺少数据值，该值被置为 <em>null</em>， 或者说包含一个空。空是一个难以获得的、未分配的、未知的，或不适用的值。空和 0 或者空格不相同。 0 是一个数字，而空格是一个字符。</p><p>&nbsp;</p><p><strong>算术表达式中的空值</strong></p><p><img src='./assets/1718062651998.png' alt='1718062651998' referrerPolicy='no-referrer' /></p><p>计算年薪包含佣金：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n673" mdtype="fences">select 12*salary+commission_pct from employees;
</pre><p><img src='./assets/1718091752101.png' alt='1718091752101' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n676' class='md-header-anchor '></a>e）别名</h4><p><strong>使用列别名：</strong></p><p><img src='./assets/1718062728661.png' alt='1718062728661' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n679" mdtype="fences">SELECT  列名 AS  列别名 FROM  表名 WHERE  条件;
</pre><p>&nbsp;</p><p>查询 employees 表将雇员 last_name 列定义别名为 name:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n682" mdtype="fences">select last_name as name from employees;
select last_name name from employees;
</pre><p><img src='./assets/1718091862641.png' alt='1718091862641' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>使用表别名:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n686" mdtype="fences">SELECT  表别名.列名 FROM  表名 as 表别名 WHERE  条件;
</pre><p>查询 employees 表为表定义别名为emp，将雇员 last_name 列定义别名为 name：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n688" mdtype="fences">select emp.last_name name from employees emp;
</pre><p><img src='./assets/1718091925714.png' alt='1718091925714' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n691' class='md-header-anchor '></a>f）mysql去重复</h4><p><img src='./assets/1718062879993.png' alt='1718062879993' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>去掉相同的行：</p><p><img src='./assets/1718062977996.png' alt='1718062977996' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n696" mdtype="fences">SELECT DISTINCT 列名 FROM 表名;
</pre><p>&nbsp;</p><p>查询 employees 表，显示唯一的部门 ID:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n699" mdtype="fences">select distinct department_id from employees;
</pre><p><img src='./assets/1718092029838.png' alt='1718092029838' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n702' class='md-header-anchor '></a>g）查询中的行选择</h4><p><img src='./assets/1718063129380.png' alt='1718063129380' referrerPolicy='no-referrer' /></p><p>用 WHERE 子句限制从查询返回的行。一个 WHERE 子句包含一个必须满足的条件，WHERE 子句紧跟着 FROM 子句。如果条件是 true，返回满足条件的行。</p><p>在语法中：WHERE 限制查询满足条件的行。<em>condition</em> 由列名、表达式、常数和比较操作组成</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n706" mdtype="fences">SELECT * |  投影列 FROM  表名 WHERE  选择条件;
</pre><p>&nbsp;</p><p>查询 departments 表中部门 ID 为 90 的部门名称与工作地点 ID:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n709" mdtype="fences">select department_name,location_id from departments where department_id =4;
</pre><p><img src='./assets/1718092273016.png' alt='1718092273016' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n712' class='md-header-anchor '></a>h）mysql中的比较条件</h4><p><img src='./assets/1718063227314.png' alt='1718063227314' referrerPolicy='no-referrer' /></p><p>符号 != 也能够表示 不等于条件。</p><p>&nbsp;</p><p>查询 employees 表中员工薪水大于等于 3000 的员工的姓名与薪水：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n717" mdtype="fences">select last_name,salary from employees where salary &gt;= 3000;
</pre><p><img src='./assets/1718092389350.png' alt='1718092389350' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查询 employees 表中员工薪水不等于 5000 的员工的姓名与薪水:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n721" mdtype="fences">select last_name,salary from employees where salary&lt;&gt;5000;
</pre><p><img src='./assets/1718092434767.png' alt='1718092434767' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n724' class='md-header-anchor '></a>i）其它比较条件</h4><p><img src='./assets/1718063310931.png' alt='1718063310931' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>可以用 BETWEEN 范围条件显示基于一个值范围的行。指定的范围包含一个下限和一个上限。</p><p><img src='./assets/1718063351561.png' alt='1718063351561' referrerPolicy='no-referrer' /></p><p>查询 employees 表，薪水在 3000-8000 之间的雇员ID、名字与薪水：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n731" mdtype="fences">select employee_id,last_name,salary from employees where salary between 3000 and 8000;
</pre><p><img src='./assets/1718092549475.png' alt='1718092549475' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>使用IN条件:</p><p><img src='./assets/1718063416740.png' alt='1718063416740' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查询 employees 表，找出薪水是 5000,6000,8000 的雇员ID、名字与薪水:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n739" mdtype="fences">select employee_id,last_name,salary from employees where salary in(5000,6000,8000);
</pre><p><img src='./assets/1718092626732.png' alt='1718092626732' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>使用LIKE条件:</p><p><img src='./assets/1718063469624.png' alt='1718063469624' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查询 employees 中雇员名字第二个字母是 e 的雇员名字:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n746" mdtype="fences">select last_name from employees where last_name like '_e%';
</pre><p><img src='./assets/1718092766591.png' alt='1718092766591' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>使用NULL条件:</p><p><img src='./assets/1718063599313.png' alt='1718063599313' referrerPolicy='no-referrer' /></p><p>NULL 条件，包括 IS NULL 条件和 IS NOT NULL 条件。IS NULL 条件用于空值测试。空值的意思是难以获得的、未指定的、未知的或者不适用的。因此，你不能用 = ，因为 null 不能等于或不等于任何值。</p><p>&nbsp;</p><p>找出 emloyees 表中那些没有佣金的雇员雇员ID、名字与佣金:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n754" mdtype="fences">select employee_id,last_name,commission_pct from employees where commission_pct is null;
</pre><p><img src='./assets/1718092862082.png' alt='1718092862082' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>找出 employees 表中那些有佣金的雇员ID、名字与佣金:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n758" mdtype="fences">select employee_id,last_name,commission_pct from employees where commission_pct is not null;
</pre><p><img src='./assets/1718092903374.png' alt='1718092903374' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n761' class='md-header-anchor '></a>j）逻辑条件</h4><p><img src='./assets/1718063659054.png' alt='1718063659054' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>逻辑条件组合两个比较条件的结果来产生一个基于这些条件的单个的结果，或者逆转一个单个条件的结果。当所有条件的结果为真时，返回行。SQL 的三个逻辑运算符是：</p><ul><li>AND</li><li>OR</li><li>NOT</li></ul><p>可以在 WHERE 子句中用 AND 和 OR 运算符使用多个条件。</p><p>&nbsp;</p><p>查询 employees 表中雇员薪水是 8000 的并且名字中含有e 的雇员名字与薪水：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n775" mdtype="fences">select last_name,salary from employees where salary = 8000 and last_name like '%e%';
</pre><p><img src='./assets/1718093101913.png' alt='1718093101913' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>查询 employees 表中雇员薪水是 8000 的或者名字中含有e 的雇员名字与薪水:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n780" mdtype="fences">select last_name,salary from employees where salary = 8000 or last_name like '%e%';
</pre><p><img src='./assets/1718093135270.png' alt='1718093135270' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查询 employees 表中雇员名字中不包含 u 的雇员的名字:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n784" mdtype="fences">select last_name from employees where last_name not like '%u%';
</pre><p><img src='./assets/1718093185960.png' alt='1718093185960' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n787' class='md-header-anchor '></a>k）优先规则</h4><p><img src='./assets/1718063833797.png' alt='1718063833797' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><img src='./assets/1718063865295.png' alt='1718063865295' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>在图片的例子中，有两个条件：</p><ul><li>第一个条件是 job_id 是 AD_PRES 并且薪水高于 15,000。</li><li>第二个条件是 job_id 是 SA_REP。</li></ul><p>&nbsp;</p><p><img src='./assets/1718063901509.png' alt='1718063901509' referrerPolicy='no-referrer' /></p><p>在图片中的例子有两个条件：</p><ul><li>第一个条件是 job_id 是 AD_PRES 或者 SA_REP 。</li><li>第二个条件是薪水高于$15,000</li></ul><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n808' class='md-header-anchor '></a>l）order by排序</h4><p><img src='./assets/1718064001546.png' alt='1718064001546' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>在一个不明确的查询结果中排序返回的行。ORDER BY 子句用于排序。如果使用了 ORDER BY 子句，它必须位于 SQL 语句的最后。</p><p><strong>SELECT 语句的执行顺序如下：</strong></p><ul><li>FROM 子句</li><li>WHERE 子句</li><li>SELECT 子句</li><li>ORDER BY 子句</li></ul><p>&nbsp;</p><p>查询 employees 表中的所有雇员，显示他们的ID、名字与薪水，并按薪水升序排序：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n824" mdtype="fences">select employee_id,last_name,salary from employees order by salary;
select employee_id,last_name,salary from employees order by salary asc;
</pre><p><img src='./assets/1718093567763.png' alt='1718093567763' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查询 employees 表中的所有雇员，显示他们的ID与名字，并按雇员名字降序排序:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n828" mdtype="fences">select employee_id,last_name from employees order by last_name desc;
</pre><p><img src='./assets/1718093625524.png' alt='1718093625524' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>使用别名排序：</p><p><img src='./assets/1718064121482.png' alt='1718064121482' referrerPolicy='no-referrer' /></p><p>显示雇员ID，名字。计算雇员的年薪，年薪列别名为annsal，并对该列进行升序排序:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n834" mdtype="fences">select employee_id,last_name ,12*salary annsal from employees order by annsal;
</pre><p><img src='./assets/1718093682302.png' alt='1718093682302' referrerPolicy='no-referrer' /></p><p>多列排序：</p><p><img src='./assets/1718064176462.png' alt='1718064176462' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>以升叙排序显示 DEPARTMENT_ID 列，同时以降序排序显示 SALARY 列：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n840" mdtype="fences">select department_id,salary from employees order by department_id asc ,salary desc;
</pre><p><img src='./assets/1718093794664.png' alt='1718093794664' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n843' class='md-header-anchor '></a>m）实操</h4><p>创建一个查询，显示收入超过 12,000 的雇员的名字和薪水。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n845" mdtype="fences">select 
LAST_NAME,SALARY
from employees
WHERE SALARY &gt; 12000;
</pre><p>&nbsp;</p><p>创建一个查询，显示雇员号为 176 的雇员的名字和部门号。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n848" mdtype="fences">SELECT
LAST_NAME,DEPARTMENT_ID
from employees
where EMPLOYEE_ID = 176;
</pre><p>&nbsp;</p><p>显示所有薪水不在 5000 和 12000 之间的雇员的名字和薪水。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n851" mdtype="fences">select
LAST_NAME,SALARY
from employees
where salary not BETWEEN 5000 and 12000;
</pre><p>&nbsp;</p><p>显示所有在部门 20 和 50 中的雇员的名字和部门号，并以名字按字母顺序排序。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n854" mdtype="fences">SELECT last_name, department_id
FROM employees
WHERE department_id IN (20,50)
ORDER BY last_name ASC;
</pre><p>&nbsp;</p><p>列出收入在 5,000 和 12,000 之间，并且在部门 20 或50 工作的雇员的名字和薪水。将列标题分别显示为 Employee 和 Monthly Salary</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n857" mdtype="fences">SELECT
LAST_NAME Employee,SALARY 'Monthly Salary'
FROM employees
WHERE SALARY BETWEEN 5000 and 12000
AND
DEPARTMENT_ID in(20,50);
</pre><p>&nbsp;</p><p>显示所有没有主管经理的雇员的名字和工作岗位。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n860" mdtype="fences">SELECT
LAST_NAME,JOB_ID
FROM employees
WHERE MANAGER_ID is null;
</pre><p>&nbsp;</p><p>显示所有有佣金的雇员的名字、薪水和佣金。以薪水和佣金的降序排序数据。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n863" mdtype="fences">SELECT
LAST_NAME,SALARY,COMMISSION_PCT
from employees
where COMMISSION_PCT is not NULL
ORDER BY SALARY DESC , COMMISSION_PCT desc;
</pre><p>&nbsp;</p><p>显示所有名字中有一个 a 和一个 e 的雇员的名字。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n866" mdtype="fences">SELECT
LAST_NAME
from employees
where LAST_NAME LIKE '%a%'
AND
LAST_NAME LIKE '%e%';
</pre><p>&nbsp;</p><p>显示所有工作岗位是销售代表（SA_REP）或者普通职员(ST_CLERK)，并且薪水不等于 2,500、3,500 或 7,000 的雇员的名字、工作岗位和薪水。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n869" mdtype="fences">SELECT
LAST_NAME,JOB_ID,SALARY
from employees
WHERE
JOB_ID in('SA_REP','ST_CLERK')
AND
SALARY not IN(2500,3500,7000)
</pre><p>&nbsp;</p><h3><a name='header-n871' class='md-header-anchor '></a>8，sql中的函数</h3><p>把函数当成别人封装好的功能块，你去调用这个函数，就可以实现某个功能。参考：</p><p><a href='https://blog.csdn.net/weixin_55076626/article/details/127341913' target='_blank' class='url'>https://blog.csdn.net/weixin_55076626/article/details/127341913</a></p><p>&nbsp;</p><p><img src='./assets/1718064492868.png' alt='1718064492868' referrerPolicy='no-referrer' /></p><p>函数是 SQL 的一个非常强有力的特性，函数能够用于下面的目的：</p><ul><li>执行数据计算</li><li>修改单个数据项</li><li>操纵输出进行行分组</li><li>格式化显示的日期和数字</li><li>转换列数据类型</li></ul><p>&nbsp;</p><p>SQL 函数有输入参数，并且总有一个返回值。函数分类：</p><p><img src='./assets/1718064568547.png' alt='1718064568547' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><ol start='' ><li><p>单行函数：单行函数仅对单个行进行运算，并且每行返回一个结果。</p><p>常见的函数类型：</p><ul><li>字符</li><li>数字</li><li>日期</li><li>转换</li></ul></li><li><p>多行函数：多行函数能够操纵成组的行，每个行组给出一个结果，这些函数也被称为组函数。</p></li></ol><p>&nbsp;</p><h4><a name='header-n908' class='md-header-anchor '></a>a）单行函数</h4><p><img src='./assets/1718064677329.png' alt='1718064677329' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>单行函数分类：</strong></p><p><img src='./assets/1718064728223.png' alt='1718064728223' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n914' class='md-header-anchor '></a>b）字符函数</h4><p><strong>大小写处理函数：</strong></p><figure><table><thead><tr><th><strong>函数</strong></th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>LOWER(s)|LCASE(s)</td><td>将字符串 s 转换为小写</td><td>将字符串 OLDLU转换为小写：<code>SELECT LOWER(&quot;OLDLU&quot;); -- oldlu</code></td></tr><tr><td>UPPER(s)|UCASE(s)</td><td>将字符串s转换为大写</td><td>将字符串 oldlu转换为大写：<code>SELECT UPPER(&quot;oldlu&quot;); -- OLDLU</code></td></tr></tbody></table></figure><p>&nbsp;</p><p>显示雇员 Davies 的雇员号、姓名和部门号，将姓名转换为大写。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n931" mdtype="fences">select employee_id,UPPER(last_name),department_id from employees where last_name = 'davies';
</pre><p>&nbsp;</p><p><strong>字符处理函数:</strong></p><figure><table><thead><tr><th>函数</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>LENGTH(s)</td><td>返回字符串 s 的长度</td><td>返回字符串oldlu的字符数<code>SELECT LENGTH(&quot;oldlu&quot;); --5;</code></td></tr><tr><td>CONCAT(s1,s2...sn)</td><td>字符串 s1,s2 等多个字符串合并为一个字符串</td><td>合并多个字符串<code>SELECT CONCAT(&quot;sxt &quot;, &quot;teacher &quot;, &quot;oldlu&quot;); --sxt teacher oldlu;</code></td></tr><tr><td>LPAD(s1,len,s2)</td><td>在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len</td><td>将字符串 x 填充到 oldlu字符串的开始处：<code>SELECT LPAD(&#39;oldlu&#39;,8,&#39;x&#39;); -- xxxoldlu</code></td></tr><tr><td>LTRIM(s)</td><td>去掉字符串 s 开始处的空格</td><td>去掉字符串 oldlu开始处的空格：<code>SELECT LTRIM(&quot; oldlu&quot;) ;-- oldlu</code></td></tr><tr><td>REPLACE(s,s1,s2)</td><td>将字符串 s2 替代字符串 s 中的字符串 s1</td><td>将字符串 oldlu 中的字符 o 替换为字符 O：<code>SELECT REPLACE(&#39;oldlu&#39;,&#39;o&#39;,&#39;O&#39;); --Oldlu</code></td></tr><tr><td>REVERSE(s)</td><td>将字符串s的顺序反过来</td><td>将字符串 abc 的顺序反过来：<code>SELECT REVERSE(&#39;abc&#39;); -- cba</code></td></tr><tr><td>RPAD(s1,len,s2)</td><td>在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len</td><td>将字符串 xx填充到 oldlu字符串的结尾处：<code>SELECT RPAD(&#39;oldlu&#39;,8,&#39;x&#39;); -- oldluxxx</code></td></tr><tr><td>RTRIM(s)</td><td>去掉字符串 s 结尾处的空格</td><td>去掉字符串 oldlu 的末尾空格：<code>SELECT RTRIM(&quot;oldlu &quot;); -- oldlu</code></td></tr><tr><td>SUBSTR(s, start, length)</td><td>从字符串 s 的 start 位置截取长度为 length 的子字符串</td><td>从字符串 OLDLU中的第 2 个位置截取 3个 字符：<code>SELECT SUBSTR(&quot;OLDLU&quot;, 2, 3); -- LDL</code></td></tr><tr><td>SUBSTRING(s, start, length)</td><td>从字符串 s 的 start 位置截取长度为 length 的子字符串</td><td>从字符串 OLDLU中的第 2 个位置截取 3个 字符：<code>SELECT SUBSTRING(&quot;OLDLU&quot;, 2, 3); --LDL</code></td></tr><tr><td>TRIM(s)</td><td>去掉字符串 s 开始和结尾处的空格</td><td>去掉字符串 oldlu 的首尾空格：<code>SELECT TRIM(&#39; oldlu &#39;);--oldlu</code></td></tr></tbody></table></figure><p>&nbsp;</p><p>显示所有工作岗位名称从第 4 个字符位置开始，包含字符串 REP的雇员的ID信息，将雇员的姓和名连接显示在一起，还显示雇员名的的长度，以及名字中字母 a 的位置。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n985" mdtype="fences">SELECT employee_id, CONCAT(last_name，first_name) NAME, 
job_id, LENGTH(last_name),INSTR(last_name, 'a') "Contains 'a'?" FROM employees WHERE SUBSTR(job_id, 4) = 'REP';
</pre><p>&nbsp;</p><h4><a name='header-n987' class='md-header-anchor '></a>c）数学函数</h4><figure><table><thead><tr><th>函数名</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回 x 的绝对值</td><td>返回 -1 的绝对值：<code>SELECT ABS(-1) -- 返回1</code></td></tr><tr><td>ACOS(x)</td><td>求 x 的反余弦值(参数是弧度)</td><td><code>SELECT ACOS(0.25);</code></td></tr><tr><td>ASIN(x)</td><td>求反正弦值(参数是弧度)</td><td><code>SELECT ASIN(0.25);</code></td></tr><tr><td>ATAN(x)</td><td>求反正切值(参数是弧度)</td><td><code>SELECT ATAN(2.5);</code></td></tr><tr><td>ATAN2(n, m)</td><td>求反正切值(参数是弧度)</td><td><code>SELECT ATAN2(-0.8, 2);</code></td></tr><tr><td>AVG(expression)</td><td>返回一个表达式的平均值，expression 是一个字段</td><td>返回 Products 表中Price 字段的平均值：<code>SELECT AVG(Price) AS AveragePrice FROM Products;</code></td></tr><tr><td>CEIL(x)</td><td>返回大于或等于 x 的最小整数</td><td><code>SELECT CEIL(1.5) -- 返回2</code></td></tr><tr><td>CEILING(x)</td><td>返回大于或等于 x 的最小整数</td><td><code>SELECT CEILING(1.5); -- 返回2</code></td></tr><tr><td>COS(x)</td><td>求余弦值(参数是弧度)</td><td><code>SELECT COS(2);</code></td></tr><tr><td>COT(x)</td><td>求余切值(参数是弧度)</td><td><code>SELECT COT(6);</code></td></tr><tr><td>COUNT(expression)</td><td>返回查询的记录总数，expression 参数是一个字段或者 * 号</td><td>返回 Products 表中 products 字段总共有多少条记录：<code>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</code></td></tr><tr><td>DEGREES(x)</td><td>将弧度转换为角度</td><td><code>SELECT DEGREES(3.1415926535898) -- 180</code></td></tr><tr><td>n DIV m</td><td>整除，n 为被除数，m 为除数</td><td>计算 10 除于 5：<code>SELECT 10 DIV 5; -- 2</code></td></tr><tr><td>EXP(x)</td><td>返回 e 的 x 次方</td><td>计算 e 的三次方：<code>SELECT EXP(3) -- 20.085536923188</code></td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于 x 的最大整数</td><td>小于或等于 1.5 的整数：<code>SELECT FLOOR(1.5) -- 返回1</code></td></tr><tr><td>GREATEST(expr1, expr2, expr3, ...)</td><td>返回列表中的最大值</td><td>返回以下数字列表中的最大值：<code>SELECT GREATEST(3, 12, 34, 8, 25); -- 34</code>返回以下字符串列表中的最大值：<code>SELECT GREATEST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Runoob</code></td></tr><tr><td>LEAST(expr1, expr2, expr3, ...)</td><td>返回列表中的最小值</td><td>返回以下数字列表中的最小值：<code>SELECT LEAST(3, 12, 34, 8, 25); -- 3</code>返回以下字符串列表中的最小值：<code>SELECT LEAST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Apple</code></td></tr><tr><td>LN</td><td>返回数字的自然对数，以 e 为底。</td><td>返回 2 的自然对数：<code>SELECT LN(2); -- 0.6931471805599453</code></td></tr><tr><td>LOG(x) 或 LOG(base, x)</td><td>返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。</td><td><code>SELECT LOG(20.085536923188) -- 3 SELECT LOG(2, 4); -- 2</code></td></tr><tr><td>LOG10(x)</td><td>返回以 10 为底的对数</td><td><code>SELECT LOG10(100) -- 2</code></td></tr><tr><td>LOG2(x)</td><td>返回以 2 为底的对数</td><td>返回以 2 为底 6 的对数：<code>SELECT LOG2(6); -- 2.584962500721156</code></td></tr><tr><td>MAX(expression)</td><td>返回字段 expression 中的最大值</td><td>返回数据表 Products 中字段 Price 的最大值：<code>SELECT MAX(Price) AS LargestPrice FROM Products;</code></td></tr><tr><td>MIN(expression)</td><td>返回字段 expression 中的最小值</td><td>返回数据表 Products 中字段 Price 的最小值：<code>SELECT MIN(Price) AS MinPrice FROM Products;</code></td></tr><tr><td>MOD(x,y)</td><td>返回 x 除以 y 以后的余数</td><td>5 除于 2 的余数：<code>SELECT MOD(5,2) -- 1</code></td></tr><tr><td>PI()</td><td>返回圆周率(3.141593）</td><td><code>SELECT PI() --3.141593</code></td></tr><tr><td>POW(x,y)</td><td>返回 x 的 y 次方</td><td>2 的 3 次方：<code>SELECT POW(2,3) -- 8</code></td></tr><tr><td>POWER(x,y)</td><td>返回 x 的 y 次方</td><td>2 的 3 次方：<code>SELECT POWER(2,3) -- 8</code></td></tr><tr><td>RADIANS(x)</td><td>将角度转换为弧度</td><td>180 度转换为弧度：<code>SELECT RADIANS(180) -- 3.1415926535898</code></td></tr><tr><td>RAND()</td><td>返回 0 到 1 的随机数</td><td><code>SELECT RAND() --0.93099315644334</code></td></tr><tr><td>ROUND(x)</td><td>返回离 x 最近的整数</td><td><code>SELECT ROUND(1.23456) --1</code></td></tr><tr><td>SIGN(x)</td><td>返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1</td><td><code>SELECT SIGN(-10) -- (-1)</code></td></tr><tr><td>SIN(x)</td><td>求正弦值(参数是弧度)</td><td><code>SELECT SIN(RADIANS(30)) -- 0.5</code></td></tr><tr><td>SQRT(x)</td><td>返回x的平方根</td><td>25 的平方根：<code>SELECT SQRT(25) -- 5</code></td></tr><tr><td>SUM(expression)</td><td>返回指定字段的总和</td><td>计算 OrderDetails 表中字段 Quantity 的总和：<code>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</code></td></tr><tr><td>TAN(x)</td><td>求正切值(参数是弧度)</td><td><code>SELECT TAN(1.75); -- -5.52037992250933</code></td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）</td><td><code>SELECT TRUNCATE(1.23456,3) -- 1.234</code></td></tr></tbody></table></figure><p>&nbsp;</p><p>ROUND 函数四舍五入列、表达式或者 n 位小数的值。如果第二个参数是 0 或者缺少，值被四舍五入为整数。如果第二个参数是 2值被四舍五入为两位小数。如果第二个参数是–2，值被四舍五入到小数点左边两位。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1139" mdtype="fences">SELECT ROUND(45.923,2), ROUND(45.923,0),ROUND(45.923,-1);
</pre><p>&nbsp;</p><p>TRUNCATE函数的作用类似于 ROUND 函数。如果第二个参数是 0 或者缺少，值被截断为整数。如果第二个参数是 2，值被截断为两位小数。如果第二个参数是–2，值被截断到小数点左边两位。与 ROUND 最大的区别是不会进行四舍五入。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1142" mdtype="fences">SELECT TRUNCATE(45.923,2);
</pre><p>&nbsp;</p><p>MOD 函数找出m 除以n的余数。所有job_id是SA_REP的雇员的名字，薪水以及薪水被5000除后的余数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1145" mdtype="fences">SELECT last_name, salary, MOD(salary, 5000) FROM employees
WHERE job_id = 'SA_REP';
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1148' class='md-header-anchor '></a>d）日期函数</h4><p>在MySQL中允许直接使用字符串表示日期，但是要求字符串的日期格式必须为：‘YYYY-MM-DD HH:MI:SS’ 或者‘YYYY/MM/DD HH:MI:SS’;</p><figure><table><thead><tr><th>函数名</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td><td><code>SELECT CURDATE(); -&gt; 2018-09-19</code></td></tr><tr><td>CURTIME()</td><td>返回当前时间</td><td><code>SELECT CURTIME(); -&gt; 19:59:02</code></td></tr><tr><td>CURRENT_DATE()</td><td>返回当前日期</td><td><code>SELECT CURRENT_DATE(); -&gt; 2018-09-19</code></td></tr><tr><td>CURRENT_TIME()</td><td>返回当前时间</td><td><code>SELECT CURRENT_TIME(); -&gt; 19:59:02</code></td></tr><tr><td>DATE()</td><td>从日期或日期时间表达式中提取日期值</td><td><code>SELECT DATE(&quot;2017-06-15&quot;); -&gt; 2017-06-15</code></td></tr><tr><td>DATEDIFF(d1,d2)</td><td>计算日期 d1-&gt;d2 之间相隔的天数</td><td><code>SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;) -&gt; -32</code></td></tr><tr><td>DAY(d)</td><td>返回日期值 d 的日期部分</td><td><code>SELECT DAY(&quot;2017-06-15&quot;); -&gt; 15</code></td></tr><tr><td>DAYNAME(d)</td><td>返回日期 d 是星期几，如 Monday,Tuesday</td><td><code>SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;) -&gt;Friday</code></td></tr><tr><td>DAYOFMONTH(d)</td><td>计算日期 d 是本月的第几天</td><td><code>SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11</code></td></tr><tr><td>DAYOFWEEK(d)</td><td>日期 d 今天是星期几，1 星期日，2 星期一，以此类推</td><td><code>SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;) -&gt;6</code></td></tr><tr><td>DAYOFYEAR(d)</td><td>计算日期 d 是本年的第几天</td><td><code>SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt;315</code></td></tr><tr><td>HOUR(t)</td><td>返回 t 中的小时值</td><td><code>SELECT HOUR(&#39;1:2:3&#39;) -&gt; 1</code></td></tr><tr><td>LAST_DAY(d)</td><td>返回给给定日期的那一月份的最后一天</td><td><code>SELECT LAST_DAY(&quot;2017-06-20&quot;); -&gt; 2017-06-30</code></td></tr><tr><td>MONTHNAME(d)</td><td>返回日期当中的月份名称，如 November</td><td><code>SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;) -&gt; November</code></td></tr><tr><td>MONTH(d)</td><td>返回日期d中的月份值，1 到 12</td><td><code>SELECT MONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11</code></td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td><td><code>SELECT NOW() -&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>SECOND(t)</td><td>返回 t 中的秒钟值</td><td><code>SELECT SECOND(&#39;1:2:3&#39;) -&gt; 3</code></td></tr><tr><td>SYSDATE()</td><td>返回当前日期和时间</td><td><code>SELECT SYSDATE() -&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>计算时间差值</td><td><code>SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;); -&gt; 00:00:01</code></td></tr><tr><td>TO_DAYS(d)</td><td>计算日期 d 距离 0000 年 1 月 1 日的天数</td><td><code>SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;) -&gt; 366</code></td></tr><tr><td>WEEK(d)</td><td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td><td><code>SELECT WEEK(&#39;2011-11-11 11:11:11&#39;) -&gt; 45</code></td></tr><tr><td>WEEKDAY(d)</td><td>日期 d 是星期几，0 表示星期一，1 表示星期二</td><td><code>SELECT WEEKDAY(&quot;2017-06-15&quot;); -&gt; 3</code></td></tr><tr><td>WEEKOFYEAR(d)</td><td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td><td><code>SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt; 45</code></td></tr><tr><td>YEAR(d)</td><td>返回年份</td><td><code>SELECT YEAR(&quot;2017-06-15&quot;); -&gt; 2017</code></td></tr></tbody></table></figure><p>&nbsp;</p><p>向 employees 表中添加一条数据，雇员ID：300，名字：kevin ，email：<a href='mailto:mailto:kevin@qq.com' target='_blank' class='url'>mailto:kevin@qq.com</a>，入职时间：2049-5-1 8:30:30，工作部门：‘IT_PROG’。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1253" mdtype="fences">insert into employees(EMPLOYEE_ID,last_name,email,HIRE_DATE,JOB_ID) values(300,'kevin','kevin@qq.com','2049-5-1 8:30:30','IT_PROG');
</pre><p>&nbsp;</p><h4><a name='header-n1255' class='md-header-anchor '></a>e）转换函数</h4><p><strong>隐式数据类型转换</strong></p><p>隐式数据类型转换是指MySQL服务器能够自动地进行类型转换。如：可以将标准格式的字串日期自动转换为日期类型。</p><p>MySQL字符串日期格式为：‘YYYY-MM-DD HH:MI:SS’ 或 ‘YYYY/MM/DD HH:MI:SS’;</p><p>&nbsp;</p><p><strong>显示数据类型转换</strong></p><p>显示数据类型转换是指需要依赖转换函数来完成相关类型的转换。</p><p>如：</p><ul><li>DATE_FORMAT(date,format) 将日期转换成字符串;</li><li>STR_TO_DATE(str,format) 将字符串转换成日期;</li></ul><p>&nbsp;</p><p>向 employees 表中添加一条数据，雇员ID：400，名字：malu，email：<a href='mailto:123@qq.com' target='_blank' class='url'>123@qq.com</a> ，入职时间：2049 年 5 月 5 日，工作部门：‘IT_PROG’。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1270" mdtype="fences">insert into employees(EMPLOYEE_ID,last_name,email,HIRE_DATE,JOB_ID) values(400,'malu','123@qq.com ', STR_TO_DATE('2049 年 5 月 5 日','%Y 年%m 月%d 日'),'IT_PROG');
</pre><p>&nbsp;</p><p>查询 employees 表中雇员名字为 King 的雇员的入职日期，要求显示格式为 yyyy 年 MM 月 dd 日。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1273" mdtype="fences">select DATE_FORMAT(hire_date,'%Y 年%m 月%d 日') from employees where last_name = 'King';
</pre><p>&nbsp;</p><h4><a name='header-n1275' class='md-header-anchor '></a>f）通用函数</h4><figure><table><thead><tr><th>函数名</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>IF(expr,v1,v2)</td><td>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</td><td><code>SELECT IF(1 &gt; 0,&#39;正确&#39;,&#39;错误&#39;) -&gt;正确</code></td></tr><tr><td>IFNULL(v1,v2)</td><td>如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。</td><td><code>SELECT IFNULL(null,&#39;Hello Word&#39;) -&gt;Hello Word</code></td></tr><tr><td>ISNULL(expression)</td><td>判断表达式是否为 NULL</td><td><code>SELECT ISNULL(NULL); -&gt;1</code></td></tr><tr><td>NULLIF(expr1, expr2)</td><td>比较两个参数是否相同，如果参数 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</td><td><code>SELECT NULLIF(25, 25); -&gt;</code></td></tr><tr><td>COALESCE(expr1, expr2, ...., expr_n)</td><td>返回参数中的第一个非空表达式（从左向右）</td><td><code>SELECT COALESCE(NULL, NULL, NULL, &#39;bjsxt.com&#39;, NULL, &#39;google.com&#39;); -&gt; bjsxt.com</code></td></tr><tr><td><code>CASE expression WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... WHEN conditionN THEN resultN ELSE result END</code></td><td>CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。</td><td><code>SELECT CASE &#39;oldlu&#39; WHEN &#39;oldlu&#39; THEN &#39;OLDLU&#39; WHEN &#39;admin&#39; THEN &#39;ADMIN&#39; ELSE &#39;kevin&#39; END;</code></td></tr></tbody></table></figure><p>&nbsp;</p><p>查询部门编号是50或者80的员工信息，包含他们的名字、薪水、佣金。在income列中，如果有佣金则显示‘SAL+COMM’，无佣金则显示&#39;SAL&#39;。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1307" mdtype="fences">SELECT last_name, salary, commission_pct,   if(ISNULL(commission_pct),
'SAL','SAL+COMM') income 
FROM employees 
WHERE department_id IN (50, 80);
</pre><p>&nbsp;</p><p>计算雇员的年报酬，你需要用 12 乘以月薪，再加上它的佣金 (等于年薪乘以佣金百分比)。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1310" mdtype="fences">SELECT last_name, salary, IFNULL(commission_pct, 0), (salary*12) +(salary*12*IFNULL(commission_pct, 0)) AN_SAL 
FROM employees;
</pre><p>&nbsp;</p><p>查询员工表，显示他们的名字、名字的长度该列名为expr1，姓氏、姓氏的长度该列名为expr2。在result列中，如果名字与姓氏的长度相同则显示空，如果不相同则显示名字长度。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1313" mdtype="fences">SELECT first_name, LENGTH(first_name) "expr1",
    last_name, LENGTH(last_name) "expr2",    NULLIF(LENGTH(first_name), LENGTH(last_name)) result
FROM employees;
</pre><p>&nbsp;</p><p>查询员工表，显示他们的名字，如果 COMMISSION_PCT 值是非空，显示它。如果COMMISSION_PCT 值是空，则显示 SALARY 。如果 COMMISSION_PCT 和SALARY 值都是空，那么显示 10。在结果中对佣金列升序排序。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1316" mdtype="fences">SELECT last_name,
COALESCE(commission_pct, salary, 10) comm 
FROM employees 
ORDER BY commission_pct;
</pre><p>&nbsp;</p><p>查询员工表，如果 JOB_ID 是 IT_PROG，薪水增加 10%；如果 JOB_ID 是 ST_CLERK，薪水增加 15%；如果 JOB_ID 是 SA_REP，薪水增加 20%。对于所有其他的工作角色，不增加薪水。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1319" mdtype="fences">SELECT last_name, job_id, salary, 
    CASE job_id WHEN 'IT_PROG' THEN 1.10*salary 
          WHEN 'ST_CLERK' THEN 1.15*salary 
          WHEN 'SA_REP' THEN 1.20*salary 
    ELSE salary END "REVISED_SALARY"
FROM employees;
</pre><p>&nbsp;</p><h4><a name='header-n1321' class='md-header-anchor '></a>g）实操</h4><p>显示受雇日期在 1998 年 2 月 20 日 和 2005 年 5 月 1 日 之间的雇员的名字、岗位和受雇日期。按受雇日期顺序排序查询结果。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1323" mdtype="fences">SELECT
LAST_NAME,JOB_ID,HIRE_DATE
FROM employees
WHERE HIRE_DATE BETWEEN '1998-2-20' AND '2005-5-1'
order by HIRE_DATE;
</pre><p>&nbsp;</p><p>显示每一个在 2002 年受雇的雇员的名字和受雇日期。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1326" mdtype="fences">select 
LAST_NAME,HIRE_DATE
FROM employees
where HIRE_DATE like '2002%'
</pre><p>对每一个雇员，显示 employee number、last_name、salary 和 salary 增加 15%，并且表示成整数，列标签显示为 New Salary。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1328" mdtype="fences">SELECT
EMPLOYEE_ID,LAST_NAME,SALARY,
ROUND(SALARY *1.15,0)
FROM employees
</pre><p>写一个查询，显示名字的长度，对所有名字开始字母是 J、A 或 M 的雇员。用雇员的 lastname排序结果。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1330" mdtype="fences">SELECT
LAST_NAME,
LENGTH(LAST_NAME)
FROM employees
WHERE LAST_NAME LIKE 'J%'
OR
LAST_NAME LIKE 'A%'
OR
LAST_NAME LIKE 'M%'
ORDER BY LAST_NAME;
</pre><p>创建一个查询显示所有雇员的 last name 和 salary。将薪水格式化为 15 个字符长度，用 $左填充 。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1332" mdtype="fences">SELECT
LAST_NAME,LPAD(SALARY,15,'$')
FROM employees;
</pre><p>&nbsp;</p><p>创建一个查询显示雇员的 last names 和 commission (佣金) 比率。如果雇员没有佣金，显示 “No Commission”，列标签 COMM。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1335" mdtype="fences">SELECT
LAST_NAME,IFNULL(COMMISSION_PCT,'No Commission') COMM
FROM employees
</pre><p>写一个查询，按照下面的数据显示所有雇员的基于 JOB_ID 列值的级别。</p><figure><table><thead><tr><th><strong>工作</strong></th><th><strong>级别</strong></th></tr></thead><tbody><tr><td>AD_PRES</td><td>A</td></tr><tr><td>ST_MAN</td><td>B</td></tr><tr><td>IT_PROG</td><td>C</td></tr><tr><td>SA_REP</td><td>D</td></tr><tr><td>ST_CLERK</td><td>E</td></tr><tr><td>不在上面的</td><td>0</td></tr></tbody></table></figure><p>&nbsp;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1360" mdtype="fences">SELECT JOB_ID, 
  CASE JOB_ID WHEN 'AD_PRES' THEN 'A'
        WHEN 'ST_MAN' THEN 'B'
          WHEN 'IT_PROG' THEN 'C'
          WHEN 'SA_REP' THEN 'D'
        WHEN 'ST_CLERK' THEN 'E'
  ELSE 0 END 
FROM employees;
</pre><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n1363' class='md-header-anchor '></a>9，多表查询（非常重要）</h3><p>&nbsp;</p><p>补充一个概念：外键约束</p><p>&nbsp;</p><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。如何理解上面的概念呢？如下图有两张表，员工表和部门表：</p><p><img src='./assets/1718161419162.png' alt='1718161419162' referrerPolicy='no-referrer' /></p><p>员工表中的dep_id字段是部门表的id字段关联，也就是说1号学生张三属于1号部门研发部的员工。现在我要删除1号部门，就会出现错误的数据（员工表中属于1号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的1号部门的数据将无法删除。</p><p>&nbsp;</p><p>添加外键约束语法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1372" mdtype="fences">-- 创建表时添加外键约束
CREATE TABLE 表名(
   列名 数据类型,
   …
   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) 
); 

-- 建完表后添加外键约束
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);
</pre><p>&nbsp;</p><p>删除外键约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1375" mdtype="fences">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
</pre><p>&nbsp;</p><p>据上述语法创建员工表和部门表，并添加上外键约束：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1378" mdtype="fences" style="break-inside: unset;">-- 删除表
DROP TABLE IF EXISTS emp;
DROP TABLE IF EXISTS dept;

-- 部门表
CREATE TABLE dept(
	id INT PRIMARY KEY AUTO_INCREMENT,
	dep_name VARCHAR(20),
	addr VARCHAR(20)
);
-- 员工表 
CREATE TABLE emp(
	id INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	age INT,
	dep_id INT,

	-- 添加外键 dep_id,关联 dept 表的id主键
	CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id)	
);
</pre><p>&nbsp;</p><p>创建好了两张表：</p><p><img src='./assets/1718162106935.png' alt='1718162106935' referrerPolicy='no-referrer' /></p><p>结构：</p><p><img src='./assets/1718162118729.png' alt='1718162118729' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>添加数据：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1386" mdtype="fences">-- 添加 2 个部门
insert into dept(dep_name,addr) values
('研发部','广州'),('销售部', '深圳');

-- 添加员工,dep_id 表示员工所在的部门
INSERT INTO emp (NAME, age, dep_id) VALUES 
('张三', 20, 1),
('李四', 20, 1),
('王五', 20, 1),
('赵六', 20, 2),
('孙七', 22, 2),
('周八', 18, 2);
</pre><p><img src='./assets/1718162195249.png' alt='1718162195249' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p><p><img src='./assets/1718162330776.png' alt='1718162330776' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>删除外键：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1393" mdtype="fences">alter table emp drop FOREIGN key fk_emp_dept;
</pre><p><img src='./assets/1718162435775.png' alt='1718162435775' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>此时，就可以删除研发部了。</p><p>&nbsp;</p><p>重新添加外键：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1399" mdtype="fences">alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1402' class='md-header-anchor '></a>a）多表查询介绍</h4><p><img src='./assets/1718065727561.png' alt='1718065727561' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>笛卡尔乘积：</strong></p><p><img src='./assets/1718065777530.png' alt='1718065777530' referrerPolicy='no-referrer' /></p><p>笛卡尔乘积 ：</p><p>当一个连接条件无效或被遗漏时，其结果是一个笛卡尔乘积 (<em>Cartesian product</em>)，其中所有行的组合都被显示。第一个表中的所有行连接到第二个表中的所有行。一个笛卡尔乘积会产生大量的行，其结果没有什么用。你应该在 WHERE 子句中始终包含一个有效的连接条件，除非你有特殊的需求，需要从所有表中组合所有的行。</p><p><img src='./assets/1718065866775.png' alt='1718065866775' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1412' class='md-header-anchor '></a>b）等值连接</h4><p><img src='./assets/1718066049985.png' alt='1718066049985' referrerPolicy='no-referrer' /></p><p><strong>等值连接</strong></p><p>为了确定一个雇员的部门名，需要比较 EMPLOYEES 表中的 DEPARTMENT_ID 列与DEPARTMENTS 表中的 DEPARTMENT_ID 列的值。在 EMPLOYEES 和DEPARTMENTS 表之间的关系是一个相等 (<em>equijoin</em>) 关系，即，两 个 表 中DEPARTMENT_ID 列的值必须相等。</p><p>&nbsp;</p><p><strong>等值连接特点：</strong>等值连接也被称为简单连接 (<em>simple joins</em>) 或内连接 (<em>inner joins</em>)。</p><ol start='' ><li>多表等值连接的结果为多表的交集部分；</li><li>n表连接，至少需要n-1个连接条件；</li><li>多表不分主次，没有顺序要求；</li><li>一般为表起别名，提高阅读性和性能；</li><li>可以搭配排序、分组、筛选….等子句使用；</li></ol><p>&nbsp;</p><p><strong>等值连接的使用：</strong></p><p><img src='./assets/1718066268831.png' alt='1718066268831' referrerPolicy='no-referrer' /></p><p>SELECT 子句指定要返回的列名：</p><ul><li>employee last name、employee number 和 department number，这些是EMPLOYEES 表中的列</li><li>department number、department name 和 location ID，这些是 DEPARTMENTS 表中的列</li></ul><p>&nbsp;</p><p>FROM 子句指定数据库必须访问的两个表：</p><ul><li>EMPLOYEES 表</li><li>DEPARTMENTS 表</li></ul><p>&nbsp;</p><p>WHERE 子句指定表怎样被连接：</p><ul><li>EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID，因为 DEPARTMENT_ID 列是两个表的同名列，它必须用表名做前缀以避免混淆。</li></ul><p>&nbsp;</p><p>增加搜索条件：</p><p><img src='./assets/1718066863027.png' alt='1718066863027' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>添加查询条件:</strong></p><p>除连接之外，可能还要求用 WHERE 子句在连接中限制一个或多个表中的行。</p><p>&nbsp;</p><p><strong>限制不能缺的列：</strong></p><p><img src='./assets/1718066908732.png' alt='1718066908732' referrerPolicy='no-referrer' /></p><p><strong>限制不明确的列名：</strong></p><ul><li>需要在 WHERE 子句中用表的名字限制列的名字以避免含糊不清。没有表前缀，DEPARTMENT_ID 列可能来自 DEPARTMENTS 表，也可能来自 EMPLOYEES 表，这种情况下需要添加表前缀来执行查询。</li><li>如果列名在两个表之间不相同，就不需要限定列。但是，使用表前缀可以改善性能，因为MySQL服务器可以根据表前缀找到对应的列。</li><li>必须限定不明确的列名也适用于在其它子句中可能引起混淆的那些列，例如 SELECT子句或 ORDER BY 子句。</li></ul><p>&nbsp;</p><p><strong>使用表别名：</strong></p><p><img src='./assets/1718066993053.png' alt='1718066993053' referrerPolicy='no-referrer' /></p><p><strong>表别名定义原则：</strong></p><ul><li>表别名不易过长，短一些更好。</li><li>表别名应该是有意义的。</li><li>表别名只对当前的 SELECT 语句有效。</li></ul><p>&nbsp;</p><p><strong>多表连接：</strong></p><p><img src='./assets/1718067146446.png' alt='1718067146446' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>查询雇员 King 所在的部门名称。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1483" mdtype="fences">select d.department_name from employees e,departments d  where e.dept_id = d.department_id and e.last_name = 'King';
</pre><p>&nbsp;</p><p>显示每个雇员的 last name、departmentname 和 city。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1486" mdtype="fences">SELECT e.last_name, d.department_name, l.city 
FROM employees e, departments d, locations l 
WHERE e.department_id = d.department_id 
AND d.location_id = l.location_id;
</pre><p>&nbsp;</p><h4><a name='header-n1488' class='md-header-anchor '></a>c）非等值连接</h4><p><img src='./assets/1718151601118.png' alt='1718151601118' referrerPolicy='no-referrer' /></p><p><strong>非等值连接</strong></p><p>一个非等值连接是一种不同于等值操作的连接条件。 EMPLOYEES 表 和JOB_GRADES A 表之间的关系有一个非等值连接例子。在两个表之间的关系是EMPLOYEES 表中的 SALARY 列必须是 JOB_GRADES 表的 LOWEST_SALARY 和HIGHEST_SALARY 列之间的值。使用不同于等于 (=) 的操作符获得关系。</p><p><img src='./assets/1718151675785.png' alt='1718151675785' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>创建 job_grades 表，包含 lowest_sal ，highest_sal ，grade_level。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1495" mdtype="fences">create table job_grades(lowest_sal int,highest_sal int ,grade_level varchar(30));
</pre><p>&nbsp;</p><p>插入数据 1000 2999 A 2000 4999 B 5000 7999 C 8000 12000 D</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1498" mdtype="fences">insert into job_grades values(1000,2999,'A');
insert into job_grades values(2000,4999,'B');
insert into job_grades values(5000,7999,'C');
insert into job_grades values(8000,12000,'D');
</pre><p>&nbsp;</p><p>查询所有雇员的薪水级别。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1501" mdtype="fences">select e.last_name,j.grade_level from employees e ,job_grades j where e.salary between j.lowest_sal and j.highest_sal;
</pre><p>&nbsp;</p><h4><a name='header-n1503' class='md-header-anchor '></a>d）自连接</h4><p><img src='./assets/1718151895540.png' alt='1718151895540' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>自连接</strong></p><p>连接一个表到它自己。有时需要连接一个表到它自己。为了找到每个雇员的经理的名字，则需要连接EMPLOYEES 表到它自己，或执行一个自连接。</p><p><img src='./assets/1718151933662.png' alt='1718151933662' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>图片中的例子连接 EMPLOYEES 表到它自己。为了在 FROM 子句中模拟两个表，对于相同的表 EMPLOYEES，用两个别名，分别为 worker 和 manager。在该例中，WHERE 子句包含的连接意味着 “一个工人的经理号匹配该经理的雇员号”。</p><p>&nbsp;</p><p>查询每个雇员的经理的名字以及雇员的名字，雇员名字列别名为W，经理列别名为M。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1513" mdtype="fences">SELECT
worker.LAST_NAME W,manager.LAST_NAME M
from employees worker,employees manager
where worker.MANAGER_ID = manager.EMPLOYEE_ID;
</pre><p>&nbsp;</p><p>查询Fox的经理是谁？显示他的名字。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1516" mdtype="fences">SELECT
worker.LAST_NAME,manager.LAST_NAME
from employees worker,employees manager
where worker.MANAGER_ID = manager.EMPLOYEE_ID
AND
worker.LAST_NAME = 'Fox';
</pre><p>&nbsp;</p><h4><a name='header-n1518' class='md-header-anchor '></a>e）交叉连接</h4><p><img src='./assets/1718152113415.png' alt='1718152113415' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>使用交叉连接查询 employees 表与 departments 表。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1522" mdtype="fences">select * from employees cross join departments;
</pre><p>&nbsp;</p><h4><a name='header-n1524' class='md-header-anchor '></a>f）自然连接</h4><p><img src='./assets/1718152188045.png' alt='1718152188045' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>自然连接</strong></p><p>连接只能发生在两个表中有相同名字和数据类型的列上。如果列有相同的名字，但数据类型不同，NATURAL JOIN 语法会引起错误。</p><p>&nbsp;</p><p><strong>自然连接查询</strong></p><p><img src='./assets/1718152297642.png' alt='1718152297642' referrerPolicy='no-referrer' /></p><p>在图片例子中，LOCATIONS 表被用 LOCATION_ID 列连接到 DEPARTMENT表，这是在两个表中唯一名字相同的列。如果存在其它的同名同类型的列，自然连接会使用等值连接的方式连接他们，连接条件的关系为and。</p><p>&nbsp;</p><p>自然连接也可以被写为等值连接：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1535" mdtype="fences">SELECT d.department_id, d.department_name,
d.location_id , l.city
FROM
departments d , locations l
WHERE
d.location_id = l.location_id;
</pre><p>&nbsp;</p><p>使用自然连接查询所有有部门的雇员的名字以及部门名称。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1538" mdtype="fences">select e.last_name,d.department_name from employees e natural join departments d;
</pre><p>&nbsp;</p><h4><a name='header-n1540' class='md-header-anchor '></a>g）内连接</h4><p><img src='./assets/1718152473980.png' alt='1718152473980' referrerPolicy='no-referrer' /></p><p><strong>语法：</strong></p><ul><li>SELECT 查询列表;</li><li>FROM 表1 别名;</li><li>INNER JOIN 连接表(INNER关键字可省略);</li><li>ON 连接条件;</li></ul><p>&nbsp;</p><p><strong>用ON子句指定连接条件</strong></p><p><img src='./assets/1718152565913.png' alt='1718152565913' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>用ON子句指定更多的连接条件</strong></p><p><img src='./assets/1718152627378.png' alt='1718152627378' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>查询雇员名字为 Fox 的雇员 ID ，薪水与部门名称。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1561" mdtype="fences">select e.employee_id,e.salary,d.department_name from employees e inner JOIN departments d on e.department_id = d.department_id where e.last_name = 'Fox';
</pre><p>&nbsp;</p><h4><a name='header-n1563' class='md-header-anchor '></a>h）左外连接与右外连接</h4><p><img src='./assets/1718152745343.png' alt='1718152745343' referrerPolicy='no-referrer' /></p><p><strong>孤儿数据(Orphan Data)</strong></p><p>孤儿数据是指被连接的列的值为空的数据。</p><p>&nbsp;</p><p><strong>左外连接(LEFT OUTER JOIN)：</strong></p><p><img src='./assets/1718152892751.png' alt='1718152892751' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><img src='./assets/1718152918343.png' alt='1718152918343' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>左外连接</strong></p><p>左边的表 (EMPLOYEES) 中即使没有与 DEPARTMENTS 表中匹配的行，该查询也会取回 EMPLOYEES 表中所有的行。</p><p>&nbsp;</p><p>查询所有雇员的名字以及他们的部门名称，包含那些没有部门的雇员。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1577" mdtype="fences">select e.last_name,d.department_name from employees e LEFT OUTER JOIN departments d on e.dept_id = d.department_id;
</pre><p>&nbsp;</p><p><strong>右外连接(RIGTH OUTER JOIN)</strong></p><p><img src='./assets/1718153057796.png' alt='1718153057796' referrerPolicy='no-referrer' /></p><p><img src='./assets/1718153094846.png' alt='1718153094846' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>右外连接</strong></p><p>右边的表 (DEPARTMENTS ) 中即使没有与 EMPLOYEES 表中匹配的行，该查询也会取回 DEPARTMENTS 表中所有的行。</p><p>&nbsp;</p><p>查询所有雇员的名字以及他们的部门名称，包含那些没有雇员的部门。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1588" mdtype="fences">select  e.last_name,d.department_name from  employees  e RIGHT OUTER JOIN  departments  d on e.DEPARTMENT_ID = d.department_id;
</pre><p>&nbsp;</p><h4><a name='header-n1590' class='md-header-anchor '></a>i）全外连接</h4><p><img src='./assets/1718166661429.png' alt='1718166661429' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>注意： MySQL 中不支持 FULL OUTER JOIN 连接</p><p>可以使用 union 实现全完连接。</p><ul><li>UNION: 可以将两个查询结果集合并，返回的行都是唯一的，如同对整个结果集合使用了 DISTINCT。</li><li>UNION ALL: 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据， 那么返回的结果集就会包含重复的数据了。</li></ul><p>&nbsp;</p><p><strong>语法结构</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1603" mdtype="fences">(SELECT  投影列 FROM 表名 LEFT OUTER JOIN  表名 ON  连接条件) 
UNION 
(SELECT  投影列 FROM 表名 RIGHT OUTER JOIN  表名 ON  连接条件)
</pre><p>&nbsp;</p><p>查询所有雇员的名字以及他们的部门名称，包含那些没有雇员的部门以及没有部门的雇 员。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1606" mdtype="fences">(select e.last_name,d.department_name from employees e LEFT OUTER JOIN departments d on  e.department_id =  d.department_id) 
UNION 
(select  e1.last_name,d1.department_name from employees e1 RIGHT OUTER JOIN departments d1 on d1.department_id = e1.department_id)
</pre><p>&nbsp;</p><h4><a name='header-n1608' class='md-header-anchor '></a>j）连接查询实操</h4><p>写一个查询显示所有雇员的 last name、department id、and department name。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1610" mdtype="fences">SELECT e.last_name, e.department_id, d.department_name
FROM employees e,departments d
WHERE e.department_id = d.department_id;

SELECT e.last_name, e.department_id, d.department_name
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id;
</pre><p>&nbsp;</p><p>创建一个在部门 80 中的所有工作岗位的唯一列表，在输出中包括部门的地点</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1613" mdtype="fences">SELECT e.job_id, d.location_id
FROM employees e,departments d
WHERE e.department_id = d.department_id
AND e.department_id = 80;

SELECT e.job_id, d.location_id
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id
WHERE e.department_id = 80;
</pre><p>&nbsp;</p><p>写一个查询显示所有有佣金的雇员的 last name、department name、location ID 和城市</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1616" mdtype="fences">SELECT e.last_name, d.department_name, d.location_id, l.city
FROM employees e,departments d, locations l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND e.commission_pct IS NOT NULL;

SELECT e.last_name, d.department_name, d.location_id, l.city
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id
INNER JOIN locations l
ON d.location_id = l.location_id
WHERE e.commission_pct IS NOT NULL;
</pre><p>&nbsp;</p><p>显示所有在其 last names 中有一个小写 <em>a</em> 的雇员的 last name 和 departmentname。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1619" mdtype="fences">SELECT e.last_name, d.department_name
FROM employees e,departments d
WHERE e.department_id = d.department_id
AND e.last_name LIKE '%a%';


SELECT e.last_name, d.department_name
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id
WHERE e.last_name LIKE '%a%';
</pre><p>&nbsp;</p><p>用sql99的内连接写一个查询显示那些工作在 Toronto 的所有雇员的 last name、job、department number 和 department name。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1622" mdtype="fences" style="break-inside: unset;">SELECT e.last_name, e.job_id, e.department_id, d.department_name
FROM employees e,departments d,locations l
WHERE e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Toronto';


SELECT e.last_name, e.job_id, e.department_id, d.department_name
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id
INNER JOIN locations l
ON d.location_id = l.location_id
WHERE l.city = 'Toronto';
</pre><p>&nbsp;</p><p>显示雇员的 last name 和 employee number 连同他们的经理的 last name 和manager number。列标签分别为 Employee、Emp#、Manager 和 Mgr#</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1625" mdtype="fences">SELECT w.last_name '员工名字', w.employee_id '员工Id', m.last_name '经理名字', m.employee_id '经理id'
FROM employees w
INNER JOIN employees m
ON w.manager_id = m.employee_id;
</pre><p>&nbsp;</p><h3><a name='header-n1627' class='md-header-anchor '></a>10，聚合函数</h3><h4><a name='header-n1628' class='md-header-anchor '></a>a）什么是聚合函数</h4><p><img src='./assets/1718166934751.png' alt='1718166934751' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>聚合函数:</strong></p><p>聚合函数也称之为多行函数，组函数或分组函数。聚合函数不象单行函数，聚合函数对行的分组进行操作，对每组给出一个结果。如果在查询中没有指定分组，那么聚合函数则将查询到的结果集视为一组。</p><p>&nbsp;</p><p><strong>聚合函数类型</strong></p><p><img src='./assets/1718167036728.png' alt='1718167036728' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>聚合函数说明：</p><figure><table><thead><tr><th>函数名</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>AVG(expression)</td><td>返回一个表达式的平均值，expression 是一个字段</td><td>返回 Products 表中Price 字段的平均值：<code>SELECT AVG(Price) AS AveragePrice FROM Products;</code></td></tr><tr><td>COUNT(expression)</td><td>返回查询的记录总数，expression 参数是一个字段或者 * 号</td><td>返回 Products 表中 products 字段总共有多少条记录：<code>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</code></td></tr><tr><td>MAX(expression)</td><td>返回字段 expression 中的最大值</td><td>返回数据表 Products 中字段 Price 的最大值：<code>SELECT MAX(Price) AS LargestPrice FROM Products;</code></td></tr><tr><td>MIN(expression)</td><td>返回字段 expression 中的最小值</td><td>返回数据表 Products 中字段 Price 的最小值：<code>SELECT MIN(Price) AS MinPrice FROM Products;</code></td></tr><tr><td>SUM(expression)</td><td>返回指定字段的总和</td><td>计算 OrderDetails 表中字段 Quantity 的总和：<code>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</code></td></tr></tbody></table></figure><p>&nbsp;</p><p><strong>聚合函数使用方式</strong></p><p><img src='./assets/1718167092595.png' alt='1718167092595' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>使用聚合函数的原则</strong></p><ul><li>DISTINCT 使得函数只考虑不重复的值；</li><li>所有聚合函数忽略空值。为了用一个值代替空值，用 IFNULL 或 COALESCE 函数。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1676' class='md-header-anchor '></a>b）avg函数和sum函数</h4><p><strong>AVG(arg)函数：</strong>对分组数据做平均值运算。arg:参数类型只能是数字类型。</p><p>&nbsp;</p><p><strong>SUM(arg)函数：</strong>对分组数据求和。arg:参数类型只能是数字类型。</p><p>&nbsp;</p><p>计算员工表中工作编号含有REP的工作岗位的平均薪水与薪水总和。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1682" mdtype="fences">SELECT AVG(salary),SUM(salary)
FROM employees
WHERE job_id LIKE '%REP%';
</pre><p>&nbsp;</p><h4><a name='header-n1684' class='md-header-anchor '></a>c）min函数和max函数</h4><p><strong>MIN(arg)函数：</strong>求分组中最小数据。arg:参数类型可以是字符、数字、 日期。</p><p>&nbsp;</p><p><strong>MAX(arg)函数：</strong>求分组中最大数据。arg:参数类型可以是字符、数字、 日期。</p><p>&nbsp;</p><p>查询员工表中入职时间最短与最长的员工，并显示他们的入职时间。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1690" mdtype="fences">SELECT MIN(hire_date), MAX(hire_date) FROM employees;
</pre><p>&nbsp;</p><h4><a name='header-n1692' class='md-header-anchor '></a>d）count函数</h4><p>&nbsp;</p><p>返回分组中的总行数。COUNT 函数有三种格式：</p><ul><li><p>COUNT(*)：返回表中满足 SELECT 语句的所有列的行数，包括重复行，包括有空值列</p><p>的行。</p></li><li><p>COUNT(expr)：返回在列中的由 <em>expr</em> 指定的非空值的数。</p></li><li><p>COUNT(DISTINCT expr)：返回在列中的由 <em>expr</em> 指定的唯一的非空值的数。</p></li></ul><p>&nbsp;</p><p><strong>使用 DISTINCT 关键字</strong></p><ul><li>COUNT(DISTINCT expr) 返回对于表达式 <em>expr</em> 非空并且值不相同的行数</li><li>显示 EMPLOYEES 表中不同部门数的值</li></ul><p>&nbsp;</p><p>显示员工表中部门编号是80中有佣金的雇员人数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1712" mdtype="fences">SELECT COUNT(commission_pct) FROM employees WHERE department_id = 80;
</pre><p>&nbsp;</p><p>显示员工表中的部门数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1715" mdtype="fences">SELECT COUNT(DISTINCT department_id) FROM employees;
</pre><p>&nbsp;</p><p>在组函数中使用 IFNULL 函数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1718" mdtype="fences">SELECT AVG(IFNULL(commission_pct, 0)) FROM employees;
</pre><p>&nbsp;</p><h4><a name='header-n1720' class='md-header-anchor '></a>e）创建分组数据</h4><p><img src='./assets/1718167711829.png' alt='1718167711829' referrerPolicy='no-referrer' /></p><p><strong>创建数据组</strong></p><p>在没有进行数据分组之前，所有聚合函数是将结果集作为一个大的信息组进行处理。但是，有时，则需要将表的信息划分为较小的组，可以用 GROUP BY 子句实现。</p><p>&nbsp;</p><p><strong>GROUP BY 子句语法</strong></p><p><img src='./assets/1718167792275.png' alt='1718167792275' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>原则</strong></p><ul><li>使用 WHERE 子句，可以在划分行成组以前过滤行。</li><li>如果有WHERE子句，那么GROUP BY 子句必须在WHERE的子句后面。</li><li>在 GROUP BY 子句中必须包含列。</li></ul><p>&nbsp;</p><p><strong>GROUP BY 子句</strong></p><p><img src='./assets/1718167847398.png' alt='1718167847398' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>下面是包含一个 GROUP BY 子句 SELECT 语句的求值过程：</p><ul><li><p>SELECT 子句指定要返回的列：</p></li><li><p>在 EMPLOYEES 表中的部门号</p><p>− GROUP BY 子句中指定分组的所有薪水的平均值</p><p>− FROM 子句指定数据库必须访问的表：EMPLOYEES 表。</p></li><li><p>WHERE 子句指定被返回的行。因为无 WHERE 子句默认情况下所有行被返回。</p></li><li><p>GROUP BY 子句指定行怎样被分组。行用部门号分组，所以 AVG 函数被应用于薪水列，以计算每个部门的平均薪水。</p></li></ul><p>&nbsp;</p><p>计算每个部门的员工总数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1754" mdtype="fences">SELECT DEPARTMENT_ID, COUNT(*) FROM employees GROUP BY DEPARTMENT_ID;
</pre><p>&nbsp;</p><h4><a name='header-n1756' class='md-header-anchor '></a>f）在多列上使用分组</h4><p><img src='./assets/1718168022894.png' alt='1718168022894' referrerPolicy='no-referrer' /></p><p><strong>在组中分组</strong></p><p>可以列出多个 GROUP BY 列返回组和子组的摘要结果。可以用 GROUP BY子句中的列的顺序确定结果的默认排序顺序。下面是图片中的 SELECT 语句中包含一个 GROUP BY 子句时的求值过程：</p><ul><li><p>SELECT 子句指定被返回的列：</p><p>− 部门号在 EMPLOYEES 表中</p><p>− Job ID 在 EMPLOYEES 表中</p><p>− 在 GROUP BY 子句中指定的组中所有薪水的合计</p></li><li><p>FROM 子句指定数据库必须访问的表：EMPLOYEES 表。</p></li><li><p>GROUP BY 子句指定你怎样分组行：</p><p>− 首先，用部门号分组行。</p><p>− 第二，在部门号的分组中再用 job ID 分组行。</p></li></ul><p>如此 SUM 函数被用于每个部门号分组中的所有 job ID 的 salary 列。</p><p>&nbsp;</p><p>计算每个部门的不同工作岗位的员工总数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1775" mdtype="fences">SELECT e.DEPARTMENT_ID, e.JOB_ID,COUNT(*)FROM employees e
GROUP BY e.DEPARTMENT_ID,e.JOB_ID;
</pre><p>&nbsp;</p><h4><a name='header-n1777' class='md-header-anchor '></a>g）约束分组结果</h4><p><img src='./assets/1718168250169.png' alt='1718168250169' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>HAVING</strong> <strong>子句</strong></p><p>HAVING 子句是对查询出结果集分组后的结果进行过滤。</p><p>&nbsp;</p><p><strong>约束分组结果</strong></p><p>用 WHERE 子句约束选择的行，用 HAVING 子句约束组。为了找到每个部门中的最高薪水，而且只显示最高薪水大于 $10,000 的那些部门，可以象下面这样做：</p><ol start='' ><li>用部门号分组，在每个部门中找最大薪水。</li><li>返回那些有最高薪水大于 $10,000 的雇员的部门</li></ol><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1790" mdtype="fences">SELECT department_id, MAX(salary) FROM employees GROUP BY department_id HAVING MAX(salary)&gt;10000 ;
</pre><p>&nbsp;</p><p><strong>HAVING子句语法</strong></p><p><img src='./assets/1718168379921.png' alt='1718168379921' referrerPolicy='no-referrer' /></p><p>显示那些合计薪水超过 13,000 的每个工作岗位的合计薪水。排除那些JOB_ID中含有REP的工作岗位，并且用合计月薪排序列表。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1795" mdtype="fences">SELECT job_id, SUM(salary) PAYROLL FROM employees WHERE job_id NOT LIKE '%REP%'GROUP BY job_id HAVING SUM(salary) &gt; 13000 ORDER BY SUM(salary);
</pre><p>&nbsp;</p><h4><a name='header-n1797' class='md-header-anchor '></a>h）聚合函数与数据分组练习</h4><p>显示所有雇员的最高、最低、合计和平均薪水，列标签分别为：Max、Min、Sum 和 Avg。四舍五入结果为最近的整数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1799" mdtype="fences">SELECT ROUND(MAX(salary)) `max`, ROUND(MIN(salary)) `min`,ROUND(SUM(salary)) `sum`, ROUND(AVG(salary)) `avg`
FROM employees e;
</pre><p>&nbsp;</p><p>写一个查询显示每一工作岗位的人数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1802" mdtype="fences">SELECT
e.JOB_ID,COUNT(*)
FROM employees e
GROUP BY e.JOB_ID;
</pre><p>&nbsp;</p><p>确定经理人数，不需要列出他们，列标签是 Number of Managers。提示：用MANAGER_ID列决定经理号。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1805" mdtype="fences">SELECT COUNT(DISTINCT e.manager_id) `Number of Managers`
FROM employees e;
</pre><p>&nbsp;</p><p>写一个查询显示最高和最低薪水之间的差。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1808" mdtype="fences">SELECT
MAX(e.SALARY) - MIN(e.SALARY)
FROM employees e;
</pre><p>&nbsp;</p><p>显示经理号和经理付给雇员的最低薪水。排除那些经理未知的人。排除最低薪水小于等于 $6,000 的组。按薪水降序排序输出。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1811" mdtype="fences">SELECT e.MANAGER_ID,MIN(e.SALARY)
FROM employees e
WHERE e.MANAGER_ID is not null
GROUP BY e.MANAGER_ID 
HAVING min(e.SALARY) &gt; 6000
ORDER BY min(e.SALARY) desc;
</pre><p>&nbsp;</p><p>写一个查询显示每个部门的名字、地点、人数和部门中所有雇员的平均薪水。四舍五入薪水到两位小数。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1814" mdtype="fences">SELECT 
d.DEPARTMENT_NAME,d.LOCATION_ID,COUNT(*),ROUND(AVG(e.SALARY))
FROM employees e,departments d
where e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_NAME,d.LOCATION_ID
</pre><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n1817' class='md-header-anchor '></a>11，子查询</h3><p>&nbsp;</p><h4><a name='header-n1819' class='md-header-anchor '></a>a）什么是子查询</h4><p><strong>用子查询解决问题：</strong></p><p>假如要写一个查询来找出挣钱比 Abel 的薪水还多的人。为了解决这个问题，需要两个查询：一个找出 Abel 的收入，第二个查询找出收入高于 Abel 的人。可以用组合两个查询的方法解决这个问题。内查询或子查询返回一个值给外查询或主查询。使用一个子查询相当于执行两个连续查询并且用第一个查询的结果作为第二个查询的搜索值。</p><p>&nbsp;</p><p><strong>子查询语法：</strong></p><p><img src='./assets/1718239086694.png' alt='1718239086694' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>子查询：</strong></p><p>子查询是一个 SELECT 语句，它是嵌在另一个 SELECT 语句中的子句。使用子查询可以用简单的语句构建功能强大的语句。</p><p>可以将子查询放在许多的 SQL 子句中，包括：</p><ul><li>WHERE 子句</li><li>HAVING 子句</li><li>FROM 子句</li></ul><p>&nbsp;</p><p><strong>使用子查询：</strong></p><p><img src='./assets/1718239131111.png' alt='1718239131111' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>使用子查询的原则：</strong></p><ul><li>子查询放在圆括号中。</li><li>将子查询放在比较条件的右边。</li><li>在单行子查询中用单行运算符，在多行子查询中用多行运算符。</li></ul><p>&nbsp;</p><p><strong>子查询类型：</strong></p><p><img src='./assets/1718239239091.png' alt='1718239239091' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>查询与Fox同一部门的同事，并显示他们的名字与部门ID。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1856" mdtype="fences">select e.LAST_NAME,e.DEPARTMENT_ID FROM employees e 
where e.DEPARTMENT_ID = 
(select e1.DEPARTMENT_ID from employees e1 where e1.last_name = 'Fox');
</pre><p>&nbsp;</p><h4><a name='header-n1858' class='md-header-anchor '></a>b）单行子查询</h4><p><strong>单行子查询：</strong></p><p><img src='./assets/1718239369430.png' alt='1718239369430' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>单行子查询：</strong></p><p>单行子查询是从内查询返回一行的查询。在该子查询类型中用一个单行操作符。</p><p>&nbsp;</p><p>查询 Fox的同事，但是不包含他自己。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1866" mdtype="fences">SELECT e.last_name, e.department_id 
FROM employees e 
WHERE e.department_id = (SELECT e1.department_id FROM employees e1 WHERE e1.last_name='Fox')
AND e.last_name &lt;&gt; 'Fox';
</pre><p>&nbsp;</p><h4><a name='header-n1868' class='md-header-anchor '></a>c）多行子查询</h4><p>多行子查询：</p><p><img src='./assets/1718239687933.png' alt='1718239687933' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>多行子查询：</strong></p><p>子查询返回多行被称为多行子查询。对多行子查询要使用多行运算符而不是单行运算符。</p><p>&nbsp;</p><p><strong>使用ANY运算符：</strong></p><p><img src='./assets/1718239752971.png' alt='1718239752971' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>ANY 运算符：</strong>ANY 运算符比较一个值与一个子查询返回的任意一个值。</p><ul><li>&lt; ANY 意思是小于最大值。</li><li>&gt; ANY 意思是大于最小值。</li><li>= ANY 等同于 IN。</li></ul><p>&nbsp;</p><p><strong>使用ALL运算符：</strong></p><p><img src='./assets/1718239841545.png' alt='1718239841545' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>ALL 运算符比较一个值与子查询返回的全部值。</p><ul><li>&lt; ALL 意思是小于最小值。</li><li>&gt; ALL 意思是大于最大值，</li></ul><p>NOT 运算符可以与 IN运算符一起使用。</p><p>&nbsp;</p><p>&nbsp;</p><p><strong>子查询中的空值：</strong></p><p><img src='./assets/1718239893682.png' alt='1718239893682' referrerPolicy='no-referrer' /></p><p>内查询返回的值含有空值，并因此整个查询无返回行，原因是用大于、小于或不等于比较Null值，都返回null。所以，只要空值可能是子查询结果集的一部分，就不能用 NOT IN 运算符。NOT IN 运算符相当于 &lt;&gt; ALL。</p><p>注意，空值作为一个子查询结果集的一部分，如果使用 IN 操作符的话，不是一个问题。IN 操作符相当于 =ANY。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1904" mdtype="fences">SELECT emp.last_name FROM employees emp WHERE emp.employee_id IN (SELECT mgr.manager_id FROM employees mgr);
</pre><p>&nbsp;</p><p>查找各部门收入为部门最低的那些雇员。显示他们的名字，薪水以及部门 ID。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1907" mdtype="fences">SELECT  em.last_name,em.salary,em.department_id 
FROM  employees  em 
WHERE  em.salary 
	IN(SELECT MIN(e.salary) FROM employees e GROUP BY e.department_id) 
GROUP BY em.department_id;
</pre><p>&nbsp;</p><h4><a name='header-n1909' class='md-header-anchor '></a>d）实操</h4><p>写一个查询显示与 Zlotkey 在同一部门的雇员的 last name 和 hire date，结果中不包括 Zlotkey。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1911" mdtype="fences">SELECT
e1.LAST_NAME,e1.HIRE_DATE
FROM employees e1
where e1.DEPARTMENT_ID = 
(select e.DEPARTMENT_ID FROM employees e where e.LAST_NAME ='Zlotkey')
AND e1.LAST_NAME &lt;&gt; 'Zlotkey';
</pre><p>创建一个查询显示所有其薪水高于平均薪水的雇员的雇员号和名字。按薪水的升序排序。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1913" mdtype="fences">SELECT
e1.EMPLOYEE_ID,e1.LAST_NAME
FROM employees e1
WHERE e1.SALARY &gt;
(select AVG(e.SALARY) from employees e)
ORDER BY e1.SALARY;
</pre><p>写一个查询显示所有工作在有任一雇员的名字中包含一个 <em>u</em> 的部门的雇员的雇员号和名字。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1915" mdtype="fences">SELECT
e1.EMPLOYEE_ID,e1.LAST_NAME 
FROM employees e1
WHERE e1.DEPARTMENT_ID IN
(SELECT e.DEPARTMENT_ID FROM employees e WHERE e.LAST_NAME like '%u%')
</pre><p>显示所有部门地点号 (department location ID ) 是 1700 的雇员的 last name、department number 和 job ID。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1917" mdtype="fences">SELECT
e.LAST_NAME,e.DEPARTMENT_ID,e.JOB_ID
FROM employees e
WHERE e.DEPARTMENT_ID IN
(SELECT 
d.DEPARTMENT_ID
FROM departments d
WHERE d.LOCATION_ID = 1700)
</pre><p>显示每个向 King 报告的雇员的名字和薪水。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1920" mdtype="fences">SELECT 
e1.LAST_NAME,e1.SALARY
FROM employees e1
where e1.MANAGER_ID IN
(select e.EMPLOYEE_ID from employees e where e.LAST_NAME ='King')
</pre><p>显示在 Executive 部门的每个雇员的 department number、last name 和 job ID。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1922" mdtype="fences">SELECT
e.DEPARTMENT_ID,e.LAST_NAME,e.JOB_ID
FROM employees e
WHERE e.DEPARTMENT_ID =
(select d.DEPARTMENT_ID FROM departments d WHERE d.DEPARTMENT_NAME = 'Executive');
</pre><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n1925' class='md-header-anchor '></a>12，索引</h3><p>&nbsp;</p><h4><a name='header-n1927' class='md-header-anchor '></a>a）索引介绍</h4><p><img src='./assets/1718255014928.png' alt='1718255014928' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>索引介绍：</strong></p><p>索引是对数据库表中的一列或多列值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息。索引是一种特殊的文件，它们包含着对数据表里所有记录的位置信息。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。MySQL 索引的建立对于MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。</p><p>&nbsp;</p><p><strong>索引的作用</strong></p><p>索引相当于图书上的目录，可以根据目录上的页码快速找到所需的内容，提高性能（查询速度）。</p><p>&nbsp;</p><p><strong>索引优点：</strong></p><ol start='' ><li>通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性；</li><li>可以加快数据的检索速度；</li><li>可以加速表与表之间的连接；</li><li>在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间；</li></ol><p>&nbsp;</p><p><strong>索引缺点</strong></p><ol start='' ><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加；</li><li>索引需要占用物理空间，数据量越大，占用空间越大；</li><li>会降低表的增删改的效率，因为每次增删改索引都需要进行动态维护；</li></ol><p>&nbsp;</p><p><strong>什么时候需要创建索引</strong></p><ol start='' ><li>频繁作为查询条件的字段应该创建索引；</li><li>查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）；</li><li>查询中统计或者分组的字段；</li></ol><p>&nbsp;</p><p><strong>什么时候不需要创建索引</strong></p><ol start='' ><li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件；</li><li>where条件里用不到的字段，不创建索引；</li><li>表记录太少，不需要创建索引；</li><li>经常增删改的表；</li><li>数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引；</li></ol><p>&nbsp;</p><p><strong>MySQL中的索引类型</strong></p><ul><li><p>普通索引：</p><p>最基本的索引，它没有任何限制。</p></li><li><p>唯一索引：</p><p>索引列的值必须唯一，但允许有空值，如果是组合索引，则列值的组合必须唯一。</p></li><li><p>主键索引：</p><p>特殊的索引，唯一的标识一条记录，不能为空，一般用primary key来约束。</p></li><li><p>联合索引：</p><p>在多个字段上建立索引，能够加速查询到速度。</p></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1996' class='md-header-anchor '></a>b）普通索引</h4><p>创建如下表：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n1998" mdtype="fences">-- 员工表
CREATE TABLE emp (
    id INT PRIMARY KEY AUTO_INCREMENT,  -- 员工id，主键且自增长
    ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空且唯一
    joindate DATE NOT NULL,  -- 入职日期，非空
    salary DOUBLE(7,2) NOT NULL,  -- 工资，非空
    bonus DOUBLE(7,2) DEFAULT 0  -- 奖金，如果没有将近默认为0
);
</pre><p>&nbsp;</p><p>是最基本的索引，它没有任何限制。在创建索引时，可以指定索引长度。length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度，如果是 BLOB 和 TEXT 类型，必须指定 length。</p><p>&nbsp;</p><p>创建索引时需要注意：如果指定单列索引长度，length 必须小于这个字段所允许的最大字符个数。</p><p>&nbsp;</p><p><strong>查询索引：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2005" mdtype="fences">SHOW INDEX FROM table_name;
</pre><p><img src='./assets/1718261645043.png' alt='1718261645043' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>直接创建索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2009" mdtype="fences">CREATE INDEX index_name ON table(column(length));
</pre><p>&nbsp;</p><p>为 emp表中的 salary 创建一个索引，索引名为 emp_salary_index；</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2012" mdtype="fences">create index emp_salary_index ON emp(salary);
</pre><p>&nbsp;</p><p><strong>修改表添加索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2015" mdtype="fences">ALTER TABLE table_name ADD INDEX index_name (column(length));
</pre><p>修改 emp 表，为 bonus 列添加索引，索引名为 emp_bonus_index；</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2017" mdtype="fences">alter table emp add index emp_bonus_index(bonus);
</pre><p>&nbsp;</p><p><strong>创建表时指定索引列:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2020" mdtype="fences">CREATE TABLE `table` (
COLUMN TYPE ,
PRIMARY KEY (`id`),
INDEX index_name (column(length))
);
</pre><p>&nbsp;</p><p>创建 emp2 表，包含 emp_id,name,address 列， 同时为 name 列创建索引 ，索引名为 emp2_name_index。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2023" mdtype="fences">CREATE TABLE  
	emp2(
		emp_id INT PRIMARY KEY AUTO_INCREMENT,
		NAME VARCHAR(30),
		address VARCHAR(50),
		INDEX emp2_name_index(NAME)
);
</pre><p>&nbsp;</p><p><strong>删除索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2026" mdtype="fences">DROP INDEX indexname ON tablename;
</pre><p>删除 emp2 表中索引名为 emp2_name_index 的索引。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2028" mdtype="fences">drop index emp2_name_index on emp2;
</pre><p>&nbsp;</p><h4><a name='header-n2030' class='md-header-anchor '></a>c）唯一索引</h4><p>唯一索引与普通索引类似，不同的就是： 索引列的值必须唯一，但允许有空值。</p><p>表如下：</p><p><img src='./assets/1718262349260.png' alt='1718262349260' referrerPolicy='no-referrer' /></p><p><img src='./assets/1718262389547.png' alt='1718262389547' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>创建唯一索引：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2037" mdtype="fences">CREATE UNIQUE INDEX indexName ON table(column(length));
</pre><p>为 emp2 表中的 name 创建一个唯一索引，索引名为 emp2_name_index。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2039" mdtype="fences">create unique index emp2_name_index on emp2(name);
</pre><p><img src='./assets/1718262442459.png' alt='1718262442459' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>修改表添加唯一索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2043" mdtype="fences">ALTER TABLE table_name ADD UNIQUE indexName (column(length));
</pre><p>修改 emp2表，为 address列添加唯一索引，索引名为 emp2_address_index。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2045" mdtype="fences">alter table emp2 add unique emp2_address_index(address);
</pre><p>&nbsp;</p><p><strong>创建表时指定唯一索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2048" mdtype="fences">CREATE TABLE `table` (
COLUMN TYPE ,
PRIMARY KEY (`id`),
UNIQUE index_name (column(length))
);
</pre><p>创建 emp3 表，包含 emp_id,name,address 列，同时为 name 列创建唯一索引。索引名为emp5_name_index。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2050" mdtype="fences">create table emp3(emp_id int primary key ,name varchar(30),address varchar(30),unique emp3_name_index(name));
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2053' class='md-header-anchor '></a>d）主键索引</h4><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</p><p>&nbsp;</p><p><strong>修改表添加主键索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2057" mdtype="fences">ALTER TABLE  表名 ADD PRIMARY KEY(列名);
</pre><p>修改 emp 表为 employee_id 添加主键索引。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2059" mdtype="fences">alter table emp add primary key(employee_id);
</pre><p>&nbsp;</p><p><strong>创建表时指定主键索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2062" mdtype="fences">CREATE TABLE `table` (
COLUMN TYPE ,
PRIMARY KEY(column)
);
</pre><p>创建 emp6 表，包含 emp_id,name,address 列，同时为 emp_id 列创建主键索引。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2064" mdtype="fences">create table emp6(employee_id int primary key auto_increment,name varchar(20),address varchar(50));
</pre><p>&nbsp;</p><h4><a name='header-n2066' class='md-header-anchor '></a>e）组合索引</h4><p>组合索引是指使用多个字段创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用(最左前缀原则)。</p><p>&nbsp;</p><p><strong>最左前缀原则:</strong> 就是最左优先。如： 我们使用表中的 name ，address ，salary 创建组合索引，那么想要组合索引生效， 我们只能使用如下组合：</p><ul><li>name/address/salary</li><li>name/address</li><li>name/</li></ul><p>如果使用 addrees/salary 或者是 salary 则索引不会生效。</p><p>&nbsp;</p><p><strong>添加组合索引：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2080" mdtype="fences">ALTER TABLE table_name ADD INDEX index_name (column(length),column(length));
</pre><p>修改 emp6 表，为 name ，address 列创建组合索引。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2082" mdtype="fences">alter table emp6 add index emp6_index_n_a(name,address);
</pre><p>&nbsp;</p><p><strong>创建表时创建组合索引:</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2085" mdtype="fences">CREATE TABLE `table` (
COLUMN TYPE ,
INDEX index_name (column(length),column(length))
);
</pre><p>创建 emp7 表，包含 emp_id,name,address 列，同时为 name,address 列创建组合索引。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2087" mdtype="fences">create table emp7(emp_id int primary key auto_increment ,name varchar(20),address varchar(30),index emp7_index_n_a(name,address));
</pre><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n2090' class='md-header-anchor '></a>13，事务</h3><p>&nbsp;</p><h4><a name='header-n2092' class='md-header-anchor '></a>a）事务介绍</h4><p>事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令。事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。事务是一个不可分割的工作逻辑单元。</p><p>&nbsp;</p><p>事务定义(Transaction)</p><ul><li>事务是一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)</li><li>一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成</li><li>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同</li></ul><p>&nbsp;</p><p>这些概念不好理解，接下来举例说明，张三和李四账户中各有1000块钱，现李四需要转500块钱给张三，具体的转账操作为</p><ul><li>第一步：查询李四账户余额</li><li>第二步：从李四账户金额 -500</li><li>第三步：给张三账户金额 +500</li></ul><p>&nbsp;</p><p>现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题</p><p><img src='./assets/1718256734862.png' alt='1718256734862' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>事务四大特征(ACID)</strong></p><ul><li>原子性(ATOMICITY) ，事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性(CONSISTENCY)，事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性(ISOLATION)，一个事务的执行不能被其他事务干扰。多个事务之间，操作的可见性。</li><li>持久性(DURABILITY)，事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>&nbsp;</p><p>从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。mysql存储引擎有很多，小皮软件中mysql默认的存储引擎是不支持事务，有的是支持的。切换一下存储引擎：</p><p><img src='./assets/1718256772560.png' alt='1718256772560' referrerPolicy='no-referrer' /></p><p><img src='./assets/1718256784804.png' alt='1718256784804' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2134' class='md-header-anchor '></a>b）使用事务</h4><figure><table><thead><tr><th>TCL语句</th><th>描述</th></tr></thead><tbody><tr><td>start transaction</td><td>事务开启</td></tr><tr><td>commit</td><td>事物提交</td></tr><tr><td>rollback</td><td>事物回滚</td></tr></tbody></table></figure><p>&nbsp;</p><p>开启事务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2150" mdtype="fences">START TRANSACTION;
或者  
BEGIN;
</pre><p>&nbsp;</p><p>提交事务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2153" mdtype="fences">commit;
</pre><p>&nbsp;</p><p>回滚事务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2156" mdtype="fences">rollback;
</pre><p>&nbsp;</p><p>环境准备：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2159" mdtype="fences">DROP TABLE IF EXISTS account;

-- 创建账户表
CREATE TABLE account(
	id int PRIMARY KEY auto_increment,
	name varchar(10),
	money double(10,2)
);

-- 添加数据
INSERT INTO account(name,money) values('张三',1000),('李四',1000);
</pre><p><img src='./assets/1718263510023.png' alt='1718263510023' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>不加事务演示问题：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2163" mdtype="fences">-- 转账操作
-- 1. 查询李四账户金额是否大于500

-- 2. 李四账户 -500
UPDATE account set money = money - 500 where name = '李四';

出现异常了...  -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行

-- 3. 张三账户 +500
UPDATE account set money = money + 500 where name = '张三';
</pre><p><img src='./assets/1718263660099.png' alt='1718263660099' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>mysql中事务是自动提交的。也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。可以通过下面语句查询默认提交方式：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2167" mdtype="fences">  SELECT @@autocommit;
</pre><p><img src='./assets/1718263919885.png' alt='1718263919885' referrerPolicy='no-referrer' /></p><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2170" mdtype="fences"> set @@autocommit = 0;
</pre><p>&nbsp;</p><p>&nbsp;</p><p>添加事务sql如下：</p><p><img src='./assets/1718265957804.png' alt='1718265957804' referrerPolicy='no-referrer' /></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2175" mdtype="fences" style="break-inside: unset;">-- 开启事务
BEGIN;

-- 转账操作
-- 1. 查询李四账户金额是否大于500

-- 2. 李四账户 -500
UPDATE ACCOUNT SET money = money - 500 WHERE NAME = '李四';

出现异常了...  -- 此处不是注释，在整体执行时会出问题，后面的sql则不执行

-- 3. 张三账户 +500
UPDATE ACCOUNT SET money = money + 500 WHERE NAME = '张三';

-- 回滚事务
ROLLBACK;

-- 提交事务
COMMIT;
</pre><p>&nbsp;</p><h4><a name='header-n2177' class='md-header-anchor '></a>c）事务并发问题与隔离级别</h4><p><strong>脏读（读取未提交数据）</strong></p><p>指一个事务读取了另外一个事务未提交的数据。A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。</p><p><img src='./assets/1718257330568.png' alt='1718257330568' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>不可重复读（前后多次读取，数据内容不一致）：</strong></p><p>在一个事务内读取表中的某一行数据，多次读取结果不同。</p><p>事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。</p><p><img src='./assets/1718257414363.png' alt='1718257414363' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>幻读（前后多次读取，数据总量不一致）：</strong></p><p>是指在一个事务内读取到了别的事务插入的数据，导致前后读取数量总量不一致。</p><p>事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。</p><p><img src='./assets/1718257479285.png' alt='1718257479285' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>事务的隔离级别：</strong></p><p>事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。</p><p>&nbsp;</p><p>事务的隔离级别从低到高依次为：</p><ul><li>READ UNCOMMITTED</li><li>READ COMMITTED</li><li>REPEATABLE READ</li><li>SERIALIZABLE</li></ul><p>&nbsp;</p><p>隔离级别越低，越能支持高并发的数据库操作。</p><p><img src='./assets/1718257603602.png' alt='1718257603602' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>查看MySQL默认事务隔离级别：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2211" mdtype="fences">SELECT @@transaction_isolation;
</pre><p>&nbsp;</p><p><strong>设置事务隔离级别：</strong>对当前session有效。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2214" mdtype="fences">set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set session transaction isolation level serializable;
</pre><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n2217' class='md-header-anchor '></a>14，用户管理与其它</h3><p>&nbsp;</p><h4><a name='header-n2219' class='md-header-anchor '></a>a）mysql用户管理</h4><p>MySQL 是一个多用户的数据库系统，按权限，用户可以分为两种： root 用户，超级管理员，和由 root 用户创建的普通用户。</p><p>&nbsp;</p><p><strong>创建用户：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2223" mdtype="fences">CREATE USER username IDENTIFIED BY 'password';
</pre><p>创建一个 u_yls 的用户，并查看创建是否成功。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2225" mdtype="fences">create user u_yls IDENTIFIED by 'yls';
select user,host from mysql.user;
</pre><p>&nbsp;</p><p><strong>查看用户：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2228" mdtype="fences">SELECT USER,HOST FROM mysql.user;
</pre><p>&nbsp;</p><p>新用户创建完后是无法登陆的，需要分配权限。 </p><p>GRANT 权限 ON 数据库.表 TO 用户名@登录主机 IDENTIFIED BY &quot;密码&quot;</p><p><strong>登陆主机：</strong></p><figure><table><thead><tr><th><strong>字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%</td><td>匹配所有主机</td></tr><tr><td>localhost</td><td>localhost 不会被解析成 IP 地址，直接通过 UNIXsocket 连接</td></tr><tr><td>127.0.0.1</td><td>会通过 TCP/IP 协议连接，并且只能在本机访问</td></tr><tr><td>:: 1</td><td>::1 就是兼容支持 ipv6 的，表示同 ipv4 的 127.0.0. 1</td></tr></tbody></table></figure><p>&nbsp;</p><p><strong>权限列表：</strong></p><figure><table><thead><tr><th><strong>权 限</strong></th><th><strong>作用范围</strong></th><th><strong>作 用</strong></th></tr></thead><tbody><tr><td>all [privileges]</td><td>服务器</td><td>所有权限</td></tr><tr><td>select</td><td>表、列</td><td>选择行</td></tr><tr><td>insert</td><td>表、列</td><td>插入行</td></tr><tr><td>update</td><td>表、列</td><td>更新行</td></tr><tr><td>delete</td><td>表</td><td>删除行</td></tr><tr><td>create</td><td>数据库、表、索引</td><td>创建</td></tr><tr><td>drop</td><td>数据库、表、视图</td><td>删除</td></tr><tr><td>reload</td><td>服务器</td><td>允许使用flush语句</td></tr><tr><td>shutdown</td><td>服务器</td><td>关闭服务</td></tr><tr><td>process</td><td>服务器</td><td>查看线程信息</td></tr><tr><td>file</td><td>服务器</td><td>文件操作</td></tr><tr><td>grant option</td><td>数据库、表、存储过程</td><td>授权</td></tr><tr><td>references</td><td>数据库、表</td><td>外键约束的父表</td></tr><tr><td>index</td><td>表</td><td>创建/删除索引</td></tr><tr><td>alter</td><td>表</td><td>修改表结构</td></tr><tr><td>show databases</td><td>服务器</td><td>查看数据库名称</td></tr><tr><td>super</td><td>服务器</td><td>超级权限</td></tr><tr><td>create temporary tables</td><td>表</td><td>创建临时表</td></tr><tr><td>lock tables</td><td>数据库</td><td>锁表</td></tr><tr><td>execute</td><td>存储过程</td><td>执行</td></tr><tr><td>replication client</td><td>服务器</td><td>允许查看主/从/二进制日志状态</td></tr><tr><td>replication slave</td><td>服务器</td><td>主从复制</td></tr><tr><td>create view</td><td>视图</td><td>创建视图</td></tr><tr><td>show view</td><td>视图</td><td>查看视图</td></tr><tr><td>create routine</td><td>存储过程</td><td>创建存储过程</td></tr><tr><td>alter routine</td><td>存储过程</td><td>修改/删除存储过程</td></tr><tr><td>create user</td><td>服务器</td><td>创建用户</td></tr><tr><td>event</td><td>数据库</td><td>创建/更改/删除/查看事件</td></tr><tr><td>trigger</td><td>表</td><td>触发器</td></tr><tr><td>create tablespace</td><td>服务器</td><td>创建/更改/删除表空间/日志文件</td></tr><tr><td>proxy</td><td>服务器</td><td>代理成为其它用户</td></tr><tr><td>usage</td><td>服务器</td><td>没有权限</td></tr></tbody></table></figure><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2384" mdtype="fences">GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost' IDENTIFIED BY 'password'
</pre><p>为 u_yls用户分配只能查询 malu 库中的 emp 表，并且只能在本机登陆的权限。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2386" mdtype="fences">grant select ON malu.emp to 'u_yls'@'localhost' IDENTIFIED by 'yls';
</pre><p>&nbsp;</p><p>每当调整权限后，通常需要执行以下语句刷新权限。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2389" mdtype="fences">FLUSH PRIVILEGES;
</pre><p>&nbsp;</p><p>删除用户：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2392" mdtype="fences">DROP USER username@localhost;
</pre><p>删除 u_yls 用户。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2394" mdtype="fences">drop user 'u_yls'@'localhost';
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2397' class='md-header-anchor '></a>b）可视化管理用户</h4><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2400' class='md-header-anchor '></a>c）导入与导出数据</h4><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2403' class='md-header-anchor '></a>d）分页查询</h4><p>&nbsp;</p><p><strong>MySQL 分页查询原则：</strong></p><ul><li>在 MySQL 数据库中使用 LIMIT 子句进行分页查询。</li><li>MySQL 分页中开始位置为 0。</li><li>分页子句在查询语句的最后侧。</li></ul><p>&nbsp;</p><p><strong>LIMIT子句：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2415" mdtype="fences">SELECT  投影列 FROM  表名 WHERE  条件 ORDER BY LIMIT  开始位置，查询数量;
</pre><p>查询雇员表中所有数据按 id 排序，实现分页查询，每次返回两条结果。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2417" mdtype="fences">select * from employees order by employees_id limit 0,2;
</pre><p>&nbsp;</p><p><strong>LIMIT OFFSET子句：</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2420" mdtype="fences">SELECT  投影列 FROM  表名 WHERE  条件 ORDER BY LIMIT  查询数量 OFFSET 开始位置;
</pre><p>查询雇员表中所有数据按 id 排序，使用 LIMIT OFFSET 实现分页查询，每次返回两条结果。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sql" contenteditable="false" cid="n2422" mdtype="fences">select * from employees order by employees_id limit 2 offset 4;
</pre><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n2425' class='md-header-anchor '></a>15，数据库范式与表关系</h3><p>&nbsp;</p><p>参考：</p><ul><li><a href='https://cloud.tencent.com/developer/article/2398012' target='_blank' class='url'>https://cloud.tencent.com/developer/article/2398012</a></li></ul><p>&nbsp;</p><h4><a name='header-n2432' class='md-header-anchor '></a>a）数据库范式简介</h4><p><strong>什么是范式（NF = NormalForm）</strong></p><ul><li>范式是符合某一种设计要求的总结</li></ul><p>&nbsp;</p><p><strong>在数据库中表的设计，必须保证其合理性</strong></p><ul><li>数据库表的设计关系整个系统的架构，关系到后续的开发效率和运行效率</li></ul><p>&nbsp;</p><p><strong>如何设计合理的数据库表</strong></p><ul><li>结构合理</li><li>冗余数据少</li><li>尽量避免插入删除修改异常</li><li>遵循一定的规则，在关系型数据库中这种规则就称为范式</li></ul><p>&nbsp;</p><p><strong>关系型数据库有六种常见范式：</strong></p><ul><li>第一范式（1NF）</li><li>第二范式（2NF）</li><li>第三范式（3NF）</li><li>巴斯-科德范式（BCNF）</li><li>第四范式（4NF）</li><li>第五范式（5NF）</li></ul><p>&nbsp;</p><p><strong>各个范式是依次嵌套包含的：</strong></p><p>在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以此类推。</p><p><img src='./assets/1718259422748.png' alt='1718259422748' referrerPolicy='no-referrer' /></p><p>范式越高，设计质量越高，在现实设计中也越难实现，一般数据库设计，达到<strong>第三范式</strong>就足够了</p><p><strong>数据库范式中的概念</strong></p><ul><li><p>元组：可以理解为一张表中的每条记录，也就是每一行数据。</p></li><li><p>属性：可以看作是“表的一列”。</p><ul><li>主属性：在一个关系中，如一个属性是构成某一个候选关键字的属性集中的一个属性，则称它为主属性。例如：在关系——学生（学号，姓名，年龄，性别，班级）中，主属性是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li><li>非主属性：不包含在候选码中的属性称为非主属性，相对于主属性来定义的。</li></ul></li></ul><p>&nbsp;</p><h4><a name='header-n2485' class='md-header-anchor '></a>b）第一范式（保证都列都是原子性）</h4><p>&nbsp;</p><p>第一范式：</p><ul><li>最基本的范式，是其他范式的基础</li><li>数据库表每列都是不可分割的基本数据项，同一列中不能有多个值，确保每列保持原子性</li></ul><p><img src='./assets/1718259624155.png' alt='1718259624155' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>根据第一范式设计表：</strong></p><p><img src='./assets/1718259678716.png' alt='1718259678716' referrerPolicy='no-referrer' /></p><p><strong>第一范式存在的问题：</strong>数据冗余</p><p><img src='./assets/1718259740562.png' alt='1718259740562' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>第一范式存在的问题：</strong>插入数据异常</p><p><img src='./assets/1718259794711.png' alt='1718259794711' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>第一范式存在的问题：</strong>修改数据复杂</p><p><img src='./assets/1718259846202.png' alt='1718259846202' referrerPolicy='no-referrer' /></p><p><strong>第一范式存在的问题：</strong>删除异常</p><p><img src='./assets/1718259870397.png' alt='1718259870397' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n2508' class='md-header-anchor '></a>c）第二范式（确保数据库表中的每一列都和主键相关）</h4><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p><img src='./assets/1718259971370.png' alt='1718259971370' referrerPolicy='no-referrer' /></p><p><img src='./assets/1718259997770.png' alt='1718259997770' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><img src='./assets/1718260067039.png' alt='1718260067039' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>根据第二范式设计表：</strong></p><p><img src='./assets/1718260120414.png' alt='1718260120414' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>第二范式存在的问题：</strong>插入异常</p><p><img src='./assets/1718260197087.png' alt='1718260197087' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>第二范式存在的问题：</strong>删除异常</p><p><img src='./assets/1718260206170.png' alt='1718260206170' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2526' class='md-header-anchor '></a>d）第三范式（每一列数据都和主键直接相关）</h4><ul><li>必须满足第二范式</li><li>确保数据表中的每一列数据都和<strong>主键直接相关</strong>，而不能间接相关</li></ul><p><img src='./assets/1718260380703.png' alt='1718260380703' referrerPolicy='no-referrer' /></p><p><img src='./assets/1718260449628.png' alt='1718260449628' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><strong>根据第三范式设计表：</strong></p><p><img src='./assets/1718260496643.png' alt='1718260496643' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2541' class='md-header-anchor '></a>e）数据库范式总结</h4><p>&nbsp;</p><p>数据库设计范式<strong>优点</strong>：</p><ul><li><p>结构合理</p></li><li><p>冗余较小</p></li><li><p>尽量避免插入删除修改异常</p><p>&nbsp;</p></li></ul><p>数据库设计范式<strong>缺点</strong>：</p><ul><li>性能降低，多表查询比单表查询速度慢</li></ul><p>&nbsp;</p><p>在实际设计中，要整体遵循范式理论。如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能</p><p>&nbsp;</p><p><strong>总结：</strong></p><ul><li><p>第一范式（1NF）：字段不能再分</p></li><li><p>第二范式（2NF）：不存在部分依赖</p><p><img src='assets/1718271020444.png' alt='1718271020444' referrerPolicy='no-referrer' /></p></li><li><p>第三范式（3NF）：不存在间接依赖</p><p><img src='assets/1718271081791.png' alt='1718271081791' referrerPolicy='no-referrer' /></p></li></ul><p>&nbsp;</p><p>使用范式可以减少冗余，但是会降低性能。特定表的的设计可以违反第三范式，增加冗余提高性能</p><p>&nbsp;</p><h4><a name='header-n2572' class='md-header-anchor '></a>f）表关系</h4><p>设计关系数据库的一个重要部分是将数据元素划分为相关的表，我们可以根据数据本身的关联性，将不同表之间的数据聚合在一起。无论在表与表之间建立了什么样的关系，决定数据之间是否有关系的不是表，而是数据本身。</p><p>&nbsp;</p><p>表与表之存在三种关系（relation），即一对一，一对多，多对多关系。</p><ul><li><strong>一对一</strong>（one-to-one）：一种对象与另一种对象是一一对应关系，比如一个学生只能在一个班级里。</li><li><strong>一对多</strong>（one-to-many）： 一种对象可以属于另一种对象的多个实例，比如一个班级里有很多学生。</li><li><strong>多对多</strong>（many-to-many）：两种对象彼此都是&quot;一对多&quot;关系，比如一个歌单里包含多首歌，同时一首歌可以属于多个歌单。</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2587' class='md-header-anchor '></a>g）一对多关系</h4><p><img src='assets/1718271419436.png' alt='1718271419436' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>一对多关系是建立在两张表之间的关系。一个表中的一条数据可以对应另一个表中的多条数据。可以添加外键约束保证数据的参照完整性，外键永远在多方。外键允许重复，允许含有空值。如果添加的外键约束，那么删除数据时，一定是先删除有外键一方的数据。</p><p>&nbsp;</p><p><img src='assets/1718271526070.png' alt='1718271526070' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><img src='assets/1718271549139.png' alt='1718271549139' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><img src='assets/1718271589056.png' alt='1718271589056' referrerPolicy='no-referrer' /></p><p><img src='assets/1718271651279.png' alt='1718271651279' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2603' class='md-header-anchor '></a>h）一对一关系</h4><p>一种对象与另一种对象是一一对应关系。</p><p><img src='assets/1718271771926.png' alt='1718271771926' referrerPolicy='no-referrer' /></p><p>一对一关系是建立在一对多的基础之上，一个表中的一条数据只能对应另一个表中的一条数据。可以添加外键约束保证数据的参照完整性，外键可以在任何一方，需要让外键具备唯 一约束。</p><p><img src='assets/1718271803442.png' alt='1718271803442' referrerPolicy='no-referrer' /></p><p><img src='assets/1718271820084.png' alt='1718271820084' referrerPolicy='no-referrer' /></p><p><img src='assets/1718271842293.png' alt='1718271842293' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>如果添加的外键约束，那么删除数据时，一定是先删除有外键一方的数据。</p><p>&nbsp;</p><h4><a name='header-n2613' class='md-header-anchor '></a>i）多对多关系</h4><p>需要建立一个中间表，中间表里建立两个列，然后需要用这两个列作为这个表的联合主键，然后每个列在作为外键参照各自的表的主键。</p><p><img src='assets/1718271956224.png' alt='1718271956224' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p><img src='assets/1718272023852.png' alt='1718272023852' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272044056.png' alt='1718272044056' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272092811.png' alt='1718272092811' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272121403.png' alt='1718272121403' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272139261.png' alt='1718272139261' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272144963.png' alt='1718272144963' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272161390.png' alt='1718272161390' referrerPolicy='no-referrer' /></p><p><img src='assets/1718272191153.png' alt='1718272191153' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>注意：</strong></p><ul><li>存数据：先两侧，再中间表。</li><li>删数据：先中间表（即有外键的表），再两侧。</li></ul><p>&nbsp;</p><h3><a name='header-n2634' class='md-header-anchor '></a>16，练习</h3><p>班级表：classes</p><figure><table><thead><tr><th>clsid</th><th>clsname</th></tr></thead><tbody><tr><td>1</td><td>超越班</td></tr><tr><td>2</td><td>火箭班</td></tr><tr><td>3</td><td>先驱班</td></tr></tbody></table></figure><p>&nbsp;</p><p>学生表：student</p><figure><table><thead><tr><th>sid</th><th>sname</th><th>sgender</th><th>sbrithday</th><th>clsid</th></tr></thead><tbody><tr><td>1</td><td>张三丰</td><td>男</td><td>1890-01-01</td><td>1</td></tr><tr><td>2</td><td>张无忌</td><td>男</td><td>1992-12-12</td><td>1</td></tr><tr><td>3</td><td>周芷若</td><td>女</td><td>1992-10-10</td><td>2</td></tr><tr><td>4</td><td>赵敏</td><td>女</td><td>1992-07-07</td><td>2</td></tr><tr><td>5</td><td>蛛儿</td><td>女</td><td>1994-06-06</td><td>3</td></tr><tr><td>6</td><td>韦一笑</td><td>男</td><td>1972-08-19</td><td>3</td></tr></tbody></table></figure><p>&nbsp;</p><p>老师表：teachers</p><figure><table><thead><tr><th>tid</th><th>tname</th></tr></thead><tbody><tr><td>1</td><td>Malu</td></tr><tr><td>2</td><td>Admin</td></tr><tr><td>3</td><td>Wangcai</td></tr></tbody></table></figure><p>&nbsp;</p><p>课程表：course</p><figure><table><thead><tr><th>cid</th><th>cname</th><th>tid</th></tr></thead><tbody><tr><td>1</td><td>Java</td><td>1</td></tr><tr><td>2</td><td>Python</td><td>2</td></tr><tr><td>3</td><td>前端</td><td>3</td></tr></tbody></table></figure><p>&nbsp;</p><p>成绩表score</p><figure><table><thead><tr><th>sid</th><th>student_id</th><th>course_id</th><th>Number</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>90</td></tr><tr><td>2</td><td>1</td><td>2</td><td>80</td></tr><tr><td>3</td><td>1</td><td>3</td><td>60</td></tr><tr><td>4</td><td>2</td><td>1</td><td>100</td></tr><tr><td>5</td><td>2</td><td>3</td><td>100</td></tr><tr><td>6</td><td>3</td><td>2</td><td>100</td></tr><tr><td>7</td><td>4</td><td>3</td><td>59</td></tr><tr><td>8</td><td>5</td><td>1</td><td>40</td></tr><tr><td>9</td><td>5</td><td>2</td><td>60</td></tr><tr><td>10</td><td>6</td><td>2</td><td>60</td></tr><tr><td>11</td><td>6</td><td>3</td><td>80</td></tr></tbody></table></figure><p>&nbsp;</p><p>练习：</p><ul><li><p>创建表classes，clsid设置为主键并自增</p></li><li><p>创建表student，sid设置为主键并自增，clsid设置为外键，参照表为classes表，参照列为clsid，外键名为pk_cls</p></li><li><p>创建表course, 为course添加tid的外键约束，参照表为teacher表，外键名为pk_tea ， cid为主键并自增</p></li><li><p>创建表teacher，tid为主键并自增</p></li><li><p>创建表score，sid为主键并自增，student_id为外键，参照表student，参照列为sid，外键名自定义，coursed_id为外键，参照表为course，参照列为cid，外键名自定义。</p></li><li><p>学生表添加三条数据：</p><p><img src='./assets/1718180634297.png' alt='1718180634297' referrerPolicy='no-referrer' /></p></li><li><p>&nbsp;</p></li></ul><p>&nbsp;</p><p>&nbsp;</p></div>
</body>
</html>