---
title: 02-koa
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - node
categories:
 - node
---

## 一，koa框架

### 1，koa框架介绍

官方文档：https://koa.bootcss.com/

![1708330620056](./assets/1708330620056.png)

Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。



使用步骤：

- 创建文件夹 studyKoa
- 进入文件夹，生成项目配置文件 npm init -y
- 安装koa: npm i koa@2.13.4 -S
- 在studyKoa文件夹下，创建 01-搭建koa服务器.js



操作如下：

![1708330848967](./assets/1708330848967.png)

创建一台服务器：

```js
const Koa = require('koa');
const app = new Koa();

// app.use表示使用中间件
app.use(async ctx => {
  ctx.body = 'Hello World';
});

app.listen(3000);
```



测试之：

![1708331068668](./assets/1708331068668.png)





### 2，中间件



写代码演示两个中间件，如下：

```js
const Koa = require('koa');
const app = new Koa();

app.use(async (ctx,next) => {
    console.log(1)
    // 上一个中间件不调用next,不会走下一个中间件
    next();
});

app.use(async (ctx,next) => {
  ctx.body = 'Hello World';
});

app.listen(3000);
```



![1708331314767](./assets/1708331314767.png)





看如下代码，为什么结果是 1 2 3，如下：

![1708331452504](./assets/1708331452504.png)



在koa中，中间的执行流程是遵循洋葱模型，如下：

![1708331495510](./assets/1708331495510.png)



看一下，官方代码：

```js
const Koa = require('koa');
const app = new Koa();

// logger  日志中间件
app.use(async (ctx, next) => {
  console.log(1)
  await next();
  console.log(5)
  const rt = ctx.response.get('X-Response-Time');
  console.log(`${ctx.method} ${ctx.url} - ${rt}`);
});

// x-response-time  计算当前请求所消耗的时间
app.use(async (ctx, next) => {
  const start = Date.now();
  console.log(2)
  await next();
  console.log(4)
  const ms = Date.now() - start;
  ctx.set('X-Response-Time', `${ms}ms`);
});

// response
app.use(async ctx => {
  console.log(3)
  ctx.body = 'Hello World';
});

app.listen(3000);
```

![1708331996713](./assets/1708331996713.png)



### 3，错误监听



 每次修改了服务器代码，都需要重新启动服务器，为了方便，可以全局安装nodemon。安装之：

```shell
npm i nodemon -g
```

![1708332259712](./assets/1708332259712.png)



后面再启动服务器，通过nodemon这个工具来启动，如下：

![1708332398566](./assets/1708332398566.png)





添加error全局事件侦听器，如下：

```js
const Koa = require('koa');
const app = new Koa();

app.use(async ctx => {
    throw new Error("未知错误~~~~")
});

// 全局错误处理  目前的处理仅仅是后台打印
app.on("error",err=>{
    console.log('全局错误处理', err.message)
})

app.listen(3000);
```



![1708332565854](./assets/1708332565854.png)





### 4，手写错误处理中间件（给客户端提示）



现在没有提示：

![1708332684841](./assets/1708332684841.png)

写一个中间件，给出提示：

```js
const Koa = require('koa');
const app = new Koa();

// 错误处理中间件
app.use(async (ctx,next) => {
    try{
        await next();
    }catch(error){
        // console.log(error.statusCode)
        // console.log(error.status)
        // 给⽤户显示状态码
        ctx.status = error.statusCode || error.status || 500;
        // 如果是ajax请求,返回的是json错误数据
        ctx.type = "json"
        ctx.body = {
            ok:0,
            message:error.message
        }
    }
})

app.use(async ctx => {
    throw new Error("未知错误~~~~")
});

// 全局错误处理 后台打印
app.on("error",err=>{
    console.log('全局错误处理', err.message)
})

app.listen(3000);
```

![1708333137427](./assets/1708333137427.png)



### 5，日志中间件之koa-logger

**安装：** npm i koa-logger@3.2.1

![1708333243009](./assets/1708333243009.png)

上代码演示：

```js
const Koa = require('koa');
const logger = require('koa-logger')

const app = new Koa();

// 使用中间件
app.use(logger())

app.use(async ctx => {
    ctx.body = "hello koa~"
});

// 全局错误处理 后台打印
app.on("error",err=>{
    console.log('全局错误处理', err.message)
})

app.listen(3000);
```

![1708333482636](./assets/1708333482636.png)



### 6，第三方错误处理中间件

**安装：** npm i koa-onerror@4.2.0

![1708333593507](./assets/1708333593507.png)



使用之：

```js
const Koa = require('koa');
const logger = require('koa-logger')
const onerror = require('koa-onerror')

const app = new Koa();

// 使用中间件
app.use(logger())
onerror(app)

app.use(async ctx => {
    // const err = new Error("未授权");
    // err.status = 401;
    // throw err;
    ctx.throw(401,"未授权")
});

// 全局错误处理 后台打印
app.on("error",err=>{
    console.log('全局错误处理', err.message)
})

app.listen(3000);
```



![1708333866041](./assets/1708333866041.png)



### 7，路由中间件



安装： npm i @koa/router@10.1.1

![1708392126096](./assets/1708392126096.png)



创建router文件夹，在router文件夹下，创建user.js，再创建cart.js，如下：

![1708392206253](./assets/1708392206253.png)



用户模块路由，如下：

```js
// 路由就是一种特殊的中间件

const Router = require("@koa/router")
const router = new Router();
router.prefix("/user")

router.get("/",(ctx,next)=>{
    ctx.body = "用户管理"
})

module.exports = router;
```



购物车模块路由，如下：

```js
const Router = require("@koa/router")
const router = new Router();
router.prefix("/cart")

router.get("/",(ctx,next)=>{
    ctx.body = "购物车管理"
})

module.exports = router;
```



在入口中，导入上面的两个路由，如下：

```js
const Koa = require('koa');
const user = require("./router/user")
const cart = require("./router/cart")

const app = new Koa();

// 注册路由
app.use(user.routes())
user.allowedMethods();
app.use(cart.routes())
cart.allowedMethods();

app.listen(3000);
```



测试之：

![1708392622421](./assets/1708392622421.png)



### 8，接收get请求参数



get请求有两种形式把数据传递给后端： 

- 访问http://localhost:3000/user/3/1
- 访问http://localhost:3000/user?name=wc&age=18



代码演示：

```js
const Router = require("@koa/router")
const router = new Router();
router.prefix("/user")

// http://localhost:3000/user?name=wc&age=18
router.get("/",(ctx,next)=>{
    // 得到查询字符串参数
    console.log(ctx.query.name, ctx.query.age)
    ctx.body = "用户管理"
})

// 访问http://localhost:3000/user/3/1
router.get("/:id/:pid",(ctx,next)=>{
    // 得到路径参数
    console.log(ctx.params.id, ctx.params.pid);
    ctx.body = "用户管理"
})

module.exports = router;
```



效果如下：

![1708393037691](./assets/1708393037691.png)



### 9，接收post请求参数

安装：npm i koa-bodyparser@4.3.0

![1708393105335](./assets/1708393105335.png)



使用之，如下：

```js
const Koa = require('koa');
const user = require("./router/user")
const cart = require("./router/cart")
const bodyparser = require("koa-bodyparser")

const app = new Koa();

app.use(bodyparser())

// 注册路由
app.use(user.routes())
user.allowedMethods();
app.use(cart.routes())
cart.allowedMethods();

app.listen(3000);
```



接收前端post请求传递的数据，如下：

```js
const Router = require("@koa/router")
const router = new Router();
router.prefix("/cart")

router.post("/",(ctx,next)=>{
    // 接收前端post传递过来的数据
    console.log(ctx.request.body)
    ctx.body = {
        "ok":1
    }
})

module.exports = router;
```



测试之：

![1708393483308](./assets/1708393483308.png)



前端给后端传递一个json，如下：

![1708393569731](./assets/1708393569731.png)





### 10，重定向

定义登录注册路由，如下：

```js
const Router = require("@koa/router")
const router = new Router();

router.get("/login",(ctx,next)=>{
    // xxxxx

    // 当访问/login  重定向到/reg
    ctx.redirect("/reg")
    ctx.status = 301; // 301 表示重定向
})

router.get("/reg",(ctx,next)=>{
    ctx.body = "注册页面~"
})

module.exports = router;
```



注册路由：

```js
const Koa = require('koa');
const user = require("./router/user")
const cart = require("./router/cart")
const loginReg = require("./router/loginReg")
const bodyparser = require("koa-bodyparser")

const app = new Koa();

app.use(bodyparser())

// 注册路由
app.use(user.routes())
user.allowedMethods();
app.use(cart.routes())
cart.allowedMethods();
app.use(loginReg.routes())
loginReg.allowedMethods();

app.listen(3000);
```



测试之：

![1708393894936](./assets/1708393894936.png)





### 11，托管静态资源

安装：npm i koa-static@5.0.0

![1708394003351](./assets/1708394003351.png)



准备静态资源：

![1708394152400](./assets/1708394152400.png)



配置托管静态资源：

```js
const Koa = require('koa');
const static = require('koa-static');
const app = new Koa();

//配置静态web服务的中间件
//app.use(static('./public'));
app.use(static(__dirname+'/public')); // __dirname是当前文件夹

app.listen(3000);
```



测试：

![1708394366967](./assets/1708394366967.png)



### 12，解决跨域

**安装：** npm i koa2-cors



使用之：

```js
const koa = require('koa');
const cors = require('koa2-cors');
const app = new koa();
app.use(cors());
```





### 13，文件上传

**安装：** npm i koa-multer@1.0.2

![1708394619685](./assets/1708394619685.png)



创建服务器，如下：

![1708394838563](./assets/1708394838563.png)



测试之，如下：

![1708394929637](./assets/1708394929637.png)





实现文件上传，如下：

```js
const Router = require("@koa/router")
const multer=require("koa-multer")

let storage=multer.diskStorage({
    // 文件保存的路径
    destination:function(req,file,cb){
        cb(null,"static/upload")
    },
    // 修改文件名称   z3  78f8dsfgasd8fg8asdgasdf.png  l4  fsadf7gas0dg7asdgasd.png
    filename:function(req,file,cb){  // logo.png  ['logo','png']    68568756767.png
        var fileFormat = (file.originalname).split(".");
        cb(null,Date.now() + "." + fileFormat[fileFormat.length - 1]);
    }
})
let upload=multer({storage})

const router = new Router();

router.post("/upload",upload.single("avatar"),(ctx,next)=>{
    console.log(ctx.req.file.filename)
    ctx.body = {
        ok:1
    }
})

module.exports = router;
```



测试：

![1708396911370](./assets/1708396911370.png)





### 14，表单验证

**安装：** npm i koa-bouncer@6.0.0

![1708396987722](./assets/1708396987722.png)

创建一个新的路由，如下：

![1708397191463](./assets/1708397191463.png)





后端接收数据，如下：

![1708397308739](./assets/1708397308739.png)



开始进行校验，如下：

![1708397457576](./assets/1708397457576.png)



校验代码如下：

```js
const Router = require("@koa/router")
const bouncer = require('koa-bouncer')
const router = new Router();
router.prefix("/user")

// 表单验证
router.post("/",async (ctx,next)=>{
    console.log(ctx.request.body)  // 获取前端传递过来的数据

    try{
        // ctx.validateBody('username').required('用户名是必须传的~').isString().isLength(3, 15, 'Username must be 3-15 chars');

        ctx
            .validateBody('uname')
            .required('用户名是必须的')
            .isString()
            .trim()
            .isLength(4, 8, '用户名必须是4~8位')
        ctx
            .validateBody('email')
            .optional()
            .isString()
            .trim()
            .isEmail('非法的邮箱格式')
        ctx
            .validateBody('pwd1')
            .required('密码是必填项')
            .isString()
            .trim()
            .isLength(6, 16, '密码必须是6~16位')
        ctx
            .validateBody('pwd2')
            .required('密码是必填项')
            .isString()
            .trim()
            .eq(ctx.vals.pwd1, '两次密码不一致')

        console.log(ctx.vals)


        ctx.body = {
            code:1
        }
    }catch (error) {
        if(error instanceof bouncer.ValidationError){
            ctx.status = 400
            ctx.body = {
                code: 400,
                message: '校验失败:' + error.message,
            }
            return
        }
    }
})

module.exports = router;
```





### 15，图形验证码



**安装：** npm i trek-captcha@0.4.0

![1708398373252](./assets/1708398373252.png)



创建路由，如下：

![1708398450875](./assets/1708398450875.png)

生成验证码：

```js
const Router = require("@koa/router")
const captcha = require("trek-captcha")
const router = new Router();
router.prefix("/login")

router.get("/captcha",async (ctx,next)=>{
    const {
        token,
        buffer
    } = await captcha({size:4})
    ctx.body = buffer;
})

module.exports = router;
```



测试：

![1708398651757](./assets/1708398651757.png)



写一个Img标签测试之，如下：

![1708398746471](./assets/1708398746471.png)







## 二，鉴权

常见的鉴权方式：

- Session/Cookie
- Token+jwt
- OAuth



### 1，Cookie



什么是会话：

- https://yujingbo1023.github.io/javablog/public/blogs/javaweb/09.html



Http协议是⼀个⽆状态的协议，服务器不会知道到底是哪⼀台浏览器访问了它，因此需要⼀个标识⽤来让服务器区分不同的浏览器。cookie就是这个管理服务器与客户端之间状态的标识。Cookie原理：浏览器第一次向服务器发送请求，服务器给给浏览器种植一个cookie，通过响应头来种植（Set-Cookie），浏览器就可以收到Cookie，并存储到浏览器中。后面浏览器再发出请求时，会自动带上这个Cookie，通过请求头的形式带上Cookie，服务器可以接收到的Cookie，就可以判断一个这个请求是来自于哪个浏览器。



cookie的基本使用，代码演示：

```js
const Koa = require('koa');
const app = new Koa();

app.use(async ctx => {

    // 第一种访问服务器时，服务器就可以给你种植一个cookie（靠响应头）
    // 后面浏览器再请求此服务器，会自动带个cookie（靠请求头）

    // 默认情况下，服务器给浏览器种植的cookie，是存储在浏览器的内存中的
    // 当会话结束了，cookie就消失了
    ctx.cookies.set("username","malu");

    ctx.body = 'Hello World';
});

app.listen(3000);
```



浏览器测试之：

![1708480042949](./assets/1708480042949.png)

![1708480061643](./assets/1708480061643.png)



当会话结束了，浏览器中的cookie就没有了，如下：

![1708480192690](./assets/1708480192690.png)





可以设置cookie的生命周期，如下：

```js
const Koa = require('koa');
const app = new Koa();

app.use(async ctx => {

    // 第一种访问服务器时，服务器就可以给你种植一个cookie（靠响应头）
    // 后面浏览器再请求此服务器，会自动带个cookie（靠请求头）

    // 默认情况下，服务器给浏览器种植的cookie，是存储在浏览器的内存中的
    // 当会话结束了，cookie就消失了
    // ctx.cookies.set("username","malu");

    // 活7天  设置cookie的生存时间
    ctx.cookies.set("username","malu",{
        maxAge:60000 * 60 * 24 * 7
    });

    ctx.body = 'Hello World';
});

app.listen(3000);
```



浏览器测试之，如下：

![1708480417084](./assets/1708480417084.png)

![1708480480338](./assets/1708480480338.png)



后面浏览器再向此服务器发请求时，会自动带个cookie，如下：

![1708480562932](./assets/1708480562932.png)



服务器端，就可以获取cookie，如下：

```js
const Koa = require('koa');
const app = new Koa();

app.use(async ctx => {

    // 第一种访问服务器时，服务器就可以给你种植一个cookie（靠响应头）
    // 后面浏览器再请求此服务器，会自动带个cookie（靠请求头）

    // 默认情况下，服务器给浏览器种植的cookie，是存储在浏览器的内存中的
    // 当会话结束了，cookie就消失了
    // ctx.cookies.set("username","malu");

    // 活7天  设置cookie的生存时间
    // ctx.cookies.set("username","malu",{
    //     maxAge:60000 * 60 * 24 * 7
    // });

    // 获取浏览器带过来的cookie
    console.log("获取cookie:", ctx.cookies.get("usrename"));

    ctx.body = 'Hello World';
});

app.listen(3000);
```



浏览器测试之，如下：

![1708480671533](./assets/1708480671533.png)





### 2，记录上一次的访问时间

直接上代码，如下：

```js
const Koa = require('koa');
const app = new Koa();

app.use(async ctx => {

    // 获取cookie  第1次获取不到，值是und
    let last = ctx.cookies.get("last")

    // 第1次访问服务器  需要种植一个cookie
    ctx.cookies.set("last",new Date().toLocaleString(),{
        maxAge:60000 * 60 * 24 * 356 * 10
    });

    if(last){
        ctx.body = `你上一次访问的时间是:${last}`
    }else{
        // 第1次访问
        ctx.body = `这是你第1次访问本网站`
    }
});

app.listen(3000);
```



浏览器测试：

![1708481077708](./assets/1708481077708.png)



### 3，Session

![1708481455201](./assets/1708481455201.png)



session是服务器内部的一片空间，cookie是把数据存储到浏览器端，session是把数据存储在服务器的。原理：

1. 服务器在接受客户端⾸次访问时在服务器端创建seesion，然后保存seesion(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使⽤后者)，然后给这个session⽣成⼀个唯⼀的标识字符串,然后在响应头中种下这个唯⼀标识字符串。
2. 签名。这⼀步通过秘钥对sid进⾏签名处理，避免客户端修改sid。(⾮必需步骤)
3. 浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的 请求头中会带上该域名下的cookie信息。
4. 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法



安装：npm i koa-session@6.2.0

![1708481674925](./assets/1708481674925.png)





基于session实现网站访问次数统计，代码如下：

```js
const Koa = require('koa');
const session = require("koa-session");

const app = new Koa();

// keys作用：用来对cookie进行签名
app.keys = ['session secret', 'anthor secret']

const SESSON_CONFIG = {
    key: 'sid', //设置cookie的key名字
    maxAge: 86400000, //有效期，默认是一天
    httpOnly: true, //仅服务端修改
    signed: true, //签名cookie
}

app.use(session(SESSON_CONFIG, app));

app.use(async ctx => {
    let n = ctx.session.count || 0
    ctx.session.count = ++n;
    ctx.body = '第' + n + '次访问';
});

app.listen(3000);
```



浏览器测试之，如下：

![1708482152137](./assets/1708482152137.png)



### 4，基于session的用户鉴权



实现三个接口，如下：

```js
const Router = require("@koa/router")
const router = new Router();
router.prefix("/user")

// 登录接口
router.post("/login",(ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '登录成功'
    }
})
// 登出接口
router.post("/logout",(ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '退出系统'
    }
})
// 获取用户信息
router.get("/getUserInfo",(ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '获取数据成功'
    }
})

module.exports = router;
```



创建服务器，如下：

```js
const Koa = require('koa');
const session = require("koa-session");
const bodyparser = require("koa-bodyparser")
const users = require("./17-user")

const app = new Koa();

// 配置bodyparser
app.use(bodyparser())

// 配置session
app.keys = ['session secret', 'anthor secret']
const SESSON_CONFIG = {
    key: 'sid', //设置cookie的key名字
    maxAge: 86400000, //有效期，默认是一天
    httpOnly: true, //仅服务端修改
    signed: true, //签名cookie
}
app.use(session(SESSON_CONFIG, app));

// 注册路由
app.use(users.routes())
users.allowedMethods()

app.listen(3000,()=>{
    console.log("3000端口被监听了~")
});
```



登录时，需要把用户名和密码传递给服务器，服务器就可以得到用户名和密码，服务器就可以把用户名和密码保存到session中，实现代码如下：

```js
// 登录接口
router.post("/login",(ctx,next)=>{
    // 得到前端传递过来的用户名和密码
    const {body} = ctx.request;
    console.log(body)
    // 把用户名存储到session中
    ctx.session.userInfo = body.user;
    ctx.body = {
        ok: 1,
        message: '登录成功'
    }
})
```



测试：

![1708484348074](./assets/1708484348074.png)



当退出登录时，需要把session中的数据删除了，如下：

```js
// 登出接口
router.post("/logout",(ctx,next)=>{
    console.log(ctx.session.userInfo)
    if(ctx.session.userInfo){
        delete ctx.session.userInfo
    }
    ctx.body = {
        ok: 1,
        message: '退出系统'
    }
})
```



测试如下：

![1708484512835](./assets/1708484512835.png)



获取用户信息，需要从session中获取用户信息，如下：

```js
// 获取用户信息
router.get("/getUserInfo",(ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '获取数据成功',
        userInfo: ctx.session.userInfo
    }
})
```



测试如下：

![1708484660324](./assets/1708484660324.png)



创建一个auth.js，些文件是专门用于鉴权的，如下：

```js
module.exports = async (ctx, next) => {
    if(ctx.session.userInfo){
        await next();
    }else{
        ctx.body = {
            code: 401,
            message: '未授权',
        }
    }
}
```



![1708484804865](./assets/1708484804865.png)



哪些接口需要鉴权，就使用上面的中间件，如下：

```js
// 获取用户信息
// 后面哪里接口，需要身份认证，就添加require("./17-auth")
router.get("/getUserInfo", require("./17-auth") ,(ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '获取数据成功',
        userInfo: ctx.session.userInfo
    }
})
```



测试如下：

![1708484987415](./assets/1708484987415.png)





### 5，Token+JWT认证

![1708485058837](./assets/1708485058837.png)



需要安装两个包：

- npm i koa-jwt@4.0.3    说明：jwt中间件
- npm i jsonwebtoken@8.5.1    说明：⽤于⽣成token下发给浏览器, 在koa2以后的版本不再提供jsonwebtoken的⽅法, 所以需要另外安装

![1708485287858](./assets/1708485287858.png)





创建服务器如下：

```js
const Koa = require('koa')
const users = require('./18-user')
const bodyParser = require('koa-bodyparser')
const app = new Koa()

app.use(bodyParser());

// 注册路由
app.use(users.routes())
users.allowedMethods()

app.listen(3000, () => {
    console.log('3000端口被监听了~~')
})
```



创建接口，如下：

```js
const Router = require("@koa/router")
const jwt = require('jsonwebtoken');
const router = new Router();
router.prefix("/user")

const secret = 'this is a scret';

router.post("/login",(ctx,next)=>{
    const {body} = ctx.request;
    // 获取前端传递的用户名
    const userInfo = body.userInfo; 
    ctx.body = {
        ok: 1,
        message: '登录成功',
        userInfo:userInfo,
        // 登录成功，响应token, 使用jwt模块生成一个令牌，把令牌返回给浏览器
        token: jwt.sign({
            data: userInfo,  // 说白了，就是把用户名加密到令牌中 令牌中就包含了用户名
            exp: '10h' //过期时间一分钟
        },secret)
    }
})
router.get("/getUserInfo" ,(ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '获取数据成功'
    }
})

module.exports = router;
```



测试登录接口，如下：

![1708485989328](./assets/1708485989328.png)





还有一个接口是获取用户信息，用户信息是存储在令牌中的，当调用获取用户令牌接口时，对令牌进行校验如下：

```js
router.get("/getUserInfo", jwtAuth({secret}), (ctx,next)=>{
    ctx.body = {
        ok: 1,
        message: '获取数据成功',
        userInfo: ctx.state.user.data
    }
})
```



测试如下：

![1708486404777](./assets/1708486404777.png)



## 三，MongoDB

### 1，MongoBD的安装

​	MongoDB和MySQL一样都是数据库, 都是存储数据的仓库, 不同的是MySQL是关系型数据库, 而MongoDB是非关系型数据库，MongoDB中的存储的数据是类JSON。



​	在MongoDB中，数据都是存储在集合中的，一个数据库，可以有很多的集合，在一个集合中，可以存储很多的文档，每一个文档，都是一条数据。

```

                          |--文档1
                |--集合1--|--文档2
        数据库--|          |--文档3
                |--集合2
                |--... ...

```



​	本质是一个软件，是服务端的软件，服务器上安装的软件，是对外提供服务器，如果服务器上安装了mongodb，那么这个服务器就可以对外提供数据库服务器。安装mongodb。安装过程，和安装其它普通软件是一样的。安装好之后，电脑上就有这个服务了：

![1708583458128](./assets/1708583458128.png)





还需要安装一个软件，这个软件可以连接mongodb，如下：

![1708583551992](./assets/1708583551992.png)



然后，就可以创建数据库，如下：

![1708583620096](./assets/1708583620096.png)



![1708583651330](./assets/1708583651330.png)





在一个数据库下，可以创建很多的集合，如下：

![1708583699149](./assets/1708583699149.png)

![1708583739995](./assets/1708583739995.png)



在一个集合下，可以创建很多的文档：

![1708583817923](./assets/1708583817923.png)

![1708583870237](./assets/1708583870237.png)

![1708583991136](./assets/1708583991136.png)



### 2，代码操作mongodb

创建一个文件夹：

![1708584718566](./assets/1708584718566.png)





安装依赖：

```json
"dependencies": {
    "mongodb": "^4.4.0",
    "mongoose": "^6.2.4",
    "sequelize": "^6.17.0"
}
```

![1708584809566](./assets/1708584809566.png)





#### a） 插入一条数据

```js
const MongoClient = require('mongodb').MongoClient;

(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    console.log("db:", db);
    // 获取集合
    const grade1 = db.collection('grade1')

    // 把文档插入到集合中
    await grade1.insertOne({
        name: "张三3",
        age: 20,
        hobby: ['吃饭', '睡觉', '打豆豆'],
        score: 90
    })

    // 关闭客户端的链接
    client.close()
})()
```



测试之，如下：

![1708585114274](./assets/1708585114274.png)





看一下数据库，是否有数据，如下：

![1708585172341](./assets/1708585172341.png)





#### b） 插入多条数据

```js
const MongoClient = require('mongodb').MongoClient

;
(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    // 获取集合
    const grade1 = db.collection('grade1')

    let r = await grade1.insertMany([{
            name: '张三',
            age: 20,
            hobby: ['吃饭', '睡觉', '打豆豆'],
            score: 90
        },
        {
            name: '李四',
            age: 40,
            hobby: ['妹子', '篮球'],
            score: 93
        },
        {
            name: '王五',
            age: 20,
            hobby: ['妹子', '睡觉'],
            score: 70
        },
        {
            name: '赵六',
            age: 16,
            hobby: ['妹子'],
            score: 50
        },
        {
            name: '张丽',
            age: 38,
            hobby: ['妹子'],
            score: 56
        },
        {
            name: '小红',
            age: 40,
            hobby: ['妹子'],
            score: 87
        },
        {
            name: '小马',
            age: 20,
            hobby: ['妹子'],
            score: 79
        },
        {
            name: '小王',
            age: 59,
            hobby: ['妹子'],
            score: 102
        },
        {
            name: '小黑',
            age: 16,
            hobby: ['妹子'],
            score: 60
        },
        {
            name: '小哥',
            age: 18,
            hobby: ['篮球'],
            score: 49
        },
    ])

    // 关闭客户端的链接
    client.close()
})()
```



测试如下：

![1708586117110](./assets/1708586117110.png)



#### c）查询数据

```js
const MongoClient = require('mongodb').MongoClient;
(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    // 获取集合
    const grade1 = db.collection('grade1')

    // findOne 查询某一条数据
    r = await grade1.findOne({
        name: '张三'
    })
    console.log("r:", r);

    // 关闭客户端的链接
    client.close()
})()
```



测试结果：

![1708586237745](./assets/1708586237745.png)



#### d）查询多条数据

```js
const MongoClient = require('mongodb').MongoClient;
(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    // 获取集合
    const grade1 = db.collection('grade1')

    // find查找所有的数据
    // r = await grade1.find().toArray()
    // console.log("r:", r);

    r = await grade1.find({
        name: '张三3'
    }).toArray()
    console.log("r:", r);

    // 关闭客户端的链接
    client.close()
})()
```



测试结果如下：

![1708586422620](./assets/1708586422620.png)



#### e）比较运算符

```js
const MongoClient = require('mongodb').MongoClient;
(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    // 获取集合
    const grade1 = db.collection('grade1')

    // 比较运算符
    r = await grade1.find({
        age: {
            // gt大于 lt小于  gte 大于等于  lte小于等于
            $gte: 20,
        },
    }).toArray()
    console.log("r:", r);

    // 关闭客户端的链接
    client.close()
})()
```





#### f）逻辑运算符

```js
const MongoClient = require('mongodb').MongoClient;

(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    // 获取集合
    const grade1 = db.collection('grade1')

    // 逻辑运算符  $and  $or $ne  $nor 不等于
    // 查询姓名叫王五并且年龄为20岁的人
    // r = await grade1.find({
    //     name: '王五',
    //     age: 200,
    // }).toArray()
    // console.log("r:", r);

    // -----------------------------

    // 查询姓名叫张三或者年龄为20岁的人
    // r = await grade1.find({
    //     $or: [
    //         {
    //             name: '张三',
    //         },
    //         {
    //             age: 20,
    //         },
    //     ],
    // }).toArray()
    // console.log("r:", r);

    // -----------------------------

    // // 查询年龄不大于20岁并且age不小于16的人员
    r = await grade1.find({
        $nor: [{
                age: {
                    $gt: 20,
                },
            },
            {
                age: {
                    $lt: 16,
                },
            },
        ],
    }).toArray()

    console.log("r:", r);

    // 关闭客户端的链接
    client.close()
})()
```



#### g）指定正则

```js
const MongoClient = require('mongodb').MongoClient;

(async function() {
    const client = new MongoClient('mongodb://127.0.0.1:27017')
    // 链接服务端
    await client.connect()
    console.log('链接成功')

    // 获取数据库 
    const db = client.db('school')
    // 获取集合
    const grade1 = db.collection('grade1')

    // 正则表达式
    r = await grade1.find({
        name: {
            $regex: /^张/,
        },
    }).toArray()

    console.log("r:", r);

    // 关闭客户端的链接
    client.close()
})()
```







### 3，mongoose











## 四，实战项目























