---
title: 03-Ajax串讲
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - node
categories:
 - node
---



## 一，Ajax串讲

客户端和服务器

- 客户端是向服务器发请求的。
  - 浏览器
  - postman
  - a标签     img标签   link标签   script标签   form标签....
  - ajax（异步局部刷新）
  - App
  - 小程序
  - ....
- 服务器主要接收客户端的请求，给出响应。通过node的框架叫express，提供服务器功能。



url

- 互联网上的资源都有一个url，通过url就可以定位到互联网上的某个资源。
- 协议名称 + 主机名称 + 端口号 + 路径 + 文件 + 查询所需的字符串 + HASH
- http://     baidu.com       8        /css/reset.css     ?a=1&b=2&c=3       #abc



http：

- HyperText Transfer Protocol 超文本传输协议。本质就是客户端和服务器之间沟通交流的规则。
- http请求（Request）：由客户端（浏览器）向服务器发出请求
- http响应（Response）：由服务器给出响应

![1713162394075](./assets/1713162394075.png)



http请求（请求报文）：

- 请求行
  - 请求方法  get  post  put .... 
  - url  不管是什么样的请求方式，都可以通过url传递参数
  - http协议版本
- 请求头
  -  Content-Type: text/plain, application/x-www-form-urlencoded, application/json, mutipul/form-data
- 请求体（请求正文），就是传给服务器的数据，post请求和put请求才有请求体，get请求没有请求体

![1713162463647](./assets/1713162463647.png)

![1713162717374](./assets/1713162717374.png)

http响应（响应报文）：

- 响应行
- 响应头
- 响应体（响应正文）



![1713162782934](./assets/1713162782934.png)







### 1，Ajax介绍

​	Ajax（Asynchronous JavaScript and XML，异步的 JavaScriopt 和 XML）是一种用于创建动态 Web 应用程序的技术，它使用 JavaScript 和 XML（或 JSON）等技术来实现异步数据传输和动态更新页面内容。

​	通过 Ajax 技术，可以在不刷新整个页面的情况下，向服务器发送请求，获取数据并进行处理，从而实现更加流畅、响应更快的 Web 应用程序。Ajax 技术最初是由 Google 推广的，现在已经成为了 Web 开发中不可或缺的一部分。

​	Ajax 的核心是 XMLHttpRequest 对象，它提供了在客户端浏览器和服务器之间发送 HTTP 请求和接收响应的功能。使用 XMLHttpRequest 对象，可以在不刷新整个页面的情况下更新部分页面内容，从而实现异步数据传输。除此之外，还可以使用 jQuery 等 JavaScript 库中提供的 Ajax 方法、Fetch API 等技术来实现 Ajax 功能。



搭建一下后端，创建一个文件夹，如下：

![1713144116832](./assets/1713144116832.png)



生成项目的配置文件：

![1713144183644](./assets/1713144183644.png)



后端用到的依赖：

![1713144262434](./assets/1713144262434.png)

```json
"dependencies": {
    "body-parser": "^1.20.0",
    "express": "^4.18.1",
    "multer": "^1.4.5-lts.1"
}
```



创建一台服务器，如下：

![1713144583561](./assets/1713144583561.png)

```js
const express = require("express")
const path = require("path")

// 创建 express 实例
const app = express();


app.get("/demo01",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","01-ajax的基本使用.html"))
})

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



对应的html文件如下：

![1713144629149](./assets/1713144629149.png)



访问服务器：

![1713144608597](./assets/1713144608597.png)



接下来，说一下ajax的基本使用，再去写一点服务器代码：

![1713144996008](./assets/1713144996008.png)

```js
const express = require("express")
const path = require("path")

// 创建 express 实例
const app = express();


app.get("/demo01",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","01-ajax的基本使用.html"))
})

// 当访问getData路径时,服务器响应 hello ajax 0.2
// 服务器代码变了,需要重启服务器
app.get('/getData', (req, res) => {
    console.log('接收到请求');
    res.send('hello ajax ' + Math.random());
});

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



然后，使用ajax请求 /getData，如下：

![1713145332605](./assets/1713145332605.png)

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <h1>ajax的基本使用</h1>
    <hr>
    <button id="btn">点击发请求</button>

    <script>
        const btn = document.querySelector('#btn');

        btn.onclick = () => {
            // 1) 创建一个xhr对象
            const xhr = new XMLHttpRequest();

            // 2) 监听成功的响应(服务器成功响应了数据,就会触发load事件)
            xhr.onload = ()=>{
                console.log('成功接收到后端的响应！');
                // responseText 得到服务器给的响应
                console.log(xhr.responseText)
            }

            // 3) 设置请求
            //    第一个参数 请求方式   get  post  put  delete  head ....
            //    第二个参数 请求URL  http://127.0.0.1:3000/getData
            //               /getData   协议  IP  端口  不写  表示向当前页面所在的服务器发请求
            //    第三个参数 是否异步，默认异步
            xhr.open("get","http://127.0.0.1:3000/getData")

            // 4) 发出请求
            //      发请求时,可以给服务器传递参数  send(请求体)
            xhr.send();
        }
    </script>
</body>
</html>
```



浏览器中测试：

![1713145357675](./assets/1713145357675.png)

学习ajax，网络面板非常重要，带着大家分析一下：

![1713145773982](./assets/1713145773982.png)

![1713145802884](./assets/1713145802884.png)



可以把数据在页面上显示出来，如下：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        #box {
            margin-top: 20px;
            width: 600px;
            padding: 20px;
            min-height: 200px;
            border: 1px solid red;
        }
    </style>
</head>
<body>
    <h1>ajax的基本使用</h1>
    <hr>
    <button id="btn">点击发请求</button>
    <div id="box"></div>

    <script>
        const btn = document.querySelector('#btn');
        const box = document.querySelector('#box');

        btn.onclick = () => {
            // 1) 创建一个xhr对象
            const xhr = new XMLHttpRequest();

            // 2) 监听成功的响应(服务器成功响应了数据,就会触发load事件)
            xhr.onload = ()=>{
                console.log('成功接收到后端的响应！');
                // responseText 得到服务器给的响应
                console.log(xhr.responseText)
                box.innerHTML += xhr.responseText + "<br/>";
            }

            // 3) 设置请求
            //    第一个参数 请求方式   get  post  put  delete  head ....
            //    第二个参数 请求URL  http://127.0.0.1:3000/getData
            //               /getData   协议  IP  端口  不写  表示向当前页面所在的服务器发请求
            //    第三个参数 是否异步，默认异步
            xhr.open("get","http://127.0.0.1:3000/getData")

            // 4) 发出请求
            //      发请求时,可以给服务器传递参数  send(请求体)
            xhr.send();
        }
    </script>
</body>
</html>
```



测试如下：

![1713145948541](./assets/1713145948541.png)



### 2，通过url把数据扔给服务器

**任何的请求方式都可以通过url传参**

动了服务器代码，一定要重启服务器，才会生效。服务器代码：

![1713146175801](./assets/1713146175801.png)



```js
const express = require("express")
const path = require("path")

// 创建 express 实例
const app = express();


app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

app.get('/getData', (req, res) => {
    console.log('接收到 GET 请求：')
    console.log('url：', req.url);
    console.log('从url中提取数据:', req.query);
    console.log('');
    res.send('GET 方式提交成功！');
});

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



开始写ajax代码：

![1713146563319](./assets/1713146563319.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过url把数据扔给服务器</h1>
    <hr>
    <table>
        <tr>
            <td>用户名：</td>
            <td><input type="text" name="username" id="username"></td>
        </tr>
        <tr>
            <td>密码：</td>
            <td><input type="password" name="pwd" id="pwd"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <button id="btn">GET方式提交</button>
            </td>
        </tr>
    </table>
    <script>
        const btn = document.querySelector('#btn');
        const username = document.querySelector('#username');
        const pwd = document.querySelector('#pwd');

        const xhr = new XMLHttpRequest();
        xhr.onload = () => {
            alert(xhr.responseText);
        };

        btn.onclick = () => {
            // 拼接查询字符串
            const qs = `uername=${username.value}&pwd=${pwd.value}`
            xhr.open("get","/getData?"+qs)
            xhr.send();
        }
    </script>
</body>

</html>
```



在浏览器中测试：

![1713148222220](./assets/1713148222220.png)

![1713146676943](./assets/1713146676943.png)

![1713146760275](./assets/1713146760275.png)

![1713146933582](./assets/1713146933582.png)



![1713146981929](./assets/1713146981929.png)







### 3，通过请求体把数据扔给服务器



get请求只能通过url把数据扔给服务器，post，put请求可以不仅可以通过url把数据扔给服务器，也可以通过请求体把数据扔给服务器。把数据通过请求体扔给服务器，也是有多个格式的：

- text/plain
  - 默认的请求体类型，如果不设置请求头字段 Content-type，默认就是该种类型
  - 求体只要是字符串就可以，后端不会做任何处理
- application/x-www-form-urlencoded
  - 需要设置请求头 xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
  - 要求请求体是查询字符串，如 a=100&b=200
  - 点击提交按钮提交表单（非Ajax），如果 Method 是 Post，默认请求体内容就是 x-www-form-urlencoded
- application/json

  - 设置设置请求头 xhr.setRequestHeader('Content-type', 'application/json');

  - 要求请求体是 json 格式的字符串
- multipart/form-data





演示 text/plain，后端代码：

```js
// 导入模块
const path = require('path');
const express = require('express');
const bodyParser = require('body-parser');  // body-parser 专门用于接收请求体数据
const multer = require('multer');


// 创建 express 实例
const app = express();


// 挂载中间件处理请求体
app.use(bodyParser.text());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: false}));


app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

// req.body 就可以获取请求体中的数据   
// typeof req.body 查看接收到的数据是什么类型
// res.send('POST 方式提交成功！');  响应数据
// req.query 得到url传递的参数的
// req.headers['content-type']  得到请求头
app.post('/getData', (req, res) => {
    console.log('接收到 POST 请求：')
    console.log('URL中获取的信息：', req.query);
    console.log('请求体内容类型：', req.headers['content-type']);
    console.log('请求体中获取的信息：', req.body, typeof req.body);
    console.log('');
    res.send('POST 方式提交成功！');
});


app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



前端代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过url把数据扔给服务器</h1>
    <hr>
    <table>
        <tr>
            <td>用户名：</td>
            <td><input type="text" name="username" id="username"></td>
        </tr>
        <tr>
            <td>密码：</td>
            <td><input type="password" name="pwd" id="pwd"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <button id="btn">POST方式提交</button>
            </td>
        </tr>
    </table>
    <script>
        const btn = document.querySelector('#btn');
        const username = document.querySelector('#username');
        const pwd = document.querySelector('#pwd');

        const xhr = new XMLHttpRequest();
        xhr.onload = () => {
            alert(xhr.responseText);
        };

        btn.onclick = () => {
            // ?a=1&b=2 url 传参
            xhr.open("post","/getData?a=1&b=2")

            const qs = `uername=${username.value}&pwd=${pwd.value}`
            // send中写请求体  send(qs); 叫请求体传参
            xhr.send(qs);
        }
    </script>
</body>

</html>
```



浏览器效果：

![1713148774903](./assets/1713148774903.png)

![1713148864363](./assets/1713148864363.png)

![1713148918324](./assets/1713148918324.png)

![1713148937660](./assets/1713148937660.png)







演示 application/x-www-form-urlencoded，后端同上。



前端代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过url把数据扔给服务器</h1>
    <hr>
    <table>
        <tr>
            <td>用户名：</td>
            <td><input type="text" name="username" id="username"></td>
        </tr>
        <tr>
            <td>密码：</td>
            <td><input type="password" name="pwd" id="pwd"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <button id="btn">POST方式提交</button>
            </td>
        </tr>
    </table>
    <script>
        const btn = document.querySelector('#btn');
        const username = document.querySelector('#username');
        const pwd = document.querySelector('#pwd');

        const xhr = new XMLHttpRequest();
        xhr.onload = () => {
            alert(xhr.responseText);
        };

        btn.onclick = () => {
            // ?a=1&b=2 url 传参
            xhr.open("post","/getData?a=1&b=2")

            const qs = `uername=${username.value}&pwd=${pwd.value}`

            // 在发请求之前,设置请求头,设置的头,叫Content-Type
            // 请求头一定要在 open() 之后，send() 之前设置
            xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

            // send中写请求体  send(qs); 叫请求体传参
            xhr.send(qs);
        }
    </script>
</body>

</html>
```



浏览器效果：

![1713149195166](./assets/1713149195166.png)

![1713149242325](./assets/1713149242325.png)

![1713149342410](./assets/1713149342410.png)



演示 application/json，后端同上。



前端代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过url把数据扔给服务器</h1>
    <hr>
    <table>
        <tr>
            <td>用户名：</td>
            <td><input type="text" name="username" id="username"></td>
        </tr>
        <tr>
            <td>密码：</td>
            <td><input type="password" name="pwd" id="pwd"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <button id="btn">POST方式提交</button>
            </td>
        </tr>
    </table>
    <script>
        const btn = document.querySelector('#btn');
        const username = document.querySelector('#username');
        const pwd = document.querySelector('#pwd');

        const xhr = new XMLHttpRequest();
        xhr.onload = () => {
            alert(xhr.responseText);
        };

        btn.onclick = () => {
            // ?a=1&b=2 url 传参
            xhr.open("post","/getData?a=1&b=2")

            // 如果传递的格式是application/json 那么就不再是x=y&z=s
            const data = { username:username.value, pwd:pwd.value }

            // 请求头一定要在 open() 之后，send() 之前设置
            xhr.setRequestHeader('Content-type', 'application/json');

            // send中写请求体  send(qs); 叫请求体传参
            // 传递时,需要把JSON对象,手动转化成JSON字符串
            xhr.send(JSON.stringify(data));
        }
    </script>
</body>

</html>
```



浏览器效果：

![1713149829738](./assets/1713149829738.png)

![1713149865835](./assets/1713149865835.png)
![1713149897393](./assets/1713149897393.png)



ajax可以发请求，表单默认也是可以发请求的，如下：



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过url把数据扔给服务器</h1>
    <hr>
    <form action="/getData?a=1&b=2" method="post">
        <table>
            <tr>
                <td>用户名：</td>
                <td><input type="text" name="username" id="username"></td>
            </tr>
            <tr>
                <td>密码：</td>
                <td><input type="password" name="pwd" id="pwd"></td>
            </tr>
            <tr>
                <td></td>
                <td>
                    <input type="submit" value="非ajax请求"></input>
                </td>
            </tr>
        </table>
    </form>
</body>

</html>
```



测试：

![1713150217766](./assets/1713150217766.png)

![1713150183436](./assets/1713150183436.png)

![1713150261152](./assets/1713150261152.png)



### 4，通过FormData传递数据



请求体（send()的方法的参数）除了是字符串，也可以是 formData 对象。如果请求体是 FormData 对象，浏览器会自动设置请求头字段 Content-type 为 multipart/form-data。



FormData不仅可以传递普通数据，还可以上传文件。



后端代码：

```js
// 导入模块
const path = require('path');
const express = require('express');
const bodyParser = require('body-parser');  // body-parser 专门用于接收请求体数据
const multer = require('multer');


// 创建 express 实例
const app = express();


// 挂载中间件处理请求体
app.use(bodyParser.text());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: false}));


app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

// req.body 接收前端传递过来的普通数据
// req.file  接收前端上传过来的文件
const upload = multer({ dest: 'uploads/' })
app.post('/upload',upload.single('avator'),(req, res) => {
    console.log('文件上传成功：');
    console.log('文件信息：', req.file);
    console.log('表单数据：', req.body);
    console.log('');
    res.send('文件上传成功！');
});


app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



前端代码：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过formdata把数据扔给服务器</h1>
    <hr>
    <table>
        <tr>
            <td>用户名：</td>
            <td><input type="text" name="username" id="username"></td>
        </tr>
        <tr>
            <td>密码：</td>
            <td><input type="password" name="pwd" id="pwd"></td>
        </tr>
        <tr>
            <td></td>
            <td>
                <button id="btn1">提交1</button>
            </td>
        </tr>
    </table>

    <script>
        const username = document.querySelector("#username")
        const pwd = document.querySelector("#pwd")
        const btn1 = document.querySelector("#btn1")

        const xhr = new XMLHttpRequest();

        xhr.onload = () => {
            alert(xhr.responseText);
        };


        btn1.onclick = () => {
            // 创建FormData  fd是一个对象  容器
            const fd = new FormData();
            fd.append("username",username.value)
            fd.append("pwd",pwd.value)
            fd.append("aaaa",1111)
            fd.append("bbbb",2222)


            xhr.open('POST', '/upload');
            // send中不只可以放字符串,还可以放formdata对象
            xhr.send(fd);
        }
    </script>
</body>

</html>
```



测试：

![1713150962853](./assets/1713150962853.png)

![1713150998829](./assets/1713150998829.png)

![1713151041657](./assets/1713151041657.png)



此时这个请求头是人家自己添加的请求头，我们并没有设置。还有一种写法，如下：

![1713151266997](./assets/1713151266997.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过formdata把数据扔给服务器</h1>
    <hr>
    <!-- form表单有默认的提交事件 -->
    <!-- onsubmit="return false" 阻止默认事件的 -->
    <form onsubmit="return false">
        <table>
            <tr>
                <td>用户名：</td>
                <td><input type="text" name="username" id="username"></td>
            </tr>
            <tr>
                <td>密码：</td>
                <td><input type="password" name="pwd" id="pwd"></td>
            </tr>
            <tr>
                <td></td>
                <td>
                    <button id="btn1">提交1</button>
                </td>
            </tr>
        </table>
    </form>

    <script>
        const username = document.querySelector("#username")
        const pwd = document.querySelector("#pwd")
        const btn1 = document.querySelector("#btn1")

        const xhr = new XMLHttpRequest();

        xhr.onload = () => {
            alert(xhr.responseText);
        };


        btn1.onclick = () => {
            const formBox = document.querySelector("form");
            // 创建formData容器时,传递一个formDOM元素
            // 自动将form元素中的表单控制添加到formData中
            const fd = new FormData(formBox);

            xhr.open('POST', '/upload');
            xhr.send(fd);
        }
    </script>
</body>

</html>
```






### 5，通过FormData实现文件上传

后端代码如下：

```js
// 导入模块
const path = require('path');
const express = require('express');
const bodyParser = require('body-parser');  // body-parser 专门用于接收请求体数据
const multer = require('multer');

// 创建 express 实例
const app = express();

// 挂载中间件处理请求体
app.use(bodyParser.text());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: false}));


app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

// req.body 接收前端传递过来的普通数据
// req.file  接收前端上传过来的文件
const upload = multer({ dest: 'uploads/' })
app.post('/upload',upload.single('avator'), (req, res) => {
    console.log('文件上传成功：');
    console.log('文件信息：', req.file);
    console.log('表单数据：', req.body);
    console.log('');
    res.send('文件上传成功！');
});


app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



测试文件上传：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <h1>通过formdata把数据扔给服务器</h1>
    <hr>
    <!-- form表单有默认的提交事件 -->
    <!-- onsubmit="return false" 阻止默认事件的 -->
    <form onsubmit="return false">
        <table>
            <tr>
                <td>用户名：</td>
                <td><input type="text" name="username" id="username"></td>
            </tr>
            <tr>
                <td>密码：</td>
                <td><input type="password" name="pwd" id="pwd"></td>
            </tr>
            <tr>
                <td>头像: </td>
                <td><input type="file" name="avator" id="avator"></td>
            </tr>
            <tr>
                <td></td>
                <td>
                    <button id="btn1">提交1</button>
                </td>
            </tr>
        </table>
    </form>

    <script>
        const username = document.querySelector("#username")
        const pwd = document.querySelector("#pwd")
        const avator = document.querySelector("#avator")
        const btn1 = document.querySelector("#btn1")

        const xhr = new XMLHttpRequest();

        xhr.onload = () => {
            alert(xhr.responseText);
        };


        btn1.onclick = () => {
            // const formBox = document.querySelector("form");
            // 创建formData容器时,传递一个formDOM元素
            // 自动将form元素中的表单控制添加到formData中
            // const fd = new FormData(formBox);

            const fd = new FormData();
            fd.append("uname",username.value);
            fd.append("upwd",pwd.value);
            fd.append("avator",avator.files[0]);

            xhr.open('POST', '/upload');
            xhr.send(fd);
        }
    </script>
</body>

</html>
```



测试：

![1713151523406](./assets/1713151523406.png)



![1713151557035](./assets/1713151557035.png)



![1713151567475](./assets/1713151567475.png)

![1713151601337](./assets/1713151601337.png)





### 6，响应报文

准备后端：

```js
// 导入模块
const path = require('path');
const express = require('express');

// 创建 express 实例
const app = express();

app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

app.get('/getData', (req, res) => {
    console.log('接收到请求');
    res.send('hello ajax ' + Math.random());
});

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



书写前端代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <button id="btn">点我发请求</button>
</head>
<body>
    <script>
        const xhr = new XMLHttpRequest();  

        xhr.onload = function(){
            // 响应分三部分：
            //   响应行
            console.log("响应行:")
            console.log('响应状态码：', xhr.status);
            console.log('响应状态描述：', xhr.statusText);
            console.log('');
            //   响应头
            console.log('响应头：');
            console.log('Content-type:', xhr.getResponseHeader('Content-type'));
            console.log('Date:', xhr.getResponseHeader('Date'));
            console.log(xhr.getAllResponseHeaders());
            console.log('');
            //   响应体
            console.log('响应体：')
            console.log(xhr.response);
            console.log(xhr.responseText);
        }

        const btn = document.querySelector("#btn");
        btn.onclick = ()=>{
            xhr.open("get","/getData")
            // get请求没有请求体，null是空的意思
            xhr.send(null);
        }

    </script>
</body>
</html>
```



测试测试：

![1713163666484](./assets/1713163666484.png)



![1713163715355](./assets/1713163715355.png)





### 7，响应JSON

如果想让后端响应一个JSON，也需要设置一个响应头，告诉客户端，响应的数据类型。书写后端：

```js
// 导入模块
const path = require('path');
const express = require('express');

// 创建 express 实例
const app = express();

app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

app.get('/getData', (req, res) => {
    console.log('接收到请求');
    const stus = [
        {id:"01",name:"malu",age:18,score:88},
        {id:"02",name:"wc",age:13,score:23},
        {id:"03",name:"xq",age:16,score:44},
        {id:"04",name:"xx",age:10,score:55},
    ]
    const stusStr = JSON.stringify(stus)
    // 告诉客户端，响应的是JSON数据
    res.setHeader("Content-Type", "application/json;charset=utf-8");
    res.send(stusStr);
});

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



前端：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <button id="btn">点我发请求</button>
</head>

<body>
    <script>
        const xhr = new XMLHttpRequest();

        // 设置期望的响应数据的数据类型，期望服务器响应json
        // xhr.responseText  这个API就不能使用了
        xhr.responseType = "json";

        xhr.onload = function () {
            // console.log(JSON.parse(xhr.responseText));

            // xhr.response得到服务器响应的JSON数据  不需要通过JSON.parse
            console.log(xhr.response);
        }

        const btn = document.querySelector("#btn");
        btn.onclick = () => {
            // 请求同一个url，第一次不走缓存，
            // 从第二次开始，就可能走缓存，304表示走的缓存
            // 不想走缓冲，需要让每次请求的url不一样
            // xhr.open("get", "/getData?random="+Math.random())
            xhr.open("get", "/getData?xx="+Date.now())
            xhr.send(null);
        }

    </script>
</body>

</html>
```



浏览器测试：

![1713164399961](./assets/1713164399961.png)

![1713164827428](./assets/1713164827428.png)





### 8，超时处理



后端：

```js
// 导入模块
const path = require('path');
const express = require('express');

// 创建 express 实例
const app = express();

app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

app.get('/getData', (req, res) => {
    console.log('接收到请求');
    const timeout = Math.floor(Math.random()*10) * 1000

    const stus = [
        {id:"01",name:"malu",age:18,score:88},
        {id:"02",name:"wc",age:13,score:23},
        {id:"03",name:"xq",age:16,score:44},
        {id:"04",name:"xx",age:10,score:55},
    ]
    const stusStr = JSON.stringify(stus)
    // 告诉客户端，响应的是JSON数据
    res.setHeader("Content-Type", "application/json;charset=utf-8");
    setTimeout(()=>{
        res.send(stusStr);
    },timeout)
});

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



前端：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <button id="btn">点我发请求</button>
    <button id="btn2">手动取消请求</button>
</head>

<body>
    <script>
        const xhr = new XMLHttpRequest();

        xhr.responseType = "json";

        xhr.onload = function () {
            console.log(xhr.response);
        }

        // 设置超时时间  5s
        // 如果时间到了，数据还没有回来，会自动取消请求
        xhr.timeout = 5000; 

        const btn = document.querySelector("#btn");
        btn.onclick = () => {
            xhr.open("get", "/getData?xx="+Date.now())
            xhr.send(null);
        }

        const btn2 = document.querySelector("#btn2");
        btn2.onclick = () => {
          xhr.abort(); // 取消请求~
        }

    </script>
</body>

</html>
```



测试：

![1713166412071](./assets/1713166412071.png)



### 9，Ajax中的事件

后端代码：

```js
// 导入模块
const path = require('path');
const express = require('express');

// 创建 express 实例
const app = express();

app.get("/",(req,res)=>{
    res.sendFile(path.join(__dirname,"../client","index.html"))
})

app.get('/getData', (req, res) => {
    console.log('接收到请求');
    const timeout = Math.floor(Math.random()*10) * 1000

    const stus = [
        {id:"01",name:"malu",age:18,score:88},
        {id:"02",name:"wc",age:13,score:23},
        {id:"03",name:"xq",age:16,score:44},
        {id:"04",name:"xx",age:10,score:55},
    ]
    const stusStr = JSON.stringify(stus)
    // 告诉客户端，响应的是JSON数据
    res.setHeader("Content-Type", "application/json;charset=utf-8");
    // setTimeout(()=>{
        // res.send(stusStr);
        res.send('hello malu'.repeat(10000000))
    // },timeout)
    // },10000)
});

app.listen(3000,()=>{
    console.log('服务器启动了，端口是3000');
})
```



在ajax中，除了load事件之外，还有一些其它的事件：
- readystatechange    当ajax状态发生变化，就会触发，触发至少 4 次
- load                响应结束的时候触发，此时 readyState 的值是 4
- loadstart            开始请求的时候触发，此时 readyState 的值是 1
- loadend                响应结束之后触发，不论请求是否成功都会触发
- error                请求失败触发，应用层面的错误也算是请求成功（如 404错误），只有网络错误才算请求失败，指请求无法发出的错误
- progress            当开始接收响应内容，被触发多次，该事件的回调函数可以获取一个 progressEvent 对象



readystatechange，用来监测ajax状态变化的

- 0   UNSET -- XHR对象已创建或已被 abort() 方法重置。 
- 1   OPENDED -- open() 方法已经被调用。
- 2   HEADERS_RECEIVED -- send() 方法已经被调用，并且响应头和响应状态已经可获得。 
- 3   LOADING -- 下载中， responseText 属性已经包含部分数据。 
- 4   DONE -- 所有响应数据接收完毕。





直接上代码，后端代码同步。前端代码如下：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        #box {
            margin-top: 20px;
            width: 600px;
            padding: 20px;
            min-height: 200px;
            border: 1px solid #999;
        }
    </style>
</head>

<body>
    <button id="btn">点我发请求</button>
    <button id="btn2">手动取消请求</button>
    <div id="box"></div>
    <script>
        const xhr = new XMLHttpRequest();
        const divBox = document.querySelector("#box")

        // xhr.responseType = "json";

        // xhr有好多状态,只要状态发生变化,就会触发readystatechange事件
        xhr.onreadystatechange = ()=>{
            console.log("xhr readystate:", xhr.readyState)
            // 0  刚new出来时,它的状态是0
            // 1  当设置完请求后,它的状态是1  调用完xhr.open之后
            // 2  发出请求,它的状态是2  调用完xhr.send之后
            // 3  开始接收响应数据时,状态就变成3
            // 4  数据接收完毕,说白了,就是响应完毕了
            if(xhr.readyState === 4){
                // 响应数据接收完毕
                // ......  等价于load事件
            }
        }

        // 开始发请求  xhr.readyState是1
        xhr.onloadstart = ()=>{
            console.log('loadstart');
        }
        // 不管成功还是失败,loadend都要走
        xhr.onloadend = ()=>{
            console.log('onloadend');
        }

        // 数据接收完毕后,会触发load事件
        xhr.onload = function () {
            console.log(xhr.response);
        }

        // 请求失败就会触发, 404是请求成功了, 所谓的失败,就是请求发不出去
        // 只有网络错误,才会请求失败
        xhr.onerror = ()=>{
            console.log('error，请求失败！');
        }

        // 在接收响应数据时,接收一点,就会触发progress事件,直到接入完毕
        xhr.onprogress = (e)=>{
            console.log('e:',e.loaded, e.total);
            // divBox.innerHTML += xhr.responseText
            divBox.innerHTML = "已下载:"+(e.loaded/e.total * 100).toFixed(2)+"%"
            if(e.loaded == e.total){
                divBox.innerHTML = "下载成功~"
            }
        }

        // 设置超时时间  5s
        // 如果时间到了，数据还没有回来，会自动取消请求
        xhr.timeout = 5000; 

        const btn = document.querySelector("#btn");
        btn.onclick = () => {
            // 404 (Not Found)   404表示请求资源服务上没有
            // xhr.open("get", "/getData123?xx="+Date.now())
            xhr.open("get", "/getData?xx="+Date.now())
            xhr.send(null);
        }


        const btn2 = document.querySelector("#btn2");
        btn2.onclick = () => {
          xhr.abort(); // 取消请求~
        }
    </script>
</body>

</html>
```



测试：

![1713168576204](./assets/1713168576204.png)



### 10，总结

创建xhr对象，使用构造函数 XMLHttpRequest 就可以创建一个 XHR 对象。

```js
let xhr = new XMLHttpRequest()；
```



ajax对象中的属性如下：

| 属性名       | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| readyState   | 返回一个数字，表示请求的状态： 0 -- UNSET -- XHR对象已创建或已被 abort() 方法重置。 1 -- OPENDED -- `open()` 方法已经被调用。 2 -- HEADERS_RECEIVED -- `send()` 方法已经被调用，并且响应头和响应状态已经可获得。 3 -- LOADING -- 下载中， `responseText` 属性已经包含部分数据。 4 -- DONE -- 所有响应数据接收完毕。 |
| status       | 响应状态码，如 404、200 等。                                 |
| statusText   | 响应状态码的文本描述，如 200 对应的是 “OK”。                 |
| responseXML  | 接收格式为 XML 的响应数据，返回一个 document 对象。          |
| responseText | 获取响应文本，返回一个字符串。                               |
| responseType | 用于设置响应内容的类型 *xhr2*                                |
| response     | 返回的类型取决于 responseType 的设置。 *xhr2*                |
| timeout      | 设置超时时间。*xhr2*                                         |



ajax对象中的方法如下：

| 方法名                  | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| open()                  | 初始化 HTTP 请求，用来指定请求方式和 URL。 `xhr.open(method, url, [async], [user], [password])` |
| send()                  | 发送 HTTP 请求，参数可以设置请求体，没有请求体无需设置参数。 |
| setRequestHeader()      | 设置 HTTP 请求头的值。必须在 `open()` 之后、`send()` 之前调用。 |
| abort()                 | 如果请求已被发出，则立刻中止请求。                           |
| getAllResponseHeaders() | 以字符串形式返回所有的响应头。                               |
| getResponseHeader()     | 返回指定的响应头。                                           |



ajax对象中的事件如下：

| 事件名           | 含义                                                         |
| ---------------- | ------------------------------------------------------------ |
| readystatechange | readyState 属性值发生变化触发该事件。                        |
| abort            | 请求终止时触发。                                             |
| error            | 请求遇到错误时触发。                                         |
| loadstart        | 接收到响应数据时触发。                                       |
| load             | 请求成功完成时触发。                                         |
| loaded           | 当请求结束时触发, 无论请求成功 ( `load`) 还是失败 (`abor` 或 `error`)。 |
| progress         | 当请求接收到更多数据时，周期性地触发。                       |
| timeout          | 在预设时间内没有接收到响应时触发。                           |



异步请求：

- 在发请求之后，其它的同步任务都已经执行完毕了。

同步请求：

- 在发请求之后，需要等到响应完全结束后才会执行剩下同步任务。



默认情况下，ajax发的请求，都是异步的，通过open方法中的第3个参数可以设置同步

- true 表示异步请求 ， 不写也是true
- false 表示同步请求，基本上不用



### 11，跨域 cors

同源策略是浏览器的一种安全策略，要求ajax代码所在的页面url中的协议，域名，端口与ajax请求中url中的协议，域名，端口要完全一样。举例：有一个这样的域名：http://www.wangcai.com

- http://zhidao.wangcai.com         不同源
- http://www.wangcai.com:8080      不同源
- https://www.wangcai.com        不同源
- http://www.wangcai.com/phone/index.html      同源
- http://www.wangcai.com/phone/huawei/index.html           同源



总结：

- 源：协议 + 域名 + 端口
- 同源：相同的协议 && 相同域名 && 相同的端口
- 不同源：不同的协议 || 不同的域名 || 不同的端口



写代码，演示一下同源策略，先看后端代码：



```js
// 导入模块
const path = require('path');
const express = require('express');

// 创建 express 实例
const app = express();

app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, "../client", "index.html"))
})

app.get('/getData', (req, res) => {
    console.log("来到服务器了~~")
    res.send('hello malu')
});

app.listen(3000, () => {
    console.log('服务器启动了，端口是3000');
})
```



前端代码：

```html
<!DOCTYPE html>
<html lang="en">
<!-- 
    休息10分钟
 -->
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        #box {
            margin-top: 20px;
            width: 600px;
            padding: 20px;
            min-height: 200px;
            border: 1px solid #999;
        }
    </style>
</head>

<body>
    <button id="btn">点我发请求</button>
    <div id="box"></div>
    <script>
        const xhr = new XMLHttpRequest();
        const divBox = document.querySelector("#box")
        const btn = document.querySelector("#btn")

        xhr.onload = ()=>{
            divBox.innerHTML += xhr.response + '<br>';
        }
        xhr.onerror = () => {
            console.log('请求失败！');
        }

        btn.onclick = () => {
            xhr.open("get","http://127.0.0.1:3000/getData")
            xhr.send();
        }
    </script>
</body>

</html>
```



上面ajax代码所在的页面url中的协议，域名，端口与ajax请求中url中的协议，域名，端口要完全一样，测试如下：

![1713170901971](./assets/1713170901971.png)





127.0.0.1对应的域名是localhost，通过localhost访问页面，如下：

![1713170988794](./assets/1713170988794.png)

![1713171050978](./assets/1713171050978.png)



虽然上面的报错了，但是我们看一下，有没有走到服务器，测试如下：

![1713171260047](./assets/1713171260047.png)



要抵抗同源策略，叫跨域，常见解决跨域的方案：

- cors
- jsonp
- 前端配置代理



先演示一个cors解决跨域域，就是后端去配置解决，如下：

```js
// 导入模块
const path = require('path');
const express = require('express');

// 创建 express 实例
const app = express();

app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, "../client", "index.html"))
})

app.get('/getData', (req, res) => {
    console.log("来到服务器了~~")
    // 通过请求头，抵抗同源策略
    // res.set('Access-Control-Allow-Origin', 'http://localhost:3000');
    // res.set('Access-Control-Allow-Origin', 'http://192.168.217.1:3000');

    // 请允许多个域名来请求
    // const allowOrigins = ['http://localhost:3000','http://192.168.217.1:3000']
    // if (allowOrigins.includes(req.get('Origin'))) {
    //     res.set('Access-Control-Allow-Origin', req.get('Origin'));
    // }

    // 允许所有的域名
    res.set('Access-Control-Allow-Origin', '*');

    res.send('hello malu')
});

app.listen(3000, () => {
    console.log('服务器启动了，端口是3000');
})
```



配置好之后，即使不同源，也可以获取数据，如下：

![1713171783695](./assets/1713171783695.png)







还有一个模块，叫cors模块，使用如下：https://www.npmjs.com/package/cors





### 12，JSONP



**不受同源策略的限制**

- 资源的引入 如：img标签的src   link标签的href     script标签的src
- 页面中的超连接 a标签中的href
- 表单的提交
- 重定向页面



如果请求的url，得到的是一个json数据，通常这个url叫API接口， 开源接口：

```
https://docs.tenapi.cn/
https://www.free-api.com/
https://api.aa1.cn/
```





### 13，Fetch





### 14，Axios


























































