---
title: 01-Spring
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - ssm
categories:
 -  ssm
---

## 一，初识Spring框架



### 1，为什么要学框架

Spring技术是JavaEE开发必备技能，企业开发技术选型命中率>90%。有的优势

- 简化开发，降低企业级开发的复杂性
  - IOC  反转控制
  - AOP 面向切面编程
- 框架整合，高效整合其他技术，提高企业级应用开发与运行效率
  - MyBatis
  - MyBatis-plus
  - Struts
  - Struts2
  - Hibernate
  - ....



### 2，认识Spring

![1702881499312](./assets/1702881499312.png)

- 官网：https://spring.io
- Spring发展到今天已经形成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能。





**Spring发展史**

![1702881546475](./assets/1702881546475.png)



**系统架构图**

Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基

![1702881613580](./assets/1702881613580.png)



目前我们的代码存在什么问题以及怎么解决这些问题？

- 代码耦合度偏高

![1702881788294](./assets/1702881788294.png)



解决方案：使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象



**核心概念：**

- IOC（Inversion of Control）控制反转。使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。通俗的讲就是“将new对象的权利交给Spring，我们从Spring中获取对象使用即可”
- Spring技术对IOC思想进行了实现。Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的“外部”。IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean
- DI（Dependency Injection）依赖注入。在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。



![1702881948488](./assets/1702881948488.png)



这样做的目录是充分解耦，使用IOC容器管理bean，在IOC容器内将有依赖关系的bean进行关系绑定（DI）。最终使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。





**Spring Framework课程学习路线**

1. 核心容器，IOC/DI，容器的基本操作
2. AOP，AOP基础操作，AOP实用开发
3. 事务
4. 整合MyBatis





## 二，IOC和DI入门案例【重点】



### 1，IOC入门案例

入门案例思路分析

1. 管理什么？(Service与Dao)
2. 如何将被管理的对象告知IOC容器？(配置文件)
3. 被管理的对象交给IOC容器，如何获取到IoC容器？(接口)
4. IOC容器得到后，如何从容器中获取bean？(接口方法)
5. 使用Spring导入哪些坐标？(pom.xml)



实现步骤：

1. 导入Spring坐标

   ```xml
   <dependencies>
       <!--导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-context</artifactId>
           <version>5.2.10.RELEASE</version>
       </dependency>
   </dependencies>
   ```

2. 定义Spring管理的类（接口）

   ```java
   // BookDao接口和BookDaoImpl实现类
   public interface BookDao {
       public void save();
   }
   
   public class BookDaoImpl implements BookDao {
       public void save() {
           System.out.println("book dao save ...");
       }
   }
   
   // BookService接口和BookServiceImpl实现类
   public interface BookService {
       public void save();
   }
   
   public class BookServiceImpl implements BookService {
       private BookDao bookDao = new BookDaoImpl();
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
   }
   ```

3. 创建Spring配置文件，配置对应类作为Spring管理的bean对象

   ```xml
   // 定义applicationContext.xml配置文件并配置BookServiceImpl
   
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    
       <!--
   		bean标签：表示配置bean
       	id属性：表示给bean起名字，bean定义时id属性在同一个上下文中(IOC容器中)不能重复
       	class属性：表示给bean定义类型
   	-->
       <bean id="bookService" class="com.malu.service.impl.BookServiceImpl"></bean>
   
   </beans>
   ```

   

4. 初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象

   ```java
   public class App {
       public static void main(String[] args) {
           //1.创建IoC容器对象，加载spring核心配置文件
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           //2 从IOC容器中获取Bean对象(BookService对象)
           BookService bookService= (BookService)ctx.getBean("bookService");
           //3 调用Bean对象(BookService对象)的方法
           bookService.save();
       }
   }
   ```



运行结果：



### 2，DI入门案例



DI入门案例思路分析

1. 基于IOC管理bean
2. Service中使用new形式创建的Dao对象是否保留？(否)
3. Service中需要的Dao对象如何进入到Service中？(提供方法)
4. Service与Dao间的关系如何描述？(配置)



实现步骤：

1. 删除使用new的形式创建对象的代码

   ```java
   public class BookServiceImpl implements BookService {
       private BookDao bookDao;  //【第一步】删除使用new的形式创建对象的代码
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
   }
   ```

2. 提供依赖对象对应的setter方法

   ```java
   public class BookServiceImpl implements BookService {
       private BookDao bookDao;
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
       //【第二步】提供依赖对象对应的setter方法
       public void setBookDao(BookDao bookDao) {
           this.bookDao = bookDao;
       }
   }
   ```

3. 在applicationContext.xml中配置service与dao之间的关系

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <!--
   		bean标签：表示配置bean
       	id属性：表示给bean起名字
       	class属性：表示给bean定义类型
   	-->
       <bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl"/>
   
       <bean id="bookService" class="com.malu.service.impl.BookServiceImpl">
           <!--配置server与dao的关系
   			property标签：表示配置当前bean的属性
           	name属性：表示配置哪一个具体的属性。name属性对应setXxx方法去掉set后首字母小写部分。
           	ref属性：表示参照哪一个bean
   		-->
           <property name="bookDao" ref="bookDao"/>
       </bean>
   </beans>
   ```

   



## 三，Bean的基础配置



