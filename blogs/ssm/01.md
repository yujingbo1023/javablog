---
title: 01-Spring
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - ssm
categories:
 -  ssm
---

## 一，初识Spring框架



### 1，为什么要学框架

Spring技术是JavaEE开发必备技能，企业开发技术选型命中率>90%。有的优势

- 简化开发，降低企业级开发的复杂性
  - IOC  反转控制
  - AOP 面向切面编程
- 框架整合，高效整合其他技术，提高企业级应用开发与运行效率
  - MyBatis
  - MyBatis-plus
  - Struts
  - Struts2
  - Hibernate
  - ....



### 2，认识Spring

![1702881499312](./assets/1702881499312.png)

- 官网：https://spring.io
- Spring发展到今天已经形成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能。





**Spring发展史**

![1702881546475](./assets/1702881546475.png)



**系统架构图**

Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基

![1702881613580](./assets/1702881613580.png)



目前我们的代码存在什么问题以及怎么解决这些问题？

- 代码耦合度偏高

![1702881788294](./assets/1702881788294.png)



解决方案：使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象



**核心概念：**

- IOC（Inversion of Control）控制反转。使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。通俗的讲就是“将new对象的权利交给Spring，我们从Spring中获取对象使用即可”
- Spring技术对IOC思想进行了实现。Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的“外部”。IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean
- DI（Dependency Injection）依赖注入。在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。



![1702881948488](./assets/1702881948488.png)



这样做的目录是充分解耦，使用IOC容器管理bean，在IOC容器内将有依赖关系的bean进行关系绑定（DI）。最终使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。





**Spring Framework课程学习路线**

1. 核心容器，IOC/DI，容器的基本操作
2. AOP，AOP基础操作，AOP实用开发
3. 事务
4. 整合MyBatis





## 二，IOC和DI入门案例【重点】



### 1，IOC入门案例

入门案例思路分析

1. 管理什么？(Service与Dao)
2. 如何将被管理的对象告知IOC容器？(配置文件)
3. 被管理的对象交给IOC容器，如何获取到IoC容器？(接口)
4. IOC容器得到后，如何从容器中获取bean？(接口方法)
5. 使用Spring导入哪些坐标？(pom.xml)



实现步骤：

1. 导入Spring坐标

   ```xml
   <dependencies>
       <!--导入spring的坐标spring-context，对应版本是5.2.10.RELEASE-->
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-context</artifactId>
           <version>5.2.10.RELEASE</version>
       </dependency>
   </dependencies>
   ```

2. 定义Spring管理的类（接口）

   ```java
   // BookDao接口和BookDaoImpl实现类
   public interface BookDao {
       public void save();
   }
   
   public class BookDaoImpl implements BookDao {
       public void save() {
           System.out.println("book dao save ...");
       }
   }
   
   // BookService接口和BookServiceImpl实现类
   public interface BookService {
       public void save();
   }
   
   public class BookServiceImpl implements BookService {
       private BookDao bookDao = new BookDaoImpl();
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
   }
   ```

3. 创建Spring配置文件，配置对应类作为Spring管理的bean对象

   ```xml
   // 定义applicationContext.xml配置文件并配置BookServiceImpl
   
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    
       <!--
   		bean标签：表示配置bean
       	id属性：表示给bean起名字，bean定义时id属性在同一个上下文中(IOC容器中)不能重复
       	class属性：表示给bean定义类型
   	-->
       <bean id="bookService" class="com.malu.service.impl.BookServiceImpl"></bean>
   
   </beans>
   ```

   

4. 初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象

   ```java
   public class App {
       public static void main(String[] args) {
           //1.创建IoC容器对象，加载spring核心配置文件
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           //2 从IOC容器中获取Bean对象(BookService对象)
           BookService bookService= (BookService)ctx.getBean("bookService");
           //3 调用Bean对象(BookService对象)的方法
           bookService.save();
       }
   }
   ```



运行结果：



### 2，DI入门案例



DI入门案例思路分析

1. 基于IOC管理bean
2. Service中使用new形式创建的Dao对象是否保留？(否)
3. Service中需要的Dao对象如何进入到Service中？(提供方法)
4. Service与Dao间的关系如何描述？(配置)



实现步骤：

1. 删除使用new的形式创建对象的代码

   ```java
   public class BookServiceImpl implements BookService {
       private BookDao bookDao;  //【第一步】删除使用new的形式创建对象的代码
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
   }
   ```

2. 提供依赖对象对应的setter方法

   ```java
   public class BookServiceImpl implements BookService {
       private BookDao bookDao;
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
       //【第二步】提供依赖对象对应的setter方法
       public void setBookDao(BookDao bookDao) {
           this.bookDao = bookDao;
       }
   }
   ```

3. 在applicationContext.xml中配置service与dao之间的关系

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
       <!--
   		bean标签：表示配置bean
       	id属性：表示给bean起名字
       	class属性：表示给bean定义类型
   	-->
       <bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl"/>
   
       <bean id="bookService" class="com.malu.service.impl.BookServiceImpl">
           <!--配置server与dao的关系
   			property标签：表示配置当前bean的属性
           	name属性：表示配置哪一个具体的属性。name属性对应setXxx方法去掉set后首字母小写部分。
           	ref属性：表示参照哪一个bean
   		-->
           <property name="bookDao" ref="bookDao"/>
       </bean>
   </beans>
   ```

   



## 三，Bean的基础配置



### 1，Bean的基础配置



基础配置：

![1702944468923](./assets/1702944468923.png)



参考：

```xml
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl" />
<bean id="bookService" class="com.malu.service.impl.BookServiceImpl"></bean>
```







### 2，Bean的别名配置



别名配置：

![1702944543061](./assets/1702944543061.png)



参考：

```xml
<bean id="bookDao" name="dao bookDaoImpl" class="com.malu.dao.impl.BookDaoImpl" />
<bean id="bookService" name="service,bookServiceImpl" class="com.malu.service.impl.BookServiceImpl"></bean>
```



代码演示：

```java
public class AppForName {
    public static void main(String[] args) {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        // 必须是配置的三个别名之一
        BookService bookService = (BookService) ctx.getBean("service4");

        bookService.save();
    }
}
```



```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔-->
    <bean id="bookService" name="service service4 bookEbi" class="com.malu.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>

    <!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype-->
    <bean id="bookDao" name="dao" class="com.malu.dao.impl.BookDaoImpl"/>
</beans>

```







### 3，Bean作用范围配置

作用范围配置：

![1702945412657](E:\javablog\blogs\ssm\assets\1702945412657.png)



参考：

```xml

<!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype-->
<!--scope的取值不仅仅只有singleton和prototype，还有request、session、application、 websocket ，表示创建出的对象放置在web容器(tomcat)对应的位置。比如：request表示保存到request域中。 -->
<bean id="bookDao" name="dao" class="com.itheima.dao.impl.BookDaoImpl" scope="prototype"/>

```



代码演示：

```java
public class AppForScope {
    public static void main(String[] args) {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        // 获取两次BookDao对象
        BookDao bookDao1 = (BookDao) ctx.getBean("bookDao");
        BookDao bookDao2 = (BookDao) ctx.getBean("bookDao");
        // 打印两次的地址值不一样，说明UserDao是非单例的
        System.out.println(bookDao1);
        System.out.println(bookDao2);
    }
}

```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="bookService" name="service service4 bookEbi" class="com.malu.service.impl.BookServiceImpl">
        <property name="bookDao" ref="bookDao"/>
    </bean>

    <!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype-->
    <bean id="bookDao" name="dao" class="com.malu.dao.impl.BookDaoImpl" scope="prototype"/>
</beans>

```



注意细节：

- 在我们的实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。



## 四，Bean的实例化



### 1，构造方法实例化

bean本质上就是对象，创建bean使用构造方法完成。BookDaoImpl实现类如下：

```java
public class BookDaoImpl implements BookDao {
    public BookDaoImpl() {
        System.out.println("book dao constructor is running ....");
    }
    public void save() {
        System.out.println("book dao save ...");
    }
}
```



applicationContext.xml配置：

```xml
<!--方式一：构造方法实例化bean-->
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
```



AppForInstanceBook测试类：

```java
public class AppForInstanceBook {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        BookDao bookDao = (BookDao) ctx.getBean("bookDao");

        bookDao.save();
    }
}
```



运行结果：

![1702945854793](E:\javablog\blogs\ssm\assets\1702945854793.png)



注意细节：

- 无参构造方法如果不存在，将抛出异常`BeanCreationException`



### 2，静态工厂方式实例化



OrderDao接口和OrderDaoImpl实现类：

```java
public interface OrderDao {
    public void save();
}
public class OrderDaoImpl implements OrderDao {
    public void save() {
        System.out.println("order dao save ...");
    }
}
```



OrderDaoFatory工厂类：

```java
//静态工厂创建对象
public class OrderDaoFactory {
    public static OrderDao getOrderDao(){
        System.out.println("factory setup....");
        return new OrderDaoImpl();
    }
}
```



applicationContext.xml配置：

```java
<!--方式二：使用静态工厂实例化bean-->
<bean id="orderDao" class="com.malu.factory.OrderDaoFactory" factory-method="getOrderDao"/>
```



AppForInstanceOrder测试类:

```java
public class AppForInstanceOrder {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        OrderDao orderDao = (OrderDao) ctx.getBean("orderDao");

        orderDao.save();
    }
}
```



运行结果：

![1702946148913](E:\javablog\blogs\ssm\assets\1702946148913.png)



### 3，实例工厂方式实例化



UserDao接口和UserDaoImpl实现类：

```java
public interface UserDao {
    public void save();
}
public class UserDaoImpl implements UserDao {
    public void save() {
        System.out.println("user dao save ...");
    }
}
```





UserDaoFactory工厂类：

```java
//实例工厂创建对象
public class UserDaoFactory {
    public UserDao getUserDao(){
        return new UserDaoImpl();
    }
}
```



applicationContext.xml配置：

```xml
<!--方式三：使用实例工厂实例化bean-->
<bean id="userFactory" class="com.malu.factory.UserDaoFactory"/>

<bean id="userDao" factory-method="getUserDao" factory-bean="userFactory"/>
```



AppForInstanceUser测试类：

```java
public class AppForInstanceUser {
    public static void main(String[] args) {
        //        //创建实例工厂对象
        //        UserDaoFactory userDaoFactory = new UserDaoFactory();
        //        //通过实例工厂对象创建对象
        //        UserDao userDao = userDaoFactory.getUserDao();
        //        userDao.save();
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserDao userDao = (UserDao) ctx.getBean("userDao");
        userDao.save();
    }
}
```



运行结果：

![1702946613690](E:\javablog\blogs\ssm\assets\1702946613690.png)





## 五，Bean的生命周期



生命周期相关的概念：

- 生命周期：从创建到消亡的完整过程
- bean生命周期：bean从创建到销毁的整体过程
- bean生命周期控制：在bean创建后到销毁前做一些事情



### 1，Bean的生命周期控制方式一



提供生命周期控制方法：

```java
public class BookDaoImpl implements BookDao {
    public void save() {
        System.out.println("book dao save ...");
    }
    //表示bean初始化对应的操作
    public void init(){
        System.out.println("init...");
    }
    //表示bean销毁前对应的操作
    public void destory(){
        System.out.println("destory...");
    }
}
```

applicationContext.xml配置:

```xml
<!--init-method：设置bean初始化生命周期回调函数,此处填写init方法名-->
<!--destroy-method：设置bean销毁生命周期回调函数，仅适用于单例对象，此处填写destory方法名-->
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl" init-method="init" destroy-method="destory"/>
```



测试类：

```java
public class AppForLifeCycle {
    public static void main( String[] args ) {
        //此处需要使用实现类类型，接口类型没有close方法
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();
        //关闭容器，执行销毁的方法
        ctx.close();
    }
}
```





### 2，Bean的生命周期控制方式二



实现InitializingBean, DisposableBean接口

```java
public class BookServiceImpl implements BookService, InitializingBean, DisposableBean {
    private BookDao bookDao;
    public void setBookDao(BookDao bookDao) {
        System.out.println("set .....");
        this.bookDao = bookDao;
    }
    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
    public void destroy() throws Exception {
        System.out.println("service destroy");
    }
    public void afterPropertiesSet() throws Exception {
        System.out.println("service init");
    }
}
```



### 3，Bean的销毁时机



- 容器关闭前触发bean的销毁
- 关闭容器方式：
  - 手工关闭容器
    `ConfigurableApplicationContext`接口`close()`操作
  - 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机
    `ConfigurableApplicationContext`接口`registerShutdownHook()`操作



代码演示：

```java
public class AppForLifeCycle {
    public static void main( String[] args ) {
        //此处需要使用实现类类型，接口类型没有close方法
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        BookDao bookDao = (BookDao) ctx.getBean("bookDao");
        bookDao.save();
        //注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器
        ctx.registerShutdownHook();
        //关闭容器
        //ctx.close();
    }
}
```



## 六，依赖注入DI

### 1，依赖注入的方式

依赖注入的方式有两种：

- setter注入
  - 简单类型
  - 引用类型（很常用）
- 构造器注入
  - 简单类型
  - 引用类型



#### 1.1 setter注入

代码演示setter引用类型依赖注入，在bean中定义引用类型属性并提供可访问的set方法：

```java
public class BookServiceImpl implements BookService{
    private BookDao bookDao;
    
    //setter注入需要提供要注入对象的set方法
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}

```



配置中使用property标签ref属性注入引用类型对象：

```java
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"></bean>

<!--注入引用类型-->
<bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
   <!--property标签：设置注入属性-->
   <!--name属性：设置注入的属性名，实际是set方法对应的名称-->
   <!--ref属性：设置注入引用类型bean的id或name-->
   <property name="bookDao" ref="bookDao"/>
</bean>
```



代码演示setter简单类型依赖注入，在bean中定义简单类型属性并提供可访问的set方法：

```java
public class BookDaoImpl implements BookDao {
    private int connectionNum;
    
    //setter注入需要提供要注入对象的set方法
    public void setConnectionNum(int connectionNum) {
        this.connectionNum = connectionNum;
    }
}
```



配置中使用property标签value属性注入简单类型数据：

```xml
<!--注入简单类型-->
<bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
	<!--property标签：设置注入属性-->
	<!--name属性：设置注入的属性名，实际是set方法对应的名称-->
	<!--value属性：设置注入简单类型数据值-->
	<property name="connectionNum" value="100"/>
</bean>
```



#### 1.2 构造方式注入

代码演示构造方式注入引用类型，在bean中定义引用类型属性并提供可访问的构造方法：

```java
public class BookServiceImpl implements BookService{
    private BookDao bookDao;

    public BookServiceImpl(BookDao bookDao) {
        this.bookDao = bookDao;
    }

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```



配置中使用constructor-arg标签ref属性注入引用类型对象：

```xml
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl"></bean>
<bean id="bookService" class="com.malu.service.impl.BookServiceImpl">
    <constructor-arg name="bookDao" ref="bookDao"/>
</bean>
```



代码演示构造方式注入简单类型，在bean中定义简单类型属性并提供可访问的构造方法：

```java
public class BookDaoImpl implements BookDao {
    private int connectionNum;

    public BookDaoImpl(int connectionNum) {
        this.connectionNum = connectionNum;
    }

    public void save() {
        System.out.println("book dao save ..."+connectionNum);
    }
}
```



配置中使用constructor-arg标签value属性注入简单类型数据：

```xml
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl">
    <constructor-arg name="connectionNum" value="10"/>
    <constructor-arg name="databaseName" value="mysql"/>
</bean>
```



配置中使用constructor-arg标签type属性设置按形参类型注入：

```xml
<!-- 解决形参名称的问题，与形参名不耦合 --> 
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl">
    根据构造方法参数类型注入
    <constructor-arg type="int" value="10"/>
    <constructor-arg type="java.lang.String" value="mysql"/>
</bean>
```



配置中使用constructor-arg标签index属性设置按形参位置注入：

```xml
 <!--解决参数类型重复问题，使用位置解决参数匹配-->
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl">
    <!--根据构造方法参数位置注入-->
    <constructor-arg index="0" value="mysql"/>
    <constructor-arg index="1" value="100"/>
</bean>
```



总结依赖注入方式选择：

- 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现
- 可选依赖使用setter注入进行，灵活性强
- Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
- 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入
- 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入
- 自己开发的模块推荐使用setter注入



### 2，依赖自动装配

什么是自动装配？

- IOC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配



自动装配方式：

- 按类型（常用）
- 按名称
- 按构造方法
- 不启用自动装配



配置中使用bean标签autowire属性设置自动装配的类型：

```xml
<bean id="bookDao" class="com.malu.dao.impl.BookDaoImpl"/>
<bean id="bookService" class="com.malu.service.impl.BookServiceImpl" autowire="byType"/>
```



##### 依赖自动装配特征

1. 自动装配用于引用类型依赖注入，不能对简单类型进行操作
2. 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用
3. 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用
4. 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效





### 3，集合注入

注入数组类型数据：

```xml
<property name="array">
    <array>
        <value>100</value>
        <value>200</value>
        <value>300</value>
    </array>
</property>
```

注入List类型数据：

```xml
<property name="list">
    <list>
        <value>aaa</value>
        <value>bbb</value>
        <value>ccc</value>
        <value>ddd</value>
    </list>
</property>
```

注入Set类型数据：

```xml
<property name="set">
    <set>
        <value>aaa</value>
        <value>bbb</value>
        <value>ccc</value>
        <value>ddd</value>
    </set>
</property>
```

注入Map类型数据：

```xml
<property name="map">
    <map>
        <entry key="country" value="china"/>
        <entry key="province" value="henan"/>
        <entry key="city" value="kaifeng"/>
    </map>
</property>
```

注入Properties类型数据：

```xml
<property name="properties">
    <props>
        <prop key="country">china</prop>
        <prop key="province">henan</prop>
        <prop key="city">kaifeng</prop>
    </props>
</property>
```



注意细节：

- property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写\<array>、\<list>、\<set>、\<map>、\<props>标签



## 七，管理第三方资源



### 1，管理DataSource连接池对象



数据库准备：

```mysql
create database if not exists spring_db character set utf8;
use spring_db;
create table if not exists tbl_account(
    id int primary key auto_increment,
    name varchar(20),
    money double
);
insert into tbl_account values(null,'Tom',1000);
insert into tbl_account values(null,'Jerry',1000);
```



管理Druid连接池步骤：

1. 【第一步】添加Druid连接池依赖、

   ```xml
   <!-- 除了添加以上两个依赖之外，别忘了添加spring-context依赖。 -->
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid</artifactId>
       <version>1.1.16</version>
   </dependency>
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.47</version>
   </dependency>
   ```

2. 【第二步】配置DruidDataSource连接池Bean对象

   ```java
   <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
       <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
       <property name="url" value="jdbc:mysql://localhost:3306/spring_db"/>
       <property name="username" value="root"/>
       <property name="password" value="root"/>
   </bean>
   ```

3. 【第三步】在测试类中从IOC容器中获取连接池对象并打印

   ```java
   public class App {
       public static void main(String[] args) {
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           DataSource dataSource = (DataSource) ctx.getBean("dataSource");
           System.out.println(dataSource);
       }
   }
   ```

   

管理c3p0连接池步骤：

1. 【第一步】添加c3p0连接池依赖

   ```xml
   <dependency>
       <groupId>c3p0</groupId>
       <artifactId>c3p0</artifactId>
       <version>0.9.1.2</version>
   </dependency>
   ```

2. 【第二步】配置c3p0连接池Bean对象

   ```xml
   <!-- 同一个Spring容器中不能有两个id="dataSource"的连接池 -->
   <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
       <property name="driverClass" value="com.mysql.jdbc.Driver"/>
       <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_db"/>
       <property name="user" value="root"/>
       <property name="password" value="root"/>
       <property name="maxPoolSize" value="1000"/>
   </bean>
   ```

3. 【第三步】在测试类中从IOC容器中获取连接池对象并打印

   ```java
   public class App {
       public static void main(String[] args) {
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           DataSource dataSource = (DataSource) ctx.getBean("dataSource");
           System.out.println(dataSource);
       }
   }
   ```



### 2，加载properties属性文件

目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。



基本用法步骤：

1. 【第一步】编写jdbc.properties属性文件

   ```properties
   jdbc.driver=com.mysql.jdbc.Driver
   jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db
   jdbc.username=root
   jdbc.password=root
   ```

2. 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件

   ![1702958425393](./assets/1702958425393.png)

   ```xml
   <context:property-placeholder location="jdbc.properties"/>
   ```

3. 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值

   ```xml
   <bean class="com.alibaba.druid.pool.DruidDataSource">
       <property name="driverClassName" value="${jdbc.driver}"/>
       <property name="url" value="${jdbc.url}"/>
       <property name="username" value="${jdbc.username}"/>
       <property name="password" value="${jdbc.password}"/>
   </bean>
   ```

4. 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。





### 3，配置不加载系统属性



**问题**

- 如果属性文件中配置的不是jdbc.username，而是username=root，那么使用${username}获取到的不是root，而是计算机的名称。

**原因**

- 系统属性的优先级比我们属性文件中的高，替换了我们的username=root。

**解决**

- 解决1：换一个名称，例如不叫username，叫jdbc.username。

- 解决2：使用system-properties-mode="NEVER"属性表示不使用系统属性。

```properties
<context:property-placeholder location="jdbc.properties" system-properties-mode="NEVER"/>
```





### 4，加载properties文件写法

- 不加载系统属性

```xml
<context:property-placeholder location="jdbc.properties" system-properties-mode="NEVER"/>
```

- 加载多个properties文件

```xml
<context:property-placeholder location="jdbc.properties,msg.properties"/>
```

- 加载所有properties文件

```xml
<context:property-placeholder location="*.properties"/>
```

- 加载properties文件**标准格式**

```xml
<context:property-placeholder location="classpath:*.properties"/>
```

- 加载properties文件标准格式

```xml
<context:property-placeholder location="classpath*:*.properties"/>
```





## 八，Spring容器



### 1，Spring核心容器

#### 1.1 创建容器

- 方式一：类路径加载配置文件

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
```

- 方式二：文件路径加载配置文件

```java
ApplicationContext ctx = new FileSystemXmlApplicationContext("D:\\applicationContext.xml");
```

- 加载多个配置文件

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("bean1.xml", "bean2.xml");
```



#### 1.2 获取bean对象

- 方式一：使用bean名称获取

> 弊端：需要自己强制类型转换

```java
BookDao bookDao = (BookDao) ctx.getBean("bookDao");
```

- 方式二：使用bean名称获取并指定类型

> 弊端：推荐使用

```java
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
```

- 方式三：使用bean类型获取

> 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错

```java
BookDao bookDao = ctx.getBean(BookDao.class);
```

#### 1.3 容器类层次结构

![1702958981045](./assets/1702958981045.png)



#### 1.4 BeanFactory

- 类路径加载配置文件

```java
Resource resources = new ClassPathResource("applicationContext.xml");
BeanFactory bf = new XmlBeanFactory(resources);
BookDao bookDao = bf.getBean("bookDao", BookDao.class);
bookDao.save();
```

- BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们





### 2，Spring核心容器总结



#### 2.1 容器相关

- BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载
- ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载
- ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能
- ApplicationContext接口常用初始化类
  - **ClassPathXmlApplicationContext(常用)**
  - FileSystemXmlApplicationContext



#### 2.2 bean相关

![1702959215914](./assets/1702959215914.png)



#### 2.3 依赖注入相关

![1702959316635](./assets/1702959316635.png)





## 九，注解开发

xml配置Bean对象有些繁琐，真实开发中，会使用注解简化Bean对象的定义。



### 1，注解开发定义Bean对象



基本使用步骤：

1. 【第一步】在applicationContext.xml中开启Spring注解包扫描

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:context="http://www.springframework.org/schema/context"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="
           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
   	 <!--扫描com.malu包及其子包下的类中注解-->
       <context:component-scan base-package="com.malu"/>
   </beans>
   ```

   

2. 【第二步】在类上使用@Component注解定义Bean。

   ```java
   // @Component注解没有使用参数指定Bean的名称，那么类名首字母小写就是Bean在IOC容器中的默认名称。例如：BookServiceImpl对象在IOC容器中的名称是bookServiceImpl。
   
   //@Component定义bean
   @Component("bookDao")
   public class BookDaoImpl implements BookDao {
       public void save() {
           System.out.println("book dao save ...");
       }
   }
   @Component
   public class BookServiceImpl implements BookService {
       private BookDao bookDao;
   
       public void setBookDao(BookDao bookDao) {
           this.bookDao = bookDao;
       }
   
       public void save() {
           System.out.println("book service save ...");
           bookDao.save();
       }
   }
   ```

3. 【第三步】在测试类中获取Bean对象

   ```java
   // 在测试类中不要调用bookService的save方法，因为还没有给BookServiceImpl中的bookDao赋值，调用bookService的save方法会出现空指针异常。
   
   public class AppForAnnotation {
       public static void main(String[] args) {
           ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
           BookDao bookDao = (BookDao) ctx.getBean("bookDao");
           System.out.println(bookDao);
           //按类型获取bean
           BookService bookService = ctx.getBean(BookService.class);
           System.out.println(bookService);
       }
   }
   ```



运行结果：





@Component三个衍生注解

- @Controller：用于表现层bean定义
- @Service：用于业务层bean定义
- @Repository：用于数据层bean定义



代码演示：

```java
@Repository("bookDao")
public class BookDaoImpl implements BookDao {
}

@Service
public class BookServiceImpl implements BookService {
}
```







### 2，纯注解开发模式

Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道。Java类代替Spring核心配置文件。如下：

```java
@Configuration
@ComponentScan("com.malu")
public class SpringConfig{
    
}
```

- @Configuration注解用于设定当前类为配置类

- @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式

  ```java
  @ComponentScan({com.malu.servicec,com.malu.dao"})
  ```

- 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象

  ```java
  //加载配置文件初始化容器
  ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
  //加载配置类初始化容器
  ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
  ```



代码演示步骤：

1. 【第一步】定义配置类代替配置文件

   ```java
   //声明当前类为Spring配置类
   @Configuration
   //Spring注解扫描，相当于<context:component-scan base-package="com.malu"/>
   @ComponentScan("com.malu")
   //设置bean扫描路径，多个路径书写为字符串数组格式
   //@ComponentScan({"com.malu.service","com.malu.dao"})
   public class SpringConfig {
   }
   ```

2. 【第二步】在测试类中加载配置类，获取Bean对象并使用

   ```java
   public class AppForAnnotation {
       public static void main(String[] args) {
           //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器
           ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
           BookDao bookDao = (BookDao) ctx.getBean("bookDao");
           System.out.println(bookDao);
           //按类型获取bean
           BookService bookService = ctx.getBean(BookService.class);
           System.out.println(bookService);
       }
   }
   ```





### 3，注解开发Bean的作用范围和生命周期

使用@Scope定义bean作用范围：

```java
@Repository
@Scope("singleton")
public class BookDaoImpl implements BookDao {
}
```



使用@PostConstruct、@PreDestroy定义bean生命周期：

```java
@Repository
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    public BookDaoImpl() {
        System.out.println("book dao constructor ...");
    }
    @PostConstruct
    public void init(){
        System.out.println("book init ...");
    }
    @PreDestroy
    public void destroy(){
        System.out.println("book destory ...");
    }
}
```



注意细节：

- @PostConstruct和@PreDestroy注解是jdk中提供的注解，从jdk9开始，jdk中的javax.annotation包被移除了，也就是说这两个注解就用不了了，可以额外导入一下依赖解决这个问题。

  ```xml
  <dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.3.2</version>
  </dependency>
  ```

  



### 4，注解开发依赖注入

使用@Autowired注解开启自动装配模式（按类型），不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配。

```java
@Service
public class BookServiceImpl implements BookService {
    //@Autowired：注入引用类型，自动装配模式，默认按类型装配
    @Autowired
    private BookDao bookDao;

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```



如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称。自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。

```java
@Service
public class BookServiceImpl implements BookService {
    //@Autowired：注入引用类型，自动装配模式，默认按类型装配
    @Autowired
    //使用@Qualifier注解指定要装配的bean名称
    //@Qualifier：自动装配bean时按bean名称装配。目的：解决IOC容器中同类型Bean有多个装配哪一个的问题
    //@Qualifier注解无法单独使用，必须配合@Autowired注解使用
    @Qualifier("bookDao")
    private BookDao bookDao;

    public void save() {
        System.out.println("book service save ...");
        bookDao.save();
    }
}
```



使用@Value实现简单类型注入：

```java
@Repository("bookDao")
public class BookDaoImpl implements BookDao {
    //@Value：注入简单类型（无需提供set方法）
    @Value("${name}")
    private String name;

    public void save() {
        System.out.println("book dao save ..." + name);
    }
}
```



以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。

```java
@Configuration
@ComponentScan("com.itheima")
//@PropertySource加载properties配置文件
@PropertySource({"classpath:jdbc.properties"}) //{}可以省略不写
public class SpringConfig {
}
```



注意细节：

- @PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*





### 5，注解开发管理第三方Bean



注解开发管理第三方Bean步骤：

1. 【第一步】单独定义配置类

   ```java
   public class JdbcConfig {
       //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中
       @Bean
       public DataSource dataSource(){
           DruidDataSource ds = new DruidDataSource();
           ds.setDriverClassName("com.mysql.jdbc.Driver");
           ds.setUrl("jdbc:mysql://localhost:3306/spring_db");
           ds.setUsername("root");
           ds.setPassword("root");
           return ds;
       }
   }
   ```

2. 【第二步】将独立的配置类加入核心配置

   - 方式1：@Import注解导入式

     ```java
     @Configuration
     @ComponentScan("com.itheima")
     //@Import:导入配置信息
     @Import({JdbcConfig.class})
     public class SpringConfig {
     }
     ```

   - 方式2：@ComponentScan扫描式

     ```java
     @Configuration
     @ComponentScan({"com.malu.config","com.malu.service","com.malu.dao"})  //只要com.malu.config包扫到了就行，三个包可以合并写成com.malu
     public class SpringConfig {
     }
     ```



### 6，注解开发为第三方Bean注入资源



简单类型依赖注入：

```java
// 如果@Value()中使用了EL表达式读取properties属性文件中的内容，那么就需要加载properties属性文件。
public class JdbcConfig {
    //1.定义一个方法获得要管理的对象
    @Value("com.mysql.jdbc.Driver")
    private String driver;
    @Value("jdbc:mysql://localhost:3306/spring_db")
    private String url;
    @Value("root")
    private String userName;
    @Value("root")
    private String password;
    //2.@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }
}
```



引用类型依赖注入:

```java
//Spring会自动从IOC容器中找到BookDao对象赋值给参数bookDao变量，如果没有就会报错。
@Bean 
public DataSource dataSource(BookDao bookDao){
    System.out.println(bookDao);
    DruidDataSource ds = new DruidDataSource();
    ds.setDriverClassName(driver);
    ds.setUrl(url);
    ds.setUsername(userName);
    ds.setPassword(password);
    return ds;
}
```



注意细节：

- 引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象



注解开发小结：

![1702967676051](./assets/1702967676051.png)



## 十，Spring 整合其它技术



### 1，Spring整合Mybatis

MyBatis程序核心对象分析：

![1702968096947](./assets/1702968096947.png)



准备service和dao层基础代码：

```java
public interface AccountService {

    void save(Account account);

    void delete(Integer id);

    void update(Account account);

    List<Account> findAll();

    Account findById(Integer id);

}
@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;

    public void save(Account account) {
        accountDao.save(account);
    }

    public void update(Account account){
        accountDao.update(account);
    }

    public void delete(Integer id) {
        accountDao.delete(id);
    }

    public Account findById(Integer id) {
        return accountDao.findById(id);
    }

    public List<Account> findAll() {
        return accountDao.findAll();
    }
}
public interface AccountDao {

    @Insert("insert into tbl_account(name,money)values(#{name},#{money})")
    void save(Account account);

    @Delete("delete from tbl_account where id = #{id} ")
    void delete(Integer id);

    @Update("update tbl_account set name = #{name} , money = #{money} where id = #{id} ")
    void update(Account account);

    @Select("select * from tbl_account")
    List<Account> findAll();

    @Select("select * from tbl_account where id = #{id} ")
    Account findById(Integer id);
}
```





整合Mybatis步骤：

1. 【第一步】导入Spring整合Mybatis依赖

   ```xml
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-jdbc</artifactId>
       <version>5.2.10.RELEASE</version>
   </dependency>
   
   <dependency>
       <groupId>org.mybatis</groupId>
       <artifactId>mybatis-spring</artifactId>
       <version>1.3.0</version>
   </dependency>
   ```

2. 【第二步】创建JdbcConfig配置DataSource数据源

   ```properties
   jdbc.driver=com.mysql.jdbc.Driver
   jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false
   jdbc.username=root
   jdbc.password=root
   ```

   ```java
   public class JdbcConfig {
       @Value("${jdbc.driver}")
       private String driver;
       @Value("${jdbc.url}")
       private String url;
       @Value("${jdbc.username}")
       private String userName;
       @Value("${jdbc.password}")
       private String password;
   
       @Bean
       public DataSource dataSource(){
           DruidDataSource ds = new DruidDataSource();
           ds.setDriverClassName(driver);
           ds.setUrl(url);
           ds.setUsername(userName);
           ds.setPassword(password);
           return ds;
       }
   }
   ```

3. 【第三步】创建MybatisConfig整合mybatis

   ```java
   public class MybatisConfig {
       //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象
       @Bean
       public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){
           SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
           ssfb.setTypeAliasesPackage("com.malu.domain");
           ssfb.setDataSource(dataSource);
           return ssfb;
       }
       //定义bean，返回MapperScannerConfigurer对象
       @Bean
       public MapperScannerConfigurer mapperScannerConfigurer(){
           MapperScannerConfigurer msc = new MapperScannerConfigurer();
           msc.setBasePackage("com.malu.dao");
           return msc;
       }
   }
   ```

   

4. 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类

   ```java
   @Configuration
   @ComponentScan("com.malu")
   //@PropertySource：加载类路径jdbc.properties文件
   @PropertySource("classpath:jdbc.properties")
   @Import({JdbcConfig.class,MybatisConfig.class})
   public class SpringConfig {
   }
   ```

5. 【第五步】定义测试类进行测试

   ```properties
   public class App {
       public static void main(String[] args) {
           ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
   
           AccountService accountService = ctx.getBean(AccountService.class);
   
           Account ac = accountService.findById(1);
           System.out.println(ac);
       }
   }
   ```



### 2，Spring整合Junit单元测试



Spring整合Junit单元测试步骤：

1. 【第一步】导入整合的依赖坐标spring-test

   ```xml
   <!--junit-->
   <dependency>
     <groupId>junit</groupId>
     <artifactId>junit</artifactId>
     <version>4.12</version>
   </dependency>
   <!--spring整合junit-->
   <dependency>
     <groupId>org.springframework</groupId>
     <artifactId>spring-test</artifactId>
     <version>5.1.9.RELEASE</version>
   </dependency>
   ```

2. 【第二步】使用Spring整合Junit专用的类加载器

3. 【第三步】加载配置文件或者配置类

   ```java
   //【第二步】使用Spring整合Junit专用的类加载器
   @RunWith(SpringJUnit4ClassRunner.class)
   //【第三步】加载配置文件或者配置类
   @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类
   //@ContextConfiguration(locations={"classpath:applicationContext.xml"})//加载配置文件
   public class AccountServiceTest {
       //支持自动装配注入bean
       @Autowired
       private AccountService accountService;
   
       @Test
       public void testFindById(){
           System.out.println(accountService.findById(1));
       }
   
       @Test
       public void testFindAll(){
           System.out.println(accountService.findAll());
       }
   }
   ```

   

注意细节：

- junit的依赖至少要是4.12版本,可以是4.13等版本,否则出现如下异常











## 十一，AOP快速入门

### 1，什么是AOP



我们之前学习的OOP(Object Oriented Programming)叫面向对象编程。是一种编程范式，指导开发者如何组织程序结构。那么接下来我们学习的AOP(Aspect Oriented Programming)，叫面向切面编程，也是一种编程范式。



作用：在不惊动原始设计的基础上为其进行功能增强。简单的说就是在不改变方法源代码的基础上对方法进行功能增强。无入侵式/无侵入式。



AOP核心概念：

![1702980593696](E:\javablog\blogs\ssm\assets\1702980593696.png)



连接点（JoinPoint）：

- 正在执行的方法，例如：update()、delete()、select()等都是连接点。

切入点（Pointcut）：

- 进行功能增强了的方法，例如:update()、delete()方法，select()方法没有被增强所以不是切入点，但是是连接点。
- 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
  - 一个具体方法：com.malu.dao包下的BookDao接口中的无形参无返回值的save方法
  - 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法

通知（Advice）：

- 在切入点前后执行的操作，也就是增强的共性功能。在SpringAOP中，功能最终以方法的形式呈现

通知类：

- 通知方法所在的类叫做通知类

切面（Aspect）：

- 描述通知与切入点的对应关系，也就是哪些通知方法对应哪些切入点方法。





### 2，AOP快速入门

AOP快速入门步骤如下：

1. 【第一步】导入aop相关坐标

   ```xml
   <dependencies>
       <!--spring核心依赖，会将spring-aop传递进来-->
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-context</artifactId>
           <version>5.2.10.RELEASE</version>
       </dependency>
       <!--切入点表达式依赖，目的是找到切入点方法，也就是找到要增强的方法-->
       <dependency>
           <groupId>org.aspectj</groupId>
           <artifactId>aspectjweaver</artifactId>
           <version>1.9.4</version>
       </dependency>
   </dependencies>
   ```

2. 【第二步】定义dao接口与实现类

   ```java
   public interface BookDao {
       public void save();
       public void update();
   }
   
   @Repository
   public class BookDaoImpl implements BookDao {
   
       public void save() {
           System.out.println(System.currentTimeMillis());
           System.out.println("book dao save ...");
       }
       public void update(){
           System.out.println("book dao update ...");
       }
   }
   ```

3. 【第三步】定义通知类，制作通知方法

   ```java
   //通知类必须配置成Spring管理的bean
   @Component
   public class MyAdvice {
       public void method(){
           System.out.println(System.currentTimeMillis());
       }
   }
   ```

4. 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系)

   ```java
   //通知类必须配置成Spring管理的bean
   @Component
   //设置当前类为切面类类
   @Aspect
   public class MyAdvice {
       //设置切入点，@Pointcut注解要求配置在方法上方
       @Pointcut("execution(void com.malu.dao.BookDao.update())")
       private void pt(){}
   
       //设置在切入点pt()的前面运行当前操作(前置通知)
       @Before("pt()")
       public void method(){
           System.out.println(System.currentTimeMillis());
       }
   }
   ```

5. 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能

   ```java
   @Configuration
   @ComponentScan("com.malu")
   //开启注解开发AOP功能
   @EnableAspectJAutoProxy
   public class SpringConfig {
   }
   ```

6.  测试类和运行结果

   ```java
   public class App {
       public static void main(String[] args) {
           ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
           BookDao bookDao = ctx.getBean(BookDao.class);
           bookDao.update();
       }
   }
   ```

   ![1702981239290](E:\javablog\blogs\ssm\assets\1702981239290.png)



### 3，AOP工作流程

AOP工作流程如下：

1. Spring容器启动
2. 读取所有切面配置中的切入点
3. 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点
   - 匹配失败，创建原始对象
   - 匹配成功，创建原始对象（目标对象）的代理对象
4. 获取bean执行方法
   - 获取的bean是原始对象时，调用方法并执行，完成操作
   - 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作



AOP核心概念：

- 目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。
- 代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。



在测试类中验证代理对象：

```java
public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        BookDao bookDao = ctx.getBean(BookDao.class);
        bookDao.update();
		//打印对象的类名
        System.out.println(bookDao.getClass());
    }
}
```

![1702981535024](E:\javablog\blogs\ssm\assets\1702981535024.png)



## 十三，AOP切入点表达式



### 1，语法格式

所谓的切入点就是要进行增强的方法，切入点表达式是要进行增强的方法的描述。

- 描述方式一：执行com.malu.dao包下的BookDao接口中的无参数update方法

  ```java
  execution(void com.malu.dao.BookDao.update())
  ```

- 描述方式二：执行com.malu.dao.impl包下的BookDaoImpl类中的无参数update方法

  ```java
  execution(void com.malu.dao.impl.BookDaoImpl.update())
  ```



切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名(参数) 异常名）

```java
execution(public User com.malu.service.UserService.findById(int))
```

- 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点
- 访问修饰符：public，private等，可以省略
- 返回值：写返回值类型
- 包名：多级包使用点连接
- 类/接口名
- 方法名
- 参数：直接写参数的类型，多个类型用逗号隔开
- 异常名：方法定义中抛出指定异常，可以省略





### 2，通配符

可以使用通配符描述切入点，快速描述。



单个*，可以独立出现，也可以作为前缀或者后缀的匹配符出现。如匹配com.malu包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法

```java
execution（public * com.malu.*.UserService.find*(*))
```



两个点，可以独立出现，常用于简化包名与参数的书写。如匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法

```java
execution（public User com..UserService.findById(..))
```



单个+，专用于匹配子类类型

```java
execution(* *..*Service+.*(..))
```



书写技巧（所有代码按照标准规范开发，否则以下技巧全部失效）：

- 描述切入点**通常描述接口**，而不描述实现类
- 访问控制修饰符针对接口开发均采用public描述（**可省略访问控制修饰符描述**）
- 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用\*通配快速描述
- **包名**书写**尽量不使用..匹配**，效率过低，常用\*做单个包描述匹配，或精准匹配
- **接口名/类名**书写名称与模块相关的**采用\*匹配**，例如UserService书写成\*Service，绑定业务层接口名
- **方法名**书写以**动词**进行**精准匹配**，名词采用星匹配，例如getById书写成getBy*,selectAll书写成selectAll
- 参数规则较为复杂，根据业务方法灵活调整
- 通常**不使用异常**作为**匹配**规则





## 十四，AOP通知类型



### 1，AOP通知的分类

AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置。AOP通知共分为5种类型

- 前置通知：在切入点方法执行之前执行
- 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。
- **环绕通知(重点)：**手动调用切入点方法并对其进行增强的通知方式。
- 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。
- 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。



### 2，AOP通知详解



##### 2.1 前置通知

- 名称：@Before
- 类型：**方法注解**
- 位置：通知方法定义上方
- 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行
- 范例：

```java
@Before("pt()")
public void before() {
    System.out.println("before advice ...");
}
```

##### 2.2 后置通知

- 名称：@After
- 类型：**方法注解**
- 位置：通知方法定义上方
- 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行
- 范例：

```java
@After("pt()")
public void after() {
    System.out.println("after advice ...");
}
```

##### 2.3 返回后通知

- 名称：@AfterReturning（了解）
- 类型：**方法注解**
- 位置：通知方法定义上方
- 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行
- 范例：

```java
@AfterReturning("pt()")
public void afterReturning() {
    System.out.println("afterReturning advice ...");
}
```

##### 2.4 抛出异常后通知

- 名称：@AfterThrowing（了解）
- 类型：**方法注解**
- 位置：通知方法定义上方
- 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行
- 范例：

```java
@AfterThrowing("pt()")
public void afterThrowing() {
    System.out.println("afterThrowing advice ...");
}
```

##### 5.2.5 环绕通知

- 名称：@Around（重点，常用）
- 类型：**方法注解**
- 位置：通知方法定义上方
- 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行
- 范例：：

```java
@Around("pt()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("around before advice ...");
    Object ret = pjp.proceed();
    System.out.println("around after advice ...");
    return ret;
}
```

**环绕通知注意事项**

1. 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。
2. 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。







## 十五，AOP案例

### 1，测试业务层接口万次执行效率



需求：任意业务层接口执行均可显示其执行效率（执行时长）



分析：

​	①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率
​	②：通知类型选择前后均可以增强的类型——环绕通知



实现流程：

1. 【第一步】编写通知类

   ```java
   @Component
   @Aspect
   public class ProjectAdvice {
       //匹配业务层的所有方法
       @Pointcut("execution(* com.malu.service.*Service.*(..))")
       private void servicePt(){}
   
       //设置环绕通知，在原始操作的运行前后记录执行时间
       @Around("ProjectAdvice.servicePt()") //本类类名可以省略不写
       public void runSpeed(ProceedingJoinPoint pjp) throws Throwable {
           //获取执行的签名对象
           Signature signature = pjp.getSignature();
           //获取接口/类全限定名
           String className = signature.getDeclaringTypeName();
           //获取方法名
           String methodName = signature.getName();
           //记录开始时间
           long start = System.currentTimeMillis();
           //执行万次操作
           for (int i = 0; i < 10000; i++) {
              pjp.proceed();
           }
           //记录结束时间
           long end = System.currentTimeMillis();
           //打印执行结果
           System.out.println("万次执行："+ className+"."+methodName+"---->" +(end-start) + "ms");
       }
   }
   ```

2. 【第二步】在SpringConfig配置类上开启AOP注解功能

   ```java
   @Configuration
   @ComponentScan("com.malu")
   @PropertySource("classpath:jdbc.properties")
   @Import({JdbcConfig.class,MybatisConfig.class})
   @EnableAspectJAutoProxy //开启AOP注解功能
   public class SpringConfig {
   }
   ```

3. 【第三步】运行测试类，查看结果

   ```java
   @RunWith(SpringJUnit4ClassRunner.class)
   @ContextConfiguration(classes = SpringConfig.class)
   public class AccountServiceTestCase {
       @Autowired
       private AccountService accountService;
       @Test
       public void testFindById(){
           Account account = accountService.findById(2);
       }
       @Test
       public void testFindAll(){
           List<Account> list = accountService.findAll();
       }
   }
   ```

4. 测试结果如下：





### 2，APO切入点数据获取



#### 2.1 获取参数

在前置通知和环绕通知中都可以获取到连接点方法的参数们。JoinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数

```java
@Before("pt()")
public void before(JoinPoint jp) {
    Object[] args = jp.getArgs(); //获取连接点方法的参数们
    System.out.println(Arrays.toString(args));
}
```



ProccedJointPoint是JoinPoint的子类

```java
@Around("pt()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs(); //获取连接点方法的参数们
    System.out.println(Arrays.toString(args));
    Object ret = pjp.proceed();
    return ret;
}
```



#### 2.2 获取返回值

在返回后通知和环绕通知中都可以获取到连接点方法的返回值，抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象

```java
@AfterReturning(value = "pt()",returning = "ret")
public void afterReturning(String ret) { //变量名要和returning="ret"的属性值一致
    System.out.println("afterReturning advice ..."+ret);
}
```



环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值

```java
@Around("pt()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    // 手动调用连接点方法，返回值就是连接点方法的返回值
    Object ret = pjp.proceed();
    return ret;
}
```





#### 2.4 获取异常

在抛出异常后通知和环绕通知中都可以获取到连接点方法中出现的异常，抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象

```java
@AfterThrowing(value = "pt()",throwing = "t")
public void afterThrowing(Throwable t) {//变量名要和throwing = "t"的属性值一致
    System.out.println("afterThrowing advice ..."+ t);
}
```



抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象

```java
@Around("pt()")
public Object around(ProceedingJoinPoint pjp)  {
    Object ret = null;
    //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常
    try {
        ret = pjp.proceed();
    } catch (Throwable t) {
        t.printStackTrace();
    }
    return ret;
}
```





### 3，AOP开发总结



**作用：**

- 在不惊动原始设计的基础上为方法进行功能增强

  

**核心概念：**

- 代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的
- 连接点（JoinPoint）：	在SpringAOP中，理解为任意方法的执行
- 切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述
- 通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法
- 切面（Aspect）：描述通知与切入点的对应关系
- 目标对象（Target）：被代理的原始对象成为目标对象



**切入点表达式语法:**

- 切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类/接口名.方法名（参数）异常名)

  - execution(* com.malu.service.* Service.*(..))

- 切入点表达式描述通配符：

  - 作用：用于快速描述，范围描述
  - *：匹配任意符号（常用）
  - .. ：匹配多个连续的任意符号（常用）
  - +：匹配子类类型

- 切入点表达式书写技巧

  1.按标准规范开发
  2.查询操作的返回值建议使用\*匹配
  3.减少使用..的形式描述包
  4.对接口进行描述，使用\*表示模块名，例如UserService的匹配描述为*Service
  5.方法名书写保留动词，例如get，使用\*表示名词，例如getById匹配描述为getBy\*
  6.参数根据实际情况灵活调整



**五种通知类型：**

- 前置通知
- 后置通知
  - 环绕通知（重点）
  - 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用
  - 环绕通知可以隔离原始方法的调用执行
  - 环绕通知返回值设置为Object类型
  - 环绕通知中可以对原始方法调用过程中出现的异常进行处理
- 返回后通知
- 抛出异常后通知



## 十六，Spring事务管理





















































