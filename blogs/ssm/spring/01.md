---
title: 新版Spring
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - ssm
categories:
 - ssm
---

## 1，Spring介绍

Spring是一个开源框架，为简化企业级开发而生。它以IOC（控制反转）和AOP（面向切面）为思想内核，提供了控制层SpringMVC、数据层SpringData、服务层事务管理等众多技术，并可以整合众多第三方框架。Spring官网地址：https://spring.io/



Spring将很多复杂的代码变得优雅简洁，有效的降低代码的耦合度，极大的方便项目的后期维护、升级和扩展。



## 2，Spring体系结构

![1722348314593](./assets/1722348314593.png)

Spring框架根据不同的功能被划分成了多个模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。

- Core Container：Spring核心模块，任何功能的使用都离不开该模块，是其他模块建立的基础。
- Data Access/Integration：该模块提供了数据持久化的相应功能。
- Web：该模块提供了web开发的相应功能。
- AOP：提供了面向切面编程实现
- Aspects：提供与AspectJ框架的集成，该框架是一个面向切面编程框架。
- Instrumentation：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。
- Messaging：为Spring框架集成一些基础的报文传送应用
- Test：提供与测试框架的集成











## 3，IOC控制反转

![1722348412625](./assets/1722348412625.png)



IOC(Inversion of Control) ：程序将创建对象的权利交给框架。之前在开发过程中，对象实例的创建是由调用者管理的，创建一个基于maven的项目，不需要创建web项目，如下：

![1722408524841](./assets/1722408524841.png)

![1722408548639](./assets/1722408548639.png)

![1722408587073](./assets/1722408587073.png)



引入依赖：

![1722408628476](./assets/1722408628476.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.malu</groupId>
    <artifactId>spring_ioc01</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- spring核心模块 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- junit -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```



创建实体类：

![1722408759703](./assets/1722408759703.png)

```java
package com.malu.domain;

public class Student {
    private int id;
    private String name;
    private String address;

    public Student() {
    }

    public Student(int id, String name, String address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

```



写一个dao层的接口：

![1722408815604](./assets/1722408815604.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public interface StudentDao {
    // 根据id查询学生
    Student findById(int id);
}
```



自己写接口的实现类：

![1722408912225](./assets/1722408912225.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl implements StudentDao {
    @Override
    public Student findById(int id) {
        return new Student(1,"malu","bj");
    }
}

```



然后写service层：

![1722409338018](./assets/1722409338018.png)

```java
package com.malu.service;

import com.malu.dao.StudentDao;
import com.malu.dao.StudentDaoImpl;
import com.malu.domain.Student;

public class StudentService {
    private StudentDao studentDao = new StudentDaoImpl();

    public Student findStudentById(int id){
        return studentDao.findById(id);
    }
}
```



Dao层还可以有新的实现类，如下：

![1722409552011](./assets/1722409552011.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl2 implements StudentDao {
    @Override
    public Student findById(int id) {
        System.out.println("新的实现类~");
        return new Student(1,"wc","sh");
    }
}

```



如果service层，要使用StudentDaoImpl2，就需要修改源码：

![1722409592437](./assets/1722409592437.png)



这种写法有两个缺点：

- 浪费资源：StudentService调用方法时即会创建一个对象，如果不断调用方法则会创建大量StudentDao对象。
- 代码耦合度高：假设随着开发，我们创建了StudentDao另一个更加完善的实现类StudentDaoImpl2，如果在StudentService中想使用StudentDaoImpl2，则必须修改源码。



而IOC思想是将创建对象的权利交给框架，框架会帮助我们创建对象，分配对象的使用，控制权由程序代码转移到了框架中，控制权发生了反转，这就是Spring的IOC思想。而IOC思想可以完美的解决以上两个问题。





## 4，Spring实现IOC

![1722348544660](./assets/1722348544660.png)



接下来我们使用Spring实现IOC，Spring内部也有一个容器用来管理对象。创建Maven工程：

![1722409820750](./assets/1722409820750.png)



引入依赖：

![1722409841022](./assets/1722409841022.png)

```xml
    <dependencies>
        <!-- spring核心模块 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- junit -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
```



创建POJO类:

![1722409877335](./assets/1722409877335.png)

```java
package com.malu.domain;

public class Student {
    private int id;
    private String name;
    private String address;

    public Student() {
    }

    public Student(int id, String name, String address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```





Dao接口和实现类:

![1722409911430](./assets/1722409911430.png)

![1722409948088](./assets/1722409948088.png)

![1722409960896](./assets/1722409960896.png)



编写xml配置文件，配置文件中配置需要Spring帮我们创建的对象。

![1722410157099](./assets/1722410157099.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl"></bean>

</beans>
```



测试从Spring容器中获取对象。

![1722410505587](./assets/1722410505587.png)

```java
import com.malu.dao.StudentDao;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestContainer {

    @Test
    public void t1(){
        // 得到容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        // 从容器中得到对象
        StudentDao studentDao1 = (StudentDao)ac.getBean("studentDao");
        StudentDao studentDao2 = (StudentDao)ac.getBean("studentDao");

        System.out.println(studentDao1);
        System.out.println(studentDao2);
        System.out.println(studentDao1.hashCode());
        System.out.println(studentDao2.hashCode());

        System.out.println(studentDao1.findById(1));
    }
}

```



测试结果：

![1722410532575](./assets/1722410532575.png)



## 5，Spring容器类型

![1722348752180](./assets/1722348752180.png)



容器接口：

- BeanFactory：BeanFactory是Spring容器中的顶层接口，它可以对Bean对象进行管理。
- ApplicationContext：ApplicationContext是BeanFactory的子接口。它除了继承 BeanFactory的所有功能外，还添加了对国际化、资源访问、事件传播等方面的良好支持。ApplicationContext有以下三个常用实现类：
  - ClassPathXmlApplicationContext：该类可以从项目中读取配置文件
  - FileSystemXmlApplicationContext：该类从磁盘中读取配置文件
  - AnnotationConfigApplicationContext：使用该类不读取配置文件，而是会读取注解



演示：

![1722411231559](./assets/1722411231559.png)



## 6，对象的创建方式

复习一下：

![1722411847881](./assets/1722411847881.png)



Spring会帮助我们创建bean，那么它底层是调用什么方法进行创建的呢？Spring默认使用类的空参构造方法创建bean：

![1722412069266](./assets/1722412069266.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl implements StudentDao {
    // 这里默认有一个无构造器，也就是说Spring是通过这个无参构造器创建的对象

    // 自己手写了一个有参构造器，那么就不会生成无参构造器
    // 问：Spring能不能把这个对象创建出来呢？ 答：不能
    public StudentDaoImpl(int a){}

    @Override
    public Student findById(int id) {
        // 模拟从数据为中查找到的数据
        return new Student(1,"malu","bj");
    }
}
```



此时，Spring就不能帮我们创建对象了，如下：

![1722412156515](./assets/1722412156515.png)



Spring可以调用工厂类的方法创建bean，创建工厂类，工厂类提供创建对象的方法：

![1722412331660](./assets/1722412331660.png)

```java
package com.malu.dao;

public class StudentDaoFactory {
    public StudentDao getStudentDao(){
        return new StudentDaoImpl(1);
    }
}

```





在配置文件中配置创建bean的方式为工厂方式。

![1722412566527](./assets/1722412566527.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--工厂类的bean-->
    <bean id="studentDaoFactory" class="com.malu.dao.StudentDaoFactory"></bean>

    <!--id: bean对象的id, factory-bean: 工厂对象的id， factory-method：工厂方法-->
    <bean id="studentDao" factory-bean="studentDaoFactory" factory-method="getStudentDao"></bean>

</beans>


```



测试：

![1722412639729](./assets/1722412639729.png)



Spring可以调用工厂类的静态方法创建bean，创建工厂类，工厂提供创建对象的静态方法。

![1722412713994](./assets/1722412713994.png)

```java
public class StudentDaoFactory {
    public static StudentDao getStudentDao(){
        return new StudentDaoImpl(1);
    }
}
```





在配置文件中配置创建bean的方式为工厂静态方法。

![1722412782630](./assets/1722412782630.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoFactory" factory-method="getStudentDao"></bean>

</beans>
```



测试:

![1722412813942](./assets/1722412813942.png)



## 7，对象的创建策略



Spring通过配置  中的 scope 属性设置对象的创建策略，共有五种创建策略：

- singleton：单例，默认策略。整个项目只会创建一个对象，通过  bean中的 lazy-init 属性可以设置单例对象的创建时机：
  - lazy-init="false"(默认)：立即创建，在容器启动时会创建配置文件中的所有Bean对象。
  - lazy-init="true"：延迟创建，第一次使用Bean对象时才会创建。
- prototype：多例，每次从容器中获取时都会创建对象。
- request：每次请求创建一个对象，只在web环境有效。
- session：每次会话创建一个对象，只在web环境有效。
- gloabal-session：一次集群环境的会话创建一个对象，只在web环境有效。



配置单例策略：

![1722413247876](./assets/1722413247876.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl" scope="singleton" lazy-init="true"></bean>

</beans>

```





测试单例策略：

![1722413326800](./assets/1722413326800.png)

```java
    @Test
    public void t1(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        StudentDao studentDao1 = (StudentDao)ac.getBean("studentDao");
        StudentDao studentDao2 = (StudentDao)ac.getBean("studentDao");
        StudentDao studentDao3 = (StudentDao)ac.getBean("studentDao");
        System.out.println(studentDao1.hashCode());
        System.out.println(studentDao2.hashCode());
        System.out.println(studentDao3.hashCode());
    }
```



配置多例：

![1722413398794](./assets/1722413398794.png)

![1722413425372](./assets/1722413425372.png)

```java
<bean id="studentDao" class="com.malu.dao.StudentDaoImpl" scope="prototype" lazy-init="true"></bean>
```







## 8，对象的销毁时机

对象的创建策略不同，销毁时机也不同：

- singleton：对象随着容器的销毁而销毁。
- prototype：使用JAVA垃圾回收机制销毁对象。
- request：当处理请求结束，bean实例将被销毁。
- session：当HTTP Session最终被废弃的时候，bean也会被销毁掉。
- gloabal-session：集群环境下的session销毁，bean实例也将被销毁。



## 9，生命周期方法

Bean对象的生命周期包含创建——使用——销毁，Spring可以配置Bean对象在创建和销毁时自动执行的方法，定义生命周期方法:

![1722413670477](./assets/1722413670477.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl implements StudentDao {
    public void init(){
        System.out.println("创建StudentDaoImpl...");
    }
    @Override
    public Student findById(int id) {
        return new Student(1,"malu","bj");
    }
    public void destory(){
        System.out.println("销毁StudentDaoImpl...");
    }
}
```





配置生命周期方法：

![1722413740530](./assets/1722413740530.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- init-method:创建对象时执行的方法 -->
    <!-- destroy-method:销毁对象时执行的方法 -->
    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl" init-method="init" destroy-method="destory"></bean>

</beans>

```



测试：

![1722413833928](./assets/1722413833928.png)

```java
    @Test
    public void t1(){
        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        StudentDao studentDao1 = (StudentDao)ac.getBean("studentDao");

        ac.close();
    }
```



## 10，获取Bean对象的方式

Spring有多种获取容器中对象的方式：

- 通过id/name获取
- 通过类型获取
- 通过类型+id/name获取



通过id获取：

![1722413971269](./assets/1722413971269.png)



通过name获取：

![1722414034650](./assets/1722414034650.png)





通过类型获取：

![1722414157079](./assets/1722414157079.png)

可以看到使用类型获取不需要强转。



虽然使用类型获取不需要强转，但如果在容器中有一个接口的多个实现类对象，则获取时会报错，如下：

![1722414231874](./assets/1722414231874.png)

![1722414323401](./assets/1722414323401.png)



此时需要使用类型+id/name获取：

![1722414400402](./assets/1722414400402.png)





## 11，什么是依赖注入



复习：

![1722414571483](./assets/1722414571483.png)

![1722414631735](./assets/1722414631735.png)



依赖注入（Dependency Injection，简称DI），它是Spring控制反转思想的具体实现。控制反转将对象的创建交给了Spring，但是对象中可能会依赖其他对象。比如service类中要有dao类的属性，我们称service依赖于dao。之前需要手动注入属性值，代码如下：

![1722414848267](./assets/1722414848267.png)

```java
package com.malu.service;

import com.malu.dao.StudentDao;
import com.malu.dao.StudentDaoImpl;
import com.malu.domain.Student;

public class StudentService {
    private StudentDao studentDao = new StudentDaoImpl();

    public Student findStudentById(int id){
        return studentDao.findById(1);
    }
}
```





此时，当StudentService的想要使用StudentDao的另一个实现类如StudentDaoImpl2时，则需要修改Java源码，造成代码的可维护性降低。



而使用Spring框架后，Spring管理Service对象与Dao对象，此时它能够为Service对象注入依赖的Dao属性值。这就是Spring的依赖注入。简单来说，控制反转是创建对象，依赖注入是为对象的属性赋值。



## 12，依赖注入方式



在之前开发中，可以通过setter方法或构造方法设置对象属性值：



Spring可以通过调用setter方法或构造方法给属性赋值



## 13，依赖注入类型

![1722349225767](./assets/1722349225767.png)





## 14，注解实现IOC
## 15，@Component
## 16，@Repository, @Service,@Controller
## 17，@Scope
## 18，@Autowired
## 19，@Qualifier
## 20，@Value
## 21，@Configuration
## 22，@ComponentScan
## 23，@PropertySource
## 24，@Bean
## 25，@Import
## 26，Spring整合MyBatis
## 27，Spring整合Junit
## 28，自动创建代理对象
## 29，AOP简介
## 30，AOP相关术语
## 31，AOP入门
## 32，通知类型
## 33，切点表达式
## 34，多切面配置
## 35，注解配置AOP
## 36，原生Spring实现AOP
## 37，SchemaBased实现AOP

## 38，Spring事务
## 39，Spring事务管理方案
## 40，Spring事务管理器
## 41，事务控制API
## 42，事务传播行为
## 43，事务的隔离级别
## 44，注解配置声明式事务


