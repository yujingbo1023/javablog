---
title: 新版Spring
date: 2028-12-15
sticky: 1
sidebar: 'auto'
tags:
 - ssm
categories:
 - ssm
---

## 1，Spring介绍

Spring是一个开源框架，为简化企业级开发而生。它以IOC（控制反转）和AOP（面向切面）为思想内核，提供了控制层SpringMVC、数据层SpringData、服务层事务管理等众多技术，并可以整合众多第三方框架。Spring官网地址：https://spring.io/



Spring将很多复杂的代码变得优雅简洁，有效的降低代码的耦合度，极大的方便项目的后期维护、升级和扩展。



## 2，Spring体系结构

![1722348314593](./assets/1722348314593.png)

Spring框架根据不同的功能被划分成了多个模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。

- Core Container：Spring核心模块，任何功能的使用都离不开该模块，是其他模块建立的基础。
- Data Access/Integration：该模块提供了数据持久化的相应功能。
- Web：该模块提供了web开发的相应功能。
- AOP：提供了面向切面编程实现
- Aspects：提供与AspectJ框架的集成，该框架是一个面向切面编程框架。
- Instrumentation：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。
- Messaging：为Spring框架集成一些基础的报文传送应用
- Test：提供与测试框架的集成











## 3，IOC控制反转

![1722348412625](./assets/1722348412625.png)



IOC(Inversion of Control) ：程序将创建对象的权利交给框架。之前在开发过程中，对象实例的创建是由调用者管理的，创建一个基于maven的项目，不需要创建web项目，如下：

![1722408524841](./assets/1722408524841.png)

![1722408548639](./assets/1722408548639.png)

![1722408587073](./assets/1722408587073.png)



引入依赖：

![1722408628476](./assets/1722408628476.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.malu</groupId>
    <artifactId>spring_ioc01</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- spring核心模块 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- junit -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```



创建实体类：

![1722408759703](./assets/1722408759703.png)

```java
package com.malu.domain;

public class Student {
    private int id;
    private String name;
    private String address;

    public Student() {
    }

    public Student(int id, String name, String address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

```



写一个dao层的接口：

![1722408815604](./assets/1722408815604.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public interface StudentDao {
    // 根据id查询学生
    Student findById(int id);
}
```



自己写接口的实现类：

![1722408912225](./assets/1722408912225.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl implements StudentDao {
    @Override
    public Student findById(int id) {
        return new Student(1,"malu","bj");
    }
}

```



然后写service层：

![1722409338018](./assets/1722409338018.png)

```java
package com.malu.service;

import com.malu.dao.StudentDao;
import com.malu.dao.StudentDaoImpl;
import com.malu.domain.Student;

public class StudentService {
    private StudentDao studentDao = new StudentDaoImpl();

    public Student findStudentById(int id){
        return studentDao.findById(id);
    }
}
```



Dao层还可以有新的实现类，如下：

![1722409552011](./assets/1722409552011.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl2 implements StudentDao {
    @Override
    public Student findById(int id) {
        System.out.println("新的实现类~");
        return new Student(1,"wc","sh");
    }
}

```



如果service层，要使用StudentDaoImpl2，就需要修改源码：

![1722409592437](./assets/1722409592437.png)



这种写法有两个缺点：

- 浪费资源：StudentService调用方法时即会创建一个对象，如果不断调用方法则会创建大量StudentDao对象。
- 代码耦合度高：假设随着开发，我们创建了StudentDao另一个更加完善的实现类StudentDaoImpl2，如果在StudentService中想使用StudentDaoImpl2，则必须修改源码。



而IOC思想是将创建对象的权利交给框架，框架会帮助我们创建对象，分配对象的使用，控制权由程序代码转移到了框架中，控制权发生了反转，这就是Spring的IOC思想。而IOC思想可以完美的解决以上两个问题。





## 4，Spring实现IOC

![1722348544660](./assets/1722348544660.png)



接下来我们使用Spring实现IOC，Spring内部也有一个容器用来管理对象。创建Maven工程：

![1722409820750](./assets/1722409820750.png)



引入依赖：

![1722409841022](./assets/1722409841022.png)

```xml
    <dependencies>
        <!-- spring核心模块 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- junit -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
```



创建POJO类:

![1722409877335](./assets/1722409877335.png)

```java
package com.malu.domain;

public class Student {
    private int id;
    private String name;
    private String address;

    public Student() {
    }

    public Student(int id, String name, String address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```





Dao接口和实现类:

![1722409911430](./assets/1722409911430.png)

![1722409948088](./assets/1722409948088.png)

![1722409960896](./assets/1722409960896.png)



编写xml配置文件，配置文件中配置需要Spring帮我们创建的对象。

![1722410157099](./assets/1722410157099.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl"></bean>

</beans>
```



测试从Spring容器中获取对象。

![1722410505587](./assets/1722410505587.png)

```java
import com.malu.dao.StudentDao;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class TestContainer {

    @Test
    public void t1(){
        // 得到容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        // 从容器中得到对象
        StudentDao studentDao1 = (StudentDao)ac.getBean("studentDao");
        StudentDao studentDao2 = (StudentDao)ac.getBean("studentDao");

        System.out.println(studentDao1);
        System.out.println(studentDao2);
        System.out.println(studentDao1.hashCode());
        System.out.println(studentDao2.hashCode());

        System.out.println(studentDao1.findById(1));
    }
}

```



测试结果：

![1722410532575](./assets/1722410532575.png)



## 5，Spring容器类型

![1722348752180](./assets/1722348752180.png)



容器接口：

- BeanFactory：BeanFactory是Spring容器中的顶层接口，它可以对Bean对象进行管理。
- ApplicationContext：ApplicationContext是BeanFactory的子接口。它除了继承 BeanFactory的所有功能外，还添加了对国际化、资源访问、事件传播等方面的良好支持。ApplicationContext有以下三个常用实现类：
  - ClassPathXmlApplicationContext：该类可以从项目中读取配置文件
  - FileSystemXmlApplicationContext：该类从磁盘中读取配置文件
  - AnnotationConfigApplicationContext：使用该类不读取配置文件，而是会读取注解



演示：

![1722411231559](./assets/1722411231559.png)



## 6，对象的创建方式

复习一下：

![1722411847881](./assets/1722411847881.png)



Spring会帮助我们创建bean，那么它底层是调用什么方法进行创建的呢？Spring默认使用类的空参构造方法创建bean：

![1722412069266](./assets/1722412069266.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl implements StudentDao {
    // 这里默认有一个无构造器，也就是说Spring是通过这个无参构造器创建的对象

    // 自己手写了一个有参构造器，那么就不会生成无参构造器
    // 问：Spring能不能把这个对象创建出来呢？ 答：不能
    public StudentDaoImpl(int a){}

    @Override
    public Student findById(int id) {
        // 模拟从数据为中查找到的数据
        return new Student(1,"malu","bj");
    }
}
```



此时，Spring就不能帮我们创建对象了，如下：

![1722412156515](./assets/1722412156515.png)



Spring可以调用工厂类的方法创建bean，创建工厂类，工厂类提供创建对象的方法：

![1722412331660](./assets/1722412331660.png)

```java
package com.malu.dao;

public class StudentDaoFactory {
    public StudentDao getStudentDao(){
        return new StudentDaoImpl(1);
    }
}

```





在配置文件中配置创建bean的方式为工厂方式。

![1722412566527](./assets/1722412566527.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--工厂类的bean-->
    <bean id="studentDaoFactory" class="com.malu.dao.StudentDaoFactory"></bean>

    <!--id: bean对象的id, factory-bean: 工厂对象的id， factory-method：工厂方法-->
    <bean id="studentDao" factory-bean="studentDaoFactory" factory-method="getStudentDao"></bean>

</beans>


```



测试：

![1722412639729](./assets/1722412639729.png)



Spring可以调用工厂类的静态方法创建bean，创建工厂类，工厂提供创建对象的静态方法。

![1722412713994](./assets/1722412713994.png)

```java
public class StudentDaoFactory {
    public static StudentDao getStudentDao(){
        return new StudentDaoImpl(1);
    }
}
```





在配置文件中配置创建bean的方式为工厂静态方法。

![1722412782630](./assets/1722412782630.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoFactory" factory-method="getStudentDao"></bean>

</beans>
```



测试:

![1722412813942](./assets/1722412813942.png)



## 7，对象的创建策略



Spring通过配置  中的 scope 属性设置对象的创建策略，共有五种创建策略：

- singleton：单例，默认策略。整个项目只会创建一个对象，通过  bean中的 lazy-init 属性可以设置单例对象的创建时机：
  - lazy-init="false"(默认)：立即创建，在容器启动时会创建配置文件中的所有Bean对象。
  - lazy-init="true"：延迟创建，第一次使用Bean对象时才会创建。
- prototype：多例，每次从容器中获取时都会创建对象。
- request：每次请求创建一个对象，只在web环境有效。
- session：每次会话创建一个对象，只在web环境有效。
- gloabal-session：一次集群环境的会话创建一个对象，只在web环境有效。



配置单例策略：

![1722413247876](./assets/1722413247876.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl" scope="singleton" lazy-init="true"></bean>

</beans>

```





测试单例策略：

![1722413326800](./assets/1722413326800.png)

```java
    @Test
    public void t1(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        StudentDao studentDao1 = (StudentDao)ac.getBean("studentDao");
        StudentDao studentDao2 = (StudentDao)ac.getBean("studentDao");
        StudentDao studentDao3 = (StudentDao)ac.getBean("studentDao");
        System.out.println(studentDao1.hashCode());
        System.out.println(studentDao2.hashCode());
        System.out.println(studentDao3.hashCode());
    }
```



配置多例：

![1722413398794](./assets/1722413398794.png)

![1722413425372](./assets/1722413425372.png)

```java
<bean id="studentDao" class="com.malu.dao.StudentDaoImpl" scope="prototype" lazy-init="true"></bean>
```







## 8，对象的销毁时机

对象的创建策略不同，销毁时机也不同：

- singleton：对象随着容器的销毁而销毁。
- prototype：使用JAVA垃圾回收机制销毁对象。
- request：当处理请求结束，bean实例将被销毁。
- session：当HTTP Session最终被废弃的时候，bean也会被销毁掉。
- gloabal-session：集群环境下的session销毁，bean实例也将被销毁。



## 9，生命周期方法

Bean对象的生命周期包含创建——使用——销毁，Spring可以配置Bean对象在创建和销毁时自动执行的方法，定义生命周期方法:

![1722413670477](./assets/1722413670477.png)

```java
package com.malu.dao;

import com.malu.domain.Student;

public class StudentDaoImpl implements StudentDao {
    public void init(){
        System.out.println("创建StudentDaoImpl...");
    }
    @Override
    public Student findById(int id) {
        return new Student(1,"malu","bj");
    }
    public void destory(){
        System.out.println("销毁StudentDaoImpl...");
    }
}
```





配置生命周期方法：

![1722413740530](./assets/1722413740530.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- init-method:创建对象时执行的方法 -->
    <!-- destroy-method:销毁对象时执行的方法 -->
    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl" init-method="init" destroy-method="destory"></bean>

</beans>

```



测试：

![1722413833928](./assets/1722413833928.png)

```java
    @Test
    public void t1(){
        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        StudentDao studentDao1 = (StudentDao)ac.getBean("studentDao");

        ac.close();
    }
```



## 10，获取Bean对象的方式

Spring有多种获取容器中对象的方式：

- 通过id/name获取
- 通过类型获取
- 通过类型+id/name获取



通过id获取：

![1722413971269](./assets/1722413971269.png)



通过name获取：

![1722414034650](./assets/1722414034650.png)





通过类型获取：

![1722414157079](./assets/1722414157079.png)

可以看到使用类型获取不需要强转。



虽然使用类型获取不需要强转，但如果在容器中有一个接口的多个实现类对象，则获取时会报错，如下：

![1722414231874](./assets/1722414231874.png)

![1722414323401](./assets/1722414323401.png)



此时需要使用类型+id/name获取：

![1722414400402](./assets/1722414400402.png)





## 11，什么是依赖注入



复习：

![1722414571483](./assets/1722414571483.png)

![1722414631735](./assets/1722414631735.png)



Dao层代码：

![1722474852499](./assets/1722474852499.png)

依赖注入（Dependency Injection，简称DI），它是Spring控制反转思想的具体实现。控制反转将对象的创建交给了Spring，但是对象中可能会依赖其他对象。比如service类中要有dao类的属性，我们称service依赖于dao。之前需要手动注入属性值，代码如下：

![1722414848267](./assets/1722414848267.png)

```java
package com.malu.service;

import com.malu.dao.StudentDao;
import com.malu.dao.StudentDaoImpl;
import com.malu.domain.Student;

public class StudentService {
    private StudentDao studentDao = new StudentDaoImpl();

    public Student findStudentById(int id){
        return studentDao.findById(1);
    }
}
```



此时，当StudentService的想要使用StudentDao的另一个实现类如StudentDaoImpl2时，则需要修改Java源码，造成代码的可维护性降低。



而使用Spring框架后，Spring管理Service对象与Dao对象，此时它能够为Service对象注入依赖的Dao属性值。这就是Spring的依赖注入。简单来说，控制反转是创建对象，依赖注入是为对象的属性赋值。



## 12，依赖注入方式



在之前开发中，可以通过setter方法设置对象属性值：

![1722475251709](./assets/1722475251709.png)



还可以通过构造方法设置对象属性值：

![1722475325137](./assets/1722475325137.png)



Spring可以通过调用setter方法或构造方法给属性赋值，先看一下Setter注入，被注入类编写属性的setter方法，如下：

![1722475410898](./assets/1722475410898.png)

```java
public class StudentService {
    private StudentDao studentDao;

    public void setStudentDao(StudentDao studentDao) {
        this.studentDao = studentDao;
    }

    public Student findStudentById(int id){
        return studentDao.findById(1);
    }
}
```



在配置文件中，给需要注入属性值的bean中设置property，如下：

![1722475609809](./assets/1722475609809.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl"></bean>

    <bean id="studentService" class="com.malu.service.StudentService">
        <!-- 依赖注入 name:对象中的属性名  ref:容器中对象的ID值 -->
        <property name="studentDao" ref="studentDao"></property>
    </bean>

</beans>

```



测试是否注入成功：

![1722475724082](./assets/1722475724082.png)

```java
public class TestContainer {

    @Test
    public void t1(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        StudentService studentService = ac.getBean("studentService", StudentService.class);

        System.out.println(studentService.findStudentById(1));
    }
}
```



构造器方法注入，被注入类编写有参的构造方法，如下：

![1722476045342](./assets/1722476045342.png)

```java
public class StudentService {
    private StudentDao studentDao;

    public StudentService(StudentDao studentDao) {
        this.studentDao = studentDao;
    }

    public Student findStudentById(int id){
        return studentDao.findById(1);
    }
}
```



给需要注入属性值的  bean 中设置 constructor-arg，如下：

![1722476174452](./assets/1722476174452.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="studentDao" class="com.malu.dao.StudentDaoImpl"></bean>

    <bean id="studentService" class="com.malu.service.StudentService">
        <!--依赖注入  name: 对象的属性名  ref: 容器中对象的ID值-->
        <constructor-arg name="studentDao" ref="studentDao"></constructor-arg>
    </bean>

</beans>

```



测试：

![1722476201232](./assets/1722476201232.png)



上面的两种注入方法，都是手动的注入，还有一种注入方式，叫自动注入，自动注入不需要在  bean 标签中添加其他标签注入属性值，而是自动从容器中找到相应的bean对象设置为属性值。



自动注入有两种配置方式：

- 全局配置：在beans标签中设置 default-autowire 属性可以定义所有bean对象的自动注入策略。
- 局部配置：在bean 中设置 autowire 属性可以定义当前bean对象的自动注入策略。



autowire的取值：

- no：不会进行自动注入。
- default：全局配置default相当于no，局部配置default表示使用全局配置
- byName：在Spring容器中查找id与属性名相同的bean，并进行注入。需要提供set方法。
- byType：在Spring容器中查找类型与属性类型相同的bean，并进行注入。需要提供set方法。
- constructor：在Spring容器中查找id与属性名相同的bean，并进行注入。需要提供构造方法。



代码演示，提供setter和构造器：

![1722476849468](./assets/1722476849468.png)



开始配置自动依赖注入，根据beanId等于属性名自动注入：

![1722476985450](./assets/1722476985450.png)

![1722477110772](./assets/1722477110772.png)



继续配置自动依赖注入，根据bean类型等于属性类型自动注入：

![1722477176217](./assets/1722477176217.png)





利用构造方法自动注入：

![1722477283708](./assets/1722477283708.png)



配置全局自动注入：

![1722477364711](./assets/1722477364711.png)



## 13，依赖注入类型

![1722349225767](./assets/1722349225767.png)

DI支持注入bean类型、基本数据类型和字符串、List集合、Set集合、Map集合、Properties对象类型等，他们的写法如下：

![1722477731844](./assets/1722477731844.png)

```java
package com.malu.service;

import com.malu.dao.StudentDao;
import com.malu.dao.StudentDaoImpl;
import com.malu.domain.Student;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class StudentService {
    private StudentDao studentDao;  // bean属性
    private String name; //字符串类型
    private int count; //基本数据类型
    private List<String> names; // 字符串类型List集合
    private List<Student> students1; // 对象类型List集合
    private Set<Student> students2; // 对象类型Set集合
    private Map<String, String> names2; // 字符串类型Map集合
    private Map<String, Student> students3; // 对象类型Map集合
    private Properties properties; //Properties类型

    public StudentService() {
    }

    public StudentDao getStudentDao() {
        return studentDao;
    }

    public void setStudentDao(StudentDao studentDao) {
        this.studentDao = studentDao;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public List<String> getNames() {
        return names;
    }

    public void setNames(List<String> names) {
        this.names = names;
    }

    public List<Student> getStudents1() {
        return students1;
    }

    public void setStudents1(List<Student> students1) {
        this.students1 = students1;
    }

    public Set<Student> getStudents2() {
        return students2;
    }

    public void setStudents2(Set<Student> students2) {
        this.students2 = students2;
    }

    public Map<String, String> getNames2() {
        return names2;
    }

    public void setNames2(Map<String, String> names2) {
        this.names2 = names2;
    }

    public Map<String, Student> getStudents3() {
        return students3;
    }

    public void setStudents3(Map<String, Student> students3) {
        this.students3 = students3;
    }

    public Properties getProperties() {
        return properties;
    }

    public void setProperties(Properties properties) {
        this.properties = properties;
    }

    @Override
    public String toString() {
        return "StudentService{" +
                "studentDao=" + studentDao +
                ", name='" + name + '\'' +
                ", count=" + count +
                ", names=" + names +
                ", students1=" + students1 +
                ", students2=" + students2 +
                ", names2=" + names2 +
                ", students3=" + students3 +
                ", properties=" + properties +
                '}';
    }

    public Student findStudentById(int id){
        return studentDao.findById(1);
    }
}

```



测试方法：

![1722477791993](./assets/1722477791993.png)

```java
    @Test
    public void t1(){
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        StudentService studentService = ac.getBean("studentService", StudentService.class);

        System.out.println(studentService);
    }
```



注入bean类型，写法一：

![1722477898622](./assets/1722477898622.png)



注入bean类型，写法二：

![1722477942658](./assets/1722477942658.png)



注入基本数据类型写法一：

![1722478013630](./assets/1722478013630.png)



注入基本数据类型写法二：

![1722478060000](./assets/1722478060000.png)



简单类型的List集合：

![1722478205268](./assets/1722478205268.png)



对象类型List集合：

![1722478319411](./assets/1722478319411.png)



注入Set集合：

![1722478929177](./assets/1722478929177.png)



简单数据类型Map集合：

![1722479031302](./assets/1722479031302.png)



对象类型Map集合：

![1722479182081](./assets/1722479182081.png)



注入Properties对象：

![1722479255059](./assets/1722479255059.png)



## 14，注解实现IOC

注解配置和xml配置对于Spring的IOC要实现的功能都是一样的，只是配置的形式不一样。还用如下的项目：

![1722479402676](./assets/1722479402676.png)



上面的bean.xml中一个空的配置文件，想让该文件支持注解，需要添加新的约束：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">


</beans>

```





## 15，@Component

- 作用：用于创建对象，放入Spring容器，相当于 bean 标签

  ```xml
  <bean id="studentDao" class="com.malu.dao.StudentDaoImpl"></bean>
  ```

- 位置：类上方



要在配置文件中配置扫描的包，扫描到该注解才能生效：

![1722479778762](./assets/1722479778762.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.malu"></context:component-scan>

</beans>
```





演示：

![1722479819848](./assets/1722479819848.png)



注意：@Component 注解配置bean的默认id是首字母小写的类名。也可以手动设置bean的id值。

![1722479900267](./assets/1722479900267.png)





## 16，@Repository, @Service,@Controller

- 作用：这三个注解和@Component的作用一样，使用它们是为了区分该类属于什么层。
- 位置：
  - @Repository用于Dao层
  - @Service用于Service层
  - @Controller用于Controller层



演示：

![1722480024427](./assets/1722480024427.png)





## 17，@Scope

- 作用：指定bean的创建策略
- 位置：类上方
- 取值：singleton prototype request session globalsession



演示：

![1722480160143](./assets/1722480160143.png)



## 18，@Autowired



- 作用：从容器中查找符合属性类型的对象自动注入属性中。用于代替bean中的依赖注入配置。
- 位置：属性上方、setter方法上方、构造方法上方。



演示：

![1722480470711](./assets/1722480470711.png)



容器中没有对象类型的对象时会报错：

![1722480571822](./assets/1722480571822.png)



容器中有多个对象匹配类型时，会找beanId等于属性名的对象，找不到会报错。

![1722480855109](./assets/1722480855109.png)





## 19，@Qualifier



- 作用：在按照类型注入对象的基础上，再按照bean的id注入。
- 位置：属性上方
- 注意：@Qualifier必须和@Autowired一起使用。



演示：

![1722481060766](./assets/1722481060766.png)



## 20，@Value



- 作用：注入String类型和基本数据类型的属性值。
- 位置：属性上方



直接设置固定的属性值：

![1722481213980](./assets/1722481213980.png)





获取配置文件中的属性值，编写配置文件，db.properties，如下：

![1722481277471](./assets/1722481277471.png)

```properties
jdbc.username=root
jdbc.password=123456
```



spring核心配置文件扫描配置文件:

![1722481364901](./assets/1722481364901.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.malu"></context:component-scan>

    <context:property-placeholder location="db.properties"></context:property-placeholder>
</beans>
```



注入配置文件中的属性值：

![1722481438796](./assets/1722481438796.png)

```java
@Service
public class StudentService {

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Override
    public String toString() {
        return "StudentService{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```







## 21，@Configuration

此时基于注解的IOC配置已经完成，但是我们依然离不开Spring的xml配置文件。接下来我们脱离bean.xml，使用纯注解实现IOC。在真实开发中，我们一般还是会保留xml配置文件，很多情况下使用配置文件更加方便。



删除配置文件：

![1722481586908](./assets/1722481586908.png)



纯注解实现IOC需要一个Java类代替xml文件。这个Java类上方需要添加@Configuration，表示该类是一个配置类，作用是代替配置文件。

![1722481664316](./assets/1722481664316.png)





## 22，@ComponentScan



- 作用：指定spring在初始化容器时扫描的包。
- 位置：配置类上方



演示：

![1722481721098](./assets/1722481721098.png)





## 23，@PropertySource



- 作用：代替配置文件中的  context:property-placeholder 扫描配置文件
- 位置：配置类上方
- 注意：配置文件位置前要加关键字 classpath



演示：

![1722482152442](./assets/1722482152442.png)





## 24，@Bean



- 作用：将方法的返回值对象放入Spring容器中。如果想将第三方类的对象放入容器，可以使用@Bean
- 位置：配置类的方法上方。
- 属性：name：给bean对象设置id
- 注意：@Bean修饰的方法如果有参数，spring会根据参数类型从容器中查找可用对象。



举例：如果想将jdbc连接对象放入Spring容器，我们无法修改Connection源码添加@Component，此时就需要使用将@Bean该对象放入Spring容器，添加驱动：

![1722482368782](./assets/1722482368782.png)



```xml
    <dependencies>
        <!-- spring核心模块 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- junit -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <!-- mysql驱动 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.27</version>
        </dependency>
    </dependencies>
```



将Connection对象放入Spring容器:

![1722483303773](./assets/1722483303773.png)



```java
@Configuration
@ComponentScan("com.malu")
@PropertySource("classpath:db.properties")
public class SpringConfig {

    @Bean(name = "connection")
    public Connection getConnection(){
       try{
           Class.forName("com.mysql.cj.jdbc.Driver");
           return DriverManager.getConnection("jdbc:mysql:///mybatis","root","root");
       }catch (Exception exception){
           return  null;
       }
    }

}

```



测试：

![1722483326212](./assets/1722483326212.png)

![1722483424949](./assets/1722483424949.png)



## 25，@Import



- 作用：如果配置过多，会有多个配置类，该注解可以为主配置类导入其他配置类
- 位置：主配置类上方



演示，创建一个新的配置类：

![1722483589329](./assets/1722483589329.png)



需要在主配置类中，导入上面你创建的新的配置类：

![1722483608678](./assets/1722483608678.png)



## 26，Spring整合MyBatis

我们知道使用MyBatis时需要写大量创建SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession等对
象的代码，而Spring的作用是帮助我们创建和管理对象，所以我们可以使用Spring整合MyBatis，简化MyBatis开发。



创建maven项目，引入依赖。

![1722483813368](./assets/1722483813368.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.malu</groupId>
    <artifactId>spring_mybatis</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- mybatis -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.7</version>
        </dependency>
        <!-- 驱动 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.26</version>
        </dependency>
        <!-- spring -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.3.13</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>5.3.13</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- mybatis和Spring的整合包 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.6</version>
        </dependency>
        <!--  junit  -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
        <!--  spring整合junit  -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>5.3.13</version>
        </dependency>
        <!-- druid -->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.8</version>
        </dependency>
    </dependencies>

</project>
```



编写数据库配置文件db.properties

![1722483916091](./assets/1722483916091.png)

```properties
jdbc.driverClassName=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///student
jdbc.username=root
jdbc.password=root
```





创建MyBatis配置文件SqlMapConfig.xml，数据源、扫描接口都交由Spring管理，不需要在MyBatis配置文件中设置。

![1722484005876](./assets/1722484005876.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

</configuration>
```







创建Spring配置文件applicationContext.xml

![1722484606378](./assets/1722484606378.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context
         http://www.springframework.org/schema/context/spring-context.xsd">

    <!--  包扫描  -->
    <context:component-scan base-package="com.malu"></context:component-scan>

    <!--  读取配置文件  -->
    <context:property-placeholder location="classpath:db.properties"></context:property-placeholder>


    <!-- 创建数据库连接池对象 -->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" >
        <property name="driverClassName" value="com.mysql.jdbc.Driver" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
    </bean>


    <!-- 创建Spring封装过的SqlSessionFactory -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource"></property>
        <property name="configLocation" value="classpath:SqlMapConfig.xml"></property>
    </bean>

    <!-- 创建Spring封装过的SqlSession -->
    <bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
        <constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"></constructor-arg>
    </bean>

</beans>
```



准备数据库：

![1722485202122](./assets/1722485202122.png)

执行sql：

```sql
CREATE DATABASE `student`;
USE `student`;
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `sex` varchar(10) DEFAULT NULL,
  `address` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT
CHARSET=utf8;

insert into `student`(`id`,`name`,`sex`,`address`) values (1,"malu","男","北京"),(2,"wc","女","北京")
```



准备实体类：

![1722485276886](./assets/1722485276886.png)

```java
package com.malu.domain;

public class Student {
    private int id;
    private String name;
    private String sex;
    private String address;

    public Student() {
    }

    public Student(int id, String name, String sex, String address) {
        this.id = id;
        this.name = name;
        this.sex = sex;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```



编写持久层接口：

![1722485408621](./assets/1722485408621.png)

```java
package com.malu.dao;

import com.malu.domain.Student;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface StudentDao {
    // 查询所有学生
    @Select("select * from student")
    List<Student> findAll();

    // 添加学生
    @Insert("insert into student values(null,#{name},#{sex},#{address})")
    void add(Student student);
}
```



编写service类

![1722485672412](./assets/1722485672412.png)

```java
@Service
public class StudentService {

    @Autowired
    private SqlSessionTemplate sqlSession;

    public List<Student> findAllStudent(){
        StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
        return studentDao.findAll();
    }

}
```



后续代码先放一下。



## 27，Spring整合Junit

之前进行单元测试时都需要手动创建Spring容器，能否在测试时让Spring自动创建容器呢？第一不：引入Junit和Spring整合Junit依赖

![1722485785240](./assets/1722485785240.png)



在MyBatis配置文件注册接口：

![1722486127138](./assets/1722486127138.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <mappers>
        <mapper class="com.malu.dao.StudentDao"></mapper>
    </mappers>

</configuration>
```



注意连接数据库的url:

![1722486218611](./assets/1722486218611.png)



编写测试类：

![1722486239213](./assets/1722486239213.png)



```java
package com.malu.service;

import com.malu.domain.Student;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

// Junit使用Spring的方式运行代码，即自动创建Spring容器
@RunWith(SpringJUnit4ClassRunner.class)
// Spring容器创建时读取的配置文件或配置类
// 配置类写法 @ContextConfiguration(classes = 配置类.class)
@ContextConfiguration(locations = "classpath:applicationContext.xml")
public class StudentServiceTest {

    @Autowired
    private StudentService studentService;

    @Test
    public void testFindAllStudent(){
        List<Student> allStudent = studentService.findAllStudent();
        allStudent.forEach(student-> System.out.println(student));
    }
}
```





## 28，自动创建代理对象

Spring提供了MapperScannerConfigurer对象，该对象可以自动扫描包创建代理对象，并将代理对象放入容器中，此时不需要使用SqlSession手动创建代理对象。



创建MapperScannerConfigurer对象:





## 29，AOP简介
## 30，AOP相关术语
## 31，AOP入门
## 32，通知类型
## 33，切点表达式
## 34，多切面配置
## 35，注解配置AOP
## 36，原生Spring实现AOP
## 37，SchemaBased实现AOP

## 38，Spring事务
## 39，Spring事务管理方案
## 40，Spring事务管理器
## 41，事务控制API
## 42，事务传播行为
## 43，事务的隔离级别
## 44，注解配置声明式事务


