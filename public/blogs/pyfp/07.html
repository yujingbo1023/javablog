<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker精讲 | 码路全栈开发</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/javablog/public/favicon.ico">
    <meta name="description" content="快来玩java全栈呀">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/javablog/public/assets/css/0.styles.0bd56f36.css" as="style"><link rel="preload" href="/javablog/public/assets/js/app.cf5c5deb.js" as="script"><link rel="preload" href="/javablog/public/assets/js/65.c0920096.js" as="script"><link rel="preload" href="/javablog/public/assets/js/1.3c422ec2.js" as="script"><link rel="preload" href="/javablog/public/assets/js/25.5e62b066.js" as="script"><link rel="prefetch" href="/javablog/public/assets/js/10.4e197da4.js"><link rel="prefetch" href="/javablog/public/assets/js/100.c47beb5a.js"><link rel="prefetch" href="/javablog/public/assets/js/101.6734d6e4.js"><link rel="prefetch" href="/javablog/public/assets/js/102.1ca65f71.js"><link rel="prefetch" href="/javablog/public/assets/js/11.3a720c3a.js"><link rel="prefetch" href="/javablog/public/assets/js/12.4c3f567b.js"><link rel="prefetch" href="/javablog/public/assets/js/13.81f6a7d3.js"><link rel="prefetch" href="/javablog/public/assets/js/14.ee3f1fd8.js"><link rel="prefetch" href="/javablog/public/assets/js/15.05549d01.js"><link rel="prefetch" href="/javablog/public/assets/js/16.3b3970d0.js"><link rel="prefetch" href="/javablog/public/assets/js/17.db912b82.js"><link rel="prefetch" href="/javablog/public/assets/js/18.ff308c1c.js"><link rel="prefetch" href="/javablog/public/assets/js/19.23cda4d7.js"><link rel="prefetch" href="/javablog/public/assets/js/20.4e58e0fe.js"><link rel="prefetch" href="/javablog/public/assets/js/21.01aaf364.js"><link rel="prefetch" href="/javablog/public/assets/js/22.3fabe619.js"><link rel="prefetch" href="/javablog/public/assets/js/23.ac5b7c7a.js"><link rel="prefetch" href="/javablog/public/assets/js/24.47c53e47.js"><link rel="prefetch" href="/javablog/public/assets/js/26.0f4a9142.js"><link rel="prefetch" href="/javablog/public/assets/js/27.a8a87c3e.js"><link rel="prefetch" href="/javablog/public/assets/js/28.37543686.js"><link rel="prefetch" href="/javablog/public/assets/js/29.dc76aff3.js"><link rel="prefetch" href="/javablog/public/assets/js/3.d97e1a44.js"><link rel="prefetch" href="/javablog/public/assets/js/30.eab60f51.js"><link rel="prefetch" href="/javablog/public/assets/js/31.164b153c.js"><link rel="prefetch" href="/javablog/public/assets/js/32.e40627a5.js"><link rel="prefetch" href="/javablog/public/assets/js/33.82fa8cce.js"><link rel="prefetch" href="/javablog/public/assets/js/34.b9e29af9.js"><link rel="prefetch" href="/javablog/public/assets/js/35.7d75add7.js"><link rel="prefetch" href="/javablog/public/assets/js/36.f2eea9ed.js"><link rel="prefetch" href="/javablog/public/assets/js/37.08ffc6b1.js"><link rel="prefetch" href="/javablog/public/assets/js/38.f84979f9.js"><link rel="prefetch" href="/javablog/public/assets/js/39.3f1cc217.js"><link rel="prefetch" href="/javablog/public/assets/js/4.e270b2fc.js"><link rel="prefetch" href="/javablog/public/assets/js/40.f4001d92.js"><link rel="prefetch" href="/javablog/public/assets/js/41.18cac5ff.js"><link rel="prefetch" href="/javablog/public/assets/js/42.e964672a.js"><link rel="prefetch" href="/javablog/public/assets/js/43.36622f4c.js"><link rel="prefetch" href="/javablog/public/assets/js/44.829366c3.js"><link rel="prefetch" href="/javablog/public/assets/js/45.749e5bfe.js"><link rel="prefetch" href="/javablog/public/assets/js/46.5c23bf9c.js"><link rel="prefetch" href="/javablog/public/assets/js/47.b18031d1.js"><link rel="prefetch" href="/javablog/public/assets/js/48.fa85700d.js"><link rel="prefetch" href="/javablog/public/assets/js/49.81a106cf.js"><link rel="prefetch" href="/javablog/public/assets/js/5.5f51d139.js"><link rel="prefetch" href="/javablog/public/assets/js/50.a4f24c09.js"><link rel="prefetch" href="/javablog/public/assets/js/51.ee8a6320.js"><link rel="prefetch" href="/javablog/public/assets/js/52.0c55fbe7.js"><link rel="prefetch" href="/javablog/public/assets/js/53.719ad93d.js"><link rel="prefetch" href="/javablog/public/assets/js/54.95793fa6.js"><link rel="prefetch" href="/javablog/public/assets/js/55.0f95297f.js"><link rel="prefetch" href="/javablog/public/assets/js/56.34868f33.js"><link rel="prefetch" href="/javablog/public/assets/js/57.28fbdd1a.js"><link rel="prefetch" href="/javablog/public/assets/js/58.dd93eb4a.js"><link rel="prefetch" href="/javablog/public/assets/js/59.19dfe2cf.js"><link rel="prefetch" href="/javablog/public/assets/js/6.680d796f.js"><link rel="prefetch" href="/javablog/public/assets/js/60.3e83663a.js"><link rel="prefetch" href="/javablog/public/assets/js/61.8999c8fc.js"><link rel="prefetch" href="/javablog/public/assets/js/62.e80ef5ab.js"><link rel="prefetch" href="/javablog/public/assets/js/63.43045b77.js"><link rel="prefetch" href="/javablog/public/assets/js/64.57ebd836.js"><link rel="prefetch" href="/javablog/public/assets/js/66.03fe767d.js"><link rel="prefetch" href="/javablog/public/assets/js/67.6fc4e3dd.js"><link rel="prefetch" href="/javablog/public/assets/js/68.c856ce0d.js"><link rel="prefetch" href="/javablog/public/assets/js/69.c47ff313.js"><link rel="prefetch" href="/javablog/public/assets/js/7.c025c339.js"><link rel="prefetch" href="/javablog/public/assets/js/70.c9dc064e.js"><link rel="prefetch" href="/javablog/public/assets/js/71.e3791740.js"><link rel="prefetch" href="/javablog/public/assets/js/72.4d2c03ed.js"><link rel="prefetch" href="/javablog/public/assets/js/73.113233f8.js"><link rel="prefetch" href="/javablog/public/assets/js/74.af79b2b1.js"><link rel="prefetch" href="/javablog/public/assets/js/75.26f34ea2.js"><link rel="prefetch" href="/javablog/public/assets/js/76.a7a681f5.js"><link rel="prefetch" href="/javablog/public/assets/js/77.6709945f.js"><link rel="prefetch" href="/javablog/public/assets/js/78.1ed19b03.js"><link rel="prefetch" href="/javablog/public/assets/js/79.7a521c7f.js"><link rel="prefetch" href="/javablog/public/assets/js/8.e864b79e.js"><link rel="prefetch" href="/javablog/public/assets/js/80.c06fab49.js"><link rel="prefetch" href="/javablog/public/assets/js/81.e897a6f5.js"><link rel="prefetch" href="/javablog/public/assets/js/82.cb117e9d.js"><link rel="prefetch" href="/javablog/public/assets/js/83.af9798c1.js"><link rel="prefetch" href="/javablog/public/assets/js/84.8ba949e5.js"><link rel="prefetch" href="/javablog/public/assets/js/85.55e21c47.js"><link rel="prefetch" href="/javablog/public/assets/js/86.934fb8df.js"><link rel="prefetch" href="/javablog/public/assets/js/87.4838df64.js"><link rel="prefetch" href="/javablog/public/assets/js/88.d13db62e.js"><link rel="prefetch" href="/javablog/public/assets/js/89.4fe54e81.js"><link rel="prefetch" href="/javablog/public/assets/js/9.3c75e6a0.js"><link rel="prefetch" href="/javablog/public/assets/js/90.1b037fe7.js"><link rel="prefetch" href="/javablog/public/assets/js/91.2ac6d423.js"><link rel="prefetch" href="/javablog/public/assets/js/92.5f9edd0d.js"><link rel="prefetch" href="/javablog/public/assets/js/93.e0567eea.js"><link rel="prefetch" href="/javablog/public/assets/js/94.7638efb7.js"><link rel="prefetch" href="/javablog/public/assets/js/95.4125803c.js"><link rel="prefetch" href="/javablog/public/assets/js/96.a3a9562b.js"><link rel="prefetch" href="/javablog/public/assets/js/97.e4bf4a9e.js"><link rel="prefetch" href="/javablog/public/assets/js/98.b3186518.js"><link rel="prefetch" href="/javablog/public/assets/js/99.e4308715.js">
    <link rel="stylesheet" href="/javablog/public/assets/css/0.styles.0bd56f36.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>码路全栈开发</h3> <p class="description" data-v-59e6cb88>快来玩java全栈呀</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>码路</span>
          
        <span data-v-59e6cb88>2017 - </span>
        2024
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/javablog/public/" class="home-link router-link-active"><img src="/javablog/public/logo.png" alt="码路全栈开发" class="logo"> <span class="site-name">码路全栈开发</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/javablog/public/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      全栈开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javablog/public/categories/base/" class="nav-link"><i class="undefined"></i>
  base
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/data analysis/" class="nav-link"><i class="undefined"></i>
  data analysis
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/javase/" class="nav-link"><i class="undefined"></i>
  javase
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/每日一题/" class="nav-link"><i class="undefined"></i>
  每日一题
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/javaweb/" class="nav-link"><i class="undefined"></i>
  javaweb
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/python/" class="nav-link"><i class="undefined"></i>
  python
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/node/" class="nav-link"><i class="undefined"></i>
  node
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/springcloudalibaba/" class="nav-link"><i class="undefined"></i>
  springcloudalibaba
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/spider/" class="nav-link"><i class="undefined"></i>
  spider
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/ssm/" class="nav-link"><i class="undefined"></i>
  ssm
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/storage/" class="nav-link"><i class="undefined"></i>
  storage
</a></li></ul></div></div><div class="nav-item"><a href="/javablog/public/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/javablog/public/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Docs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javablog/public/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/javablog/public/avatar.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    码路
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>92</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>23</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/javablog/public/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      全栈开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javablog/public/categories/base/" class="nav-link"><i class="undefined"></i>
  base
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/data analysis/" class="nav-link"><i class="undefined"></i>
  data analysis
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/javase/" class="nav-link"><i class="undefined"></i>
  javase
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/每日一题/" class="nav-link"><i class="undefined"></i>
  每日一题
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/javaweb/" class="nav-link"><i class="undefined"></i>
  javaweb
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/python/" class="nav-link"><i class="undefined"></i>
  python
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/node/" class="nav-link"><i class="undefined"></i>
  node
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/springcloudalibaba/" class="nav-link"><i class="undefined"></i>
  springcloudalibaba
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/spider/" class="nav-link"><i class="undefined"></i>
  spider
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/ssm/" class="nav-link"><i class="undefined"></i>
  ssm
</a></li><li class="dropdown-item"><!----> <a href="/javablog/public/categories/storage/" class="nav-link"><i class="undefined"></i>
  storage
</a></li></ul></div></div><div class="nav-item"><a href="/javablog/public/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/javablog/public/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Docs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javablog/public/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Docker精讲</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>码路</span>
          
        <span data-v-59e6cb88>2017 - </span>
        2024
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Docker精讲</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>码路</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>12/15/2028</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>linux</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="一-docker介绍"><a href="#一-docker介绍" class="header-anchor">#</a> 一，Docker介绍</h2> <p><img src="/javablog/public/assets/img/1716352031684.7f8be353.png" alt="1716352031684"></p> <h3 id="_1-什么是docker"><a href="#_1-什么是docker" class="header-anchor">#</a> 1，什么是Docker</h3> <p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0 协议开源。</p> <p><img src="/javablog/public/assets/img/1716351978164.99e79394.png" alt="1716351978164"></p> <p>标志是一头鲸鱼携带着一堆容器。它正在向您发送这些信息的途中。Docker直译过来是码头工人，然而Docker给人的第一感觉是容器，容器技术英译为Linux Container， Container的直译有集装箱，容器两个意思。</p> <p><strong>集装箱技术</strong></p> <p>我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色，在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响于是乎，IT领域借鉴了这一理念，大家就在想，有没有可能大家 只需要关注程序本身?</p> <p>Docker是一个开源的应用容器引擎，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的Linux机器上，也可实现虚拟化。</p> <p><img src="/javablog/public/assets/img/1716352328550.61ff4e04.png" alt="1716352328550"></p> <p>总结：Docker其实就是可以打包程序和运行环境，把环境和程序一起发布的容器。</p> <h3 id="_2-为什么要使用docker"><a href="#_2-为什么要使用docker" class="header-anchor">#</a> 2，为什么要使用Docker</h3> <p>开发者需要能方便高效构建应用，并且任何时间任何地点都可以获取。传统项目部署：</p> <p><img src="/javablog/public/assets/img/1716352563058.b5251adc.png" alt="1716352563058"></p> <p>对开发和运维( DevOps)人员来说，可能最梦寐以求的就是一次性地创建或配置，可以在任意环境、任意时间让应用正常地运行。而Docker恰恰是可以实现这一终极目标的瑞士军刀。它的优势：</p> <ul><li>更快速的交付和部署</li> <li>更高效的资源利用</li> <li>更轻松的迁移和扩展</li> <li>更简单的更新管理</li></ul> <p>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势。</p> <p><img src="/javablog/public/assets/img/1716352627078.7d60d992.png" alt="1716352627078"></p> <h3 id="_3-虚拟化与docker"><a href="#_3-虚拟化与docker" class="header-anchor">#</a> 3，虚拟化与Docker</h3> <p>虚拟化分类：</p> <ul><li><p>完全虚拟化</p></li> <li><p>硬件辅助虚拟化</p></li> <li><p>部分虚拟化</p></li> <li><p>超虚拟机化</p></li> <li><p>操作系统虚拟化</p></li></ul> <p><img src="/javablog/public/assets/img/1716352733936.09628017.png" alt="1716352733936"></p> <p>虚拟化技术是一个通用的概念,在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化或通常说的服务器虚拟化。简单的说，「虚拟化」，顾名思义，就是「虚拟」的，是「假」的，是观念上、逻辑上的划分。 举个例子：假设你现在手头上有一套房子，并且你要把它给租出去，租金的市场价是2000元/月。那么有没有办法把它租得更贵，获得6000元的租金呢？你想到了两个办法：</p> <ul><li>找一个不差钱的傻X租户，让他每月交6000元。</li> <li>把房子租给4个单身狗，租金为1500元/人/月</li></ul> <p><img src="/javablog/public/assets/img/1716352896204.96a60839.png" alt="1716352896204"></p> <p>什么是物理机：</p> <p><img src="/javablog/public/assets/img/1716352946838.22a1fa68.png" alt="1716352946838"></p> <p>什么是虚拟机：</p> <p><img src="/javablog/public/assets/img/1716352993277.d92d3bd6.png" alt="1716352993277"></p> <p>什么是Docker：</p> <p><img src="/javablog/public/assets/img/1716353067968.980ac5ae.png" alt="1716353067968"></p> <h3 id="_4-docker的核心概念"><a href="#_4-docker的核心概念" class="header-anchor">#</a> 4，Docker的核心概念</h3> <p><img src="/javablog/public/assets/img/1716353229476.8a6f7006.png" alt="1716353229476"></p> <p>Docker技术的三大核心概念，分别是：</p> <ul><li>镜像（Image）</li> <li>容器 (Container)</li> <li>仓库 (Repository)</li></ul> <p><strong>镜像：</strong></p> <p>Docker 镜像 (Image) 类似于虚拟机镜像，可以将它理解为个面向Docker引擎的模板，包含了文件系统。</p> <p><img src="/javablog/public/assets/img/1716353355295.740748f3.png" alt="1716353355295"></p> <p>镜像从何而来：</p> <ul><li>从Docker Hub下载    maven-&gt; 中央仓库</li> <li>通过Docker file自己创建出来</li></ul> <p><strong>容器：</strong></p> <p>Docker容器(Container)类似于一个轻量级的沙箱,Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。</p> <p>容器和镜像一样，也是若干层的叠加，唯一区别是所有只读层的最上面一层，是一层可读可写层，可以记住这个简单的公式：容器 = 容器镜像 + 可读可写层。</p> <p><strong>仓库：</strong></p> <p>Docker仓库(Repository)类似于代码仓库，是Docker集中存放镜像文件的场所。目前，最大的公开仓库是Docker Hub，存放了数量庞 大的镜像供用户下载。国内的公开仓库包括Docker Pool等，可以提供稳定的国内访问。</p> <p><img src="/javablog/public/assets/img/1716353869910.5822360b.png" alt="1716353869910"></p> <p>Docker利用仓库管理镜像的设计理念与Maven非常相似。</p> <p>咱们再来理解docker的两句口号就更好理解了：</p> <ul><li>Build, Ship and Run (搭建，发送，运行)</li> <li>Build once，Run anywhere (搭建一次，运行到任何地方)</li></ul> <h3 id="_5-docker安装"><a href="#_5-docker安装" class="header-anchor">#</a> 5，Docker安装</h3> <p><strong>系统环境</strong></p> <p><img src="/javablog/public/assets/img/1716353982222.8d6e4641.png" alt="1716353982222"></p> <p><img src="/javablog/public/assets/img/1716354268644.57ea0aee.png" alt="1716354268644"></p> <p>关闭防火墙：</p> <p><img src="/javablog/public/assets/img/1716354419910.c5a04864.png" alt="1716354419910"></p> <p>关闭selinux：</p> <p><img src="/javablog/public/assets/img/1716354505083.600c00e5.png" alt="1716354505083"></p> <p><img src="/javablog/public/assets/img/1716354491099.a68f19fd.png" alt="1716354491099"></p> <p>安装docker引擎：</p> <p><img src="/javablog/public/assets/img/1716356095472.337f27d9.png" alt="1716356095472"></p> <p>启动docker：</p> <p><img src="/javablog/public/assets/img/1716354793768.a2c108bb.png" alt="1716354793768"></p> <p>设置docker自启动：</p> <p><img src="/javablog/public/assets/img/1716354827413.643283ce.png" alt="1716354827413"></p> <p>测试docker是否安装成功：</p> <p><img src="/javablog/public/assets/img/1716356280033.5b9d3c02.png" alt="1716356280033"></p> <h2 id="二-docker命令"><a href="#二-docker命令" class="header-anchor">#</a> 二，Docker命令</h2> <h3 id="_1-镜像命令"><a href="#_1-镜像命令" class="header-anchor">#</a> 1，镜像命令</h3> <p>Docker运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker会尝试先从默认镜像仓库下载（默认使用Docker Hub 公共注册服务器中的仓库)，用户也可以通过配置，使用自定义的镜像仓库。总之：镜像是Docker运行容器的前提。</p> <p>镜像下载：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker pull 镜像名字:[tag]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：如果不指定tag，则下载Docker Hub公共注册服务器中仓库的最新版本。</p> <p>操作：</p> <p><img src="/javablog/public/assets/img/1716357744211.3fbb1aa7.png" alt="1716357744211"></p> <p>查看镜像：列出本地主机上已有的镜像。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker images
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>操作：</p> <p><img src="/javablog/public/assets/img/1716357820265.673521a0.png" alt="1716357820265"></p> <p>参数：</p> <ul><li>参数1：来自哪个仓库</li> <li>参数2：镜像的标签信息</li> <li>参数3：镜像的ID（唯一），镜像的ID信息十分重要，它唯一标识了镜像。</li> <li>参数4：创建时间</li> <li>参数5：镜像大小</li></ul> <p>镜像搜索：搜索远端仓库中共享的镜像,默认搜索Docker Hub官方仓库中的镜像。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker search [镜像名字]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>操作：</p> <p><img src="/javablog/public/assets/img/1716358009036.8f730b6e.png" alt="1716358009036"></p> <p>参数：</p> <ul><li>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、星级（表示该镜像的受欢迎程度），是否官方创建、是否自动创建等</li></ul> <p>删除镜像：使用镜像的标签删除镜像</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker rmi 源名字
docker rmi image id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>操作：</p> <p><img src="/javablog/public/assets/img/1716358200031.20cb7ebb.png" alt="1716358200031"></p> <h3 id="_2-容器命令"><a href="#_2-容器命令" class="header-anchor">#</a> 2，容器命令</h3> <p>当我们有了镜像，才可以创建容器, 创建一个centos容器来学习。Docker的容器十分轻量级，用户可以随时创建或者删除容器。语法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker create -it 镜像名字
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：使用docker create命令新建的容器处于停止状态，可以使用docker start命令来启动它。</p> <p>操作：</p> <p><img src="/javablog/public/assets/img/1716358585760.3a987ef1.png" alt="1716358585760"></p> <p>启动容器：</p> <p><img src="/javablog/public/assets/img/1716358834876.c684059c.png" alt="1716358834876"></p> <p>列出容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker ps
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参数：</p> <ul><li>-a: 显示未启动容器</li> <li>-q：返回容器id号</li></ul> <p>操作：</p> <p><img src="/javablog/public/assets/img/1716358689959.7a8d2e0f.png" alt="1716358689959"></p> <p><img src="/javablog/public/assets/img/1716358738476.e43b8bd5.png" alt="1716358738476"></p> <p>新建并启动容器：启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（ stopped)的容器重新启动。所需要的命令主要为docker run，等价于先执行docker create命令,再执行docker  start命令。语法格式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run 镜像名字 /bin/echo 'hello world'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>操作：</p> <p><img src="/javablog/public/assets/img/1716358963305.eae38dd4.png" alt="1716358963305"></p> <p><img src="/javablog/public/assets/img/1716359063907.d431b4f6.png" alt="1716359063907"></p> <p><img src="/javablog/public/assets/img/1716359114913.72020dd2.png" alt="1716359114913"></p> <p>参数：</p> <ul><li>-t选项让Docker 分配一个伪终端（pseudo-tty)并绑定到容器的标准输入上</li> <li>-i则让容器的标准输入保持打开。</li> <li>exit命令退出。</li></ul> <p>Docker在后台运行的标准操作包括：</p> <ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载。</li> <li>利用镜像创建并启动一个容器。</li> <li>分配一个文件系统,并在只读的镜像层外面挂载一层可读写层。</li> <li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li> <li>从地址池配置一个IP地址给容器。</li> <li>执行用户指定的应用程序。</li> <li>执行完毕后容器被终止。</li></ul> <p>守护态运行：更多的时候，需要让Docker容器在后台以守护态（Daemonized)形式运行。用户可以通过添加-d参数来实现。不以守护态运行：</p> <p><img src="/javablog/public/assets/img/1716359251105.3ec5c859.png" alt="1716359251105"></p> <p>守护态运行：</p> <p><img src="/javablog/public/assets/img/1716359381083.6b523216.png" alt="1716359381083"></p> <p>容器启动后会返回一个唯一的ID，也可以通过docker ps命令来查看容器信息:</p> <p><img src="/javablog/public/assets/img/1716359421396.f6b1caef.png" alt="1716359421396"></p> <p>获取容器输出信息</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker logs 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>操作：</p> <p><img src="/javablog/public/assets/img/1716359472827.99d956d4.png" alt="1716359472827"></p> <p>终止容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker stop 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716359578635.ab4c69d2.png" alt="1716359578635"></p> <p>处于终止状态的容器，可以通过docker start命令来重新启动:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker start 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716359624193.8b8ea1cc.png" alt="1716359624193"></p> <p>此外，docker restart命令会将一个运行态的容器终止，然后再重新启动</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker restart 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716359661641.e56fa486.png" alt="1716359661641"></p> <p>进入容器：</p> <p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息。某些时候如果需要进入容器进行操作，有多种方法，包括使用docker attach命令、docker exec命令,以及nsenter工具等。</p> <p><img src="/javablog/public/assets/img/1716359761402.1c4c061c.png" alt="1716359761402"></p> <p>使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p> <p>Docke自1.3版本起，提供了一个更加方便的工具exec，可以直接在容器内运行命令。例如进入到刚创建的容器中,并启动一个bash:</p> <p><img src="/javablog/public/assets/img/1716359840913.f42df70a.png" alt="1716359840913"></p> <p>删除容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker rm 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716359952477.8b8c8394.png" alt="1716359952477"></p> <p>参数：</p> <ul><li>-f, --force=false强行终止并删除一个运行中的容器。</li> <li>-l, --link=false删除容器的连接,但保留容器。</li> <li>-V,--volumes=false删除容器挂载的数据卷。</li></ul> <p>退出：如果docker容器在启动的时候没有加 -d 参数</p> <ul><li>exit # 会直接停止同期并退出</li> <li>Ctrt + p + q # 容器不停止 并退出</li></ul> <h3 id="_3-其它命令"><a href="#_3-其它命令" class="header-anchor">#</a> 3，其它命令</h3> <p>查看日志</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker logs 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参数：</p> <ul><li>-f, --follow 跟踪实时日志</li> <li>--since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）</li> <li>--tail string 从日志末尾显示多少行日志， 默认是all</li> <li>-t, --timestamps 显示时间戳</li> <li>--until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）</li></ul> <p><img src="/javablog/public/assets/img/1716360504325.d977c790.png" alt="1716360504325"></p> <p>查看容器里面的进程</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> docker top 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716360681651.8659abfb.png" alt="1716360681651"></p> <p>从容器拷贝文件到主机上：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker cp 容器id：容器内路径   目录路径
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716360892908.51b092ff.png" alt="1716360892908"></p> <h2 id="三-docker实践"><a href="#三-docker实践" class="header-anchor">#</a> 三，Docker实践</h2> <h3 id="_1-安装jdk"><a href="#_1-安装jdk" class="header-anchor">#</a> 1，安装JDK</h3> <p>查看JDK镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker search openjdk:11
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716364123585.d3fb655e.png" alt="1716364123585"></p> <p>下载JDK镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker pull openjdk:11
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716364148565.897d97dc.png" alt="1716364148565"></p> <p>运行JDK镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run openjdk:11 java -version
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716364516861.bd1fb10a.png" alt="1716364516861"></p> <h3 id="_2-安装tomcat"><a href="#_2-安装tomcat" class="header-anchor">#</a> 2，安装Tomcat</h3> <p>查看tomcat镜像</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker search docker.io/tomee
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716364788464.53ec7ba6.png" alt="1716364788464"></p> <p>下载tomcat镜像</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker pull docker.io/tomee
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716364809622.7e384c02.png" alt="1716364809622"></p> <p>启动tomcat容器</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -d --name mytomcat -p 9090:8080 docker.io/tomee
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716364862359.74f58b00.png" alt="1716364862359"></p> <p>参数：</p> <ul><li>-p 映射端口 宿主机端口号:容器内应用端口</li> <li>-P 随机端口</li></ul> <p>端口绑定：</p> <p><img src="/javablog/public/assets/img/1716364738724.4e89f8d4.png" alt="1716364738724"></p> <p>访问：</p> <p><img src="/javablog/public/assets/img/1716364949441.e6493bf6.png" alt="1716364949441"></p> <h3 id="_3-安装mysql"><a href="#_3-安装mysql" class="header-anchor">#</a> 3，安装Mysql</h3> <p>查看镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker search mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716365065924.c3a3c14a.png" alt="1716365065924"></p> <p>下载镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker pull mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716365088675.8fd05623.png" alt="1716365088675"></p> <p>启动镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run --name mysql -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参数：</p> <ul><li>-p 我们以后使用3307 端口来访问mysql 为了防止黑客攻击</li> <li>-e 配置环境变量</li> <li>MYSQL_ROOT_PASSWORD 设置容器内mysql root 密码</li></ul> <p><img src="/javablog/public/assets/img/1716365158919.5ef5c66c.png" alt="1716365158919"></p> <p>测试：</p> <p><img src="/javablog/public/assets/img/1716365260047.734caf1a.png" alt="1716365260047"></p> <h2 id="四-docker数据管理"><a href="#四-docker数据管理" class="header-anchor">#</a> 四，Docker数据管理</h2> <p><img src="/javablog/public/assets/img/1716366142697.9f0b1e38.png" alt="1716366142697"></p> <h3 id="_1-为什么使用数据卷"><a href="#_1-为什么使用数据卷" class="header-anchor">#</a> 1，为什么使用数据卷</h3> <p>什么是容器数据卷：Docker中的数据可以存储在类似于宿主机磁盘的介质中，在Docker中称为数据卷（Data Volume）。</p> <p>思考：</p> <ul><li><p>Docker容器删除后，在容器中产生的数据还在吗？</p> <p><img src="/javablog/public/assets/img/1716366334891.c2cd14f2.png" alt="1716366334891"></p></li> <li><p>Docker容器和外部机器可以直接交换文件吗？</p> <p><img src="/javablog/public/assets/img/1716366390740.352262f8.png" alt="1716366390740"></p></li> <li><p>容器之间能进行数据交互？</p> <p><img src="/javablog/public/assets/img/1716366435831.c10b2462.png" alt="1716366435831"></p></li></ul> <p>数据卷的概念：</p> <ul><li>数据卷是宿主机中的一个目录或文件。</li> <li>当容器目录和数据卷目录绑定后，对方修改会立即同步。</li> <li>一个数据卷可以同时被多个容器同时挂载。</li> <li>一个容器也可以被挂载多个数据卷。</li></ul> <p><img src="/javablog/public/assets/img/1716366571223.b0bb9d3f.png" alt="1716366571223"></p> <p>数据卷的作用：</p> <ul><li>容器数据持久化。</li> <li>外部机器和容器间接通信。</li> <li>容器之间数据交换。</li></ul> <p>总结：数据卷技术就是为了实现数据的持久化和同步操作，容器间也是数据共享。</p> <h3 id="_2-配置数据卷"><a href="#_2-配置数据卷" class="header-anchor">#</a> 2，配置数据卷</h3> <p>命令：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -v 宿主机目录(文件):容器内目录(文件) webapps
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：</p> <ul><li>目录必须是绝对路径</li> <li>如果目录不存在则会自动创建</li> <li>可以挂载多个数据卷</li></ul> <p>查看容器，停止容器：</p> <p><img src="/javablog/public/assets/img/1716366776787.2403449b.png" alt="1716366776787"></p> <p>查看没有启动的镜像：</p> <p><img src="/javablog/public/assets/img/1716366922249.e13a3646.png" alt="1716366922249"></p> <p>启动tomcat:</p> <p><img src="/javablog/public/assets/img/1716367044667.a2149b36.png" alt="1716367044667"></p> <p>停止容器：</p> <p><img src="/javablog/public/assets/img/1716367094903.21604baa.png" alt="1716367094903"></p> <p>操作：给Tomcat服务器挂载/opt/webapps路径。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -d --name mytomcat -p 8080:8080 -v /opt/webapps:/usr/local/tomee/webapps tomcat
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716367604448.873499d2.png" alt="1716367604448"></p> <p><img src="/javablog/public/assets/img/1716367687116.ba7a2852.png" alt="1716367687116"></p> <p>重启，访问：</p> <p><img src="/javablog/public/assets/img/1716367750215.a7a2a875.png" alt="1716367750215"></p> <h3 id="_3-数据卷容器"><a href="#_3-数据卷容器" class="header-anchor">#</a> 3，数据卷容器</h3> <p>Volume的基本使用：</p> <ul><li>create # 创建数据卷</li> <li>inspect #查看数据卷元数据</li> <li>ls #查看数据卷列表</li> <li>prune #删除所有未使用的卷</li> <li>rm #删除数据卷</li></ul> <p>查看所有的容器卷：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker volume ls
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716367849441.c04d041b.png" alt="1716367849441"></p> <p>创建一个自定义容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker volume create test_web
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716367936476.f39fe116.png" alt="1716367936476"></p> <p>查看指定容器卷详情信息：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker volume inspect test_web
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716368011548.3ef19693.png" alt="1716368011548"></p> <p>使用指定卷容器，有了自定义容器卷，我们可以创建一个使用这个数据卷的容器，这里我们以tomcat为例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -d -it --name=ylstomcat -p 8080:8080 -v test_web:/usr/local/tomee/webapps tomee
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716368230183.e3c0fada.png" alt="1716368230183"></p> <p>注意：</p> <ul><li>-v代表挂载数据卷，这里使用自定数据卷test_web，并且将数据卷挂载到/usr/local/tomcat/webapps 。如果没有通过-v指定，那么Docker会默认帮我们创建匿名数据卷进行映射和挂载。</li></ul> <h3 id="_4-mysql数据卷挂载"><a href="#_4-mysql数据卷挂载" class="header-anchor">#</a> 4，Mysql数据卷挂载</h3> <p>搜索镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker search mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>下载镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker pull mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>前面已经下载过镜像了：</p> <p><img src="/javablog/public/assets/img/1716371399950.6139fe18.png" alt="1716371399950"></p> <p>运行镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -d -p 3306:3306 \
-v /opt/mysql/conf:/etc/mysql/conf.d \
-v /opt/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=root --name my-mysql mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/javablog/public/assets/img/1716371442316.1c02da68.png" alt="1716371442316"></p> <p><img src="/javablog/public/assets/img/1716371467274.7cb128d8.png" alt="1716371467274"></p> <p>进入mysql容器，如下：</p> <p><img src="/javablog/public/assets/img/1716380282980.b9ce718b.png" alt="1716380282980"></p> <p>创建一个数据库，在一个数据为中创建表，然后在表中插入一条数据，如下：</p> <p><img src="/javablog/public/assets/img/1716380424999.aa4b93a4.png" alt="1716380424999"></p> <p>此时，我们把数据库这个容器停掉，然后删除掉，如下：</p> <p><img src="/javablog/public/assets/img/1716380511670.9367166e.png" alt="1716380511670"></p> <p>然后重新创建容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -d -p 3306:3306 \
-v /opt/mysql/conf:/etc/mysql/conf.d \
-v /opt/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=root --name my-mysql mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/javablog/public/assets/img/1716380672294.24ecf696.png" alt="1716380672294"></p> <p><img src="/javablog/public/assets/img/1716380683961.019876d2.png" alt="1716380683961"></p> <h2 id="五-dockerfile"><a href="#五-dockerfile" class="header-anchor">#</a> 五，Dockerfile</h2> <h3 id="_1-什么是dockerfile"><a href="#_1-什么是dockerfile" class="header-anchor">#</a> 1，什么是Dockerfile</h3> <p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。
<img src="/javablog/public/assets/img/1716383478792.f2197d37.png" alt="1716383478792"></p> <p>Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。一般而言，Dockerfile分为四部分:基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。 如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>## Dockerfile文件格式  
# 1、第一行必须指定 基础镜像信息
FROM openjdk:11
# 2、维护者信息
MAINTAINER ityls ityls@163.com
# 3、镜像操作指令
RUN echo &quot;wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.55/bin/apache-tomcat-9.0.55.tar.gz&quot;
run tar -zxvf apache-tomcat-9.0.55.tar.gz -C /usr/local
# 4、容器启动执行指令
CMD /usr/local/tomcat/bin/catalina.sh
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>说明：</p> <ul><li>一开始必须要指明所基于的镜像名称, 关键字是FROM, 这是必须的.</li> <li>接下来是维护者信息关键字是MAINTAINER, 非必须, 但良好的习惯有利于后期的职责明确</li> <li>后面是镜像操作指令, 如RUN等, 每执行一条RUN命令,镜像添加新的一层</li> <li>最后是CMD指令,来指明运行容器时的操作命令</li></ul> <h3 id="_2-构建镜像"><a href="#_2-构建镜像" class="header-anchor">#</a> 2，构建镜像</h3> <p><img src="/javablog/public/assets/img/1716383681698.c88a5924.png" alt="1716383681698"></p> <p>在一个空白的文本文件, 命名为Dockerfile</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vim Dockerfile
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Dockerfile文件内容:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#基础镜像
FROM centos
#维护者
MAINTAINER baizhan&lt;baizhan@163.com&gt;
#启动容器运行命令
CMD echo &quot;hello Dockerfile&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="/javablog/public/assets/img/1716384077031.e8ae957f.png" alt="1716384077031"></p> <p>构建镜像</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker build -t 镜像名字:版本 .
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：. 代表Dockerfile文件在当前路径</p> <p><img src="/javablog/public/assets/img/1716384169956.73ef23ec.png" alt="1716384169956"></p> <p>大家可以再操作如下的Dockerfile：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM java:8
MAINTAINER WCC
CMD java -version
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-常见的13种指令"><a href="#_3-常见的13种指令" class="header-anchor">#</a> 3，常见的13种指令</h3> <p><img src="/javablog/public/assets/img/1716384458902.a0c2427a.png" alt="1716384458902"></p> <h4 id="_1-from"><a href="#_1-from" class="header-anchor">#</a> 1）FROM</h4> <p>FROM：指定基础镜像，必须为第一个命令。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM &lt;image&gt;　　
FROM &lt;image&gt;:&lt;tag&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意：tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</p> <h4 id="_2-maintainer"><a href="#_2-maintainer" class="header-anchor">#</a> 2）MAINTAINER</h4> <p>MAINTAINER：维护者信息</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>MAINTAINER &lt;name&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_3-workdir"><a href="#_3-workdir" class="header-anchor">#</a> 3）WORKDIR</h4> <p>WORKDIR：工作目录，类似于cd命令</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>WORKDIR /usr/workdir
WORKDIR /a (这时工作目录为/a)
WORKDIR b (这时工作目录为/a/b)
WORKDIR c (这时工作目录为/a/b/c)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>再比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>WORKDIR /OPT
RUN mkdir docker
WORKDIR /usr/local
RUN echo &quot;test&quot; &gt; a.info
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意：通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</p> <h4 id="_4-run"><a href="#_4-run" class="header-anchor">#</a> 4）RUN</h4> <p>RUN：构建镜像时执行的命令</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># 1. shell执行
格式 RUN &lt;command&gt;
# 2. exec执行
格式 RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>WORKDIR /OPT
RUN mkdir docker
WORKDIR /usr/local
RUN echo &quot;test&quot; &gt; a.info
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意：RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</p> <h4 id="_5-add"><a href="#_5-add" class="header-anchor">#</a> 5）ADD</h4> <p>ADD:将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD &lt;src&gt;... &lt;dest&gt;
ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径示例：    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ADD hom* /mydir/  # 添加所有以&quot;hom&quot;开头的文件
ADD hom?.txt /mydir/  # ? 替代一个单字符,例如：&quot;home.txt&quot;
ADD test relativeDir # 添加 &quot;test&quot; 到 WORKDIR/relativeDir/
ADD test /absoluteDir/ # 添加 &quot;test&quot; 到 /absoluteDir/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_6-copy"><a href="#_6-copy" class="header-anchor">#</a> 6）COPY</h4> <p>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY &lt;源路径&gt; &lt;目标路径&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>COPY ./start.sh /start.sh
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_7-cmd"><a href="#_7-cmd" class="header-anchor">#</a> 7）CMD</h4> <p>CMD：构建容器后调用，也就是在容器启动时才进行调用。指定这个容器启动的时候要运行的命令只有最后一个会生效可被替换。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>CMD指令与RUN指令相似，也具有两种格式：
1. shell格式：CMD &lt;命令&gt;
2. exec格式： CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;, …]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>CMD echo &quot;This is a test.&quot; | wc -
CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意：CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</p> <p>实操操作：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#基础镜像
FROM openjdk:11
#维护者
MAINTAINER ityls&lt;123@qq.com&gt;
#工作目录 切换目录
WORKDIR /opt
#构建镜像时执行的命令
RUN mkdir abc
#将本地文件添加到容器内
ADD ./webapps /opt
#构建成功之后执行的命令
CMD echo &quot;This is a test.&quot; | wc -
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><img src="/javablog/public/assets/img/1716385039501.82de38f9.png" alt="1716385039501"></p> <p><img src="/javablog/public/assets/img/1716385180316.ba60537f.png" alt="1716385180316"></p> <h4 id="_8-entrypoint"><a href="#_8-entrypoint" class="header-anchor">#</a> 8）ENTRYPOINT</h4> <p>ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去&quot;application&quot;，只使用参数。指定容器启动的要运行的命令，可以追加命令</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
ENTRYPOINT command param1 param2 (shell内部命令)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设 置，而只执行最后的ENTRYPOINT指令。</p> <h4 id="_9-env"><a href="#_9-env" class="header-anchor">#</a> 9）ENV</h4> <p>ENV: 这个指令非常简单，就是用于设置环境变量而已，无论是接下来的指令，还是在容器中运行的程序，都可以使用这里定义的环境变量。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV &lt;key&gt;=&lt;value&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ENV JAVA_HOME=/usr/local/jdk1.7.0_79
ENV PATH=$JAVA_HOME/bin:$PATH
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="_10-expose"><a href="#_10-expose" class="header-anchor">#</a> 10）EXPOSE</h4> <p>EXPOSE: 指定于外界交互的端口</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>EXPOSE 80
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参 数来发布EXPOSE导出的所有端口。</p> <h4 id="_11-volume"><a href="#_11-volume" class="header-anchor">#</a> 11）VOLUME</h4> <p>VOLUME：用于指定持久化目录</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>VOLUME [&quot;/path/to/dir&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>VOLUME [&quot;/data&quot;]
VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意：一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p> <ul><li>卷可以容器间共享和重用</li> <li>容器并不一定要和其它容器共享卷</li> <li>修改卷后会立即生效</li> <li>对卷的修改不会对镜像产生影响</li> <li>卷会一直存在，直到没有任何容器在使用它</li></ul> <h4 id="_12-user"><a href="#_12-user" class="header-anchor">#</a> 12）USER</h4> <p>USER：指令用于将会用以什么样的用户去运行</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>USER user
USER user:group
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意：使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、 ENTRYPOINT都将使用该用户。镜像构建完成后，通过 docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</p> <h4 id="_13-onbuild"><a href="#_13-onbuild" class="header-anchor">#</a> 13）ONBUILD</h4> <p>ONBUILD：帮助别人定制而准备的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ONBUILD [INSTRUCTION]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM centos
WORKDIR /data
ONBUILD RUN mkdir test
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-cmd和entrypoint的区别"><a href="#_4-cmd和entrypoint的区别" class="header-anchor">#</a> 4，CMD和ENTRYPOINT的区别</h3> <p>区别：</p> <ul><li>CMD #指定这个容器启动的时候要运行的命令，可被替换</li> <li>ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令</li></ul> <p>定义Dockerfile，如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#基础镜像
from centos
#启动容器运行命令
CMD [&quot;ls&quot; ,&quot;-a&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/javablog/public/assets/img/1716387313433.ad4b055a.png" alt="1716387313433"></p> <p>构建镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker build -t test:v3 .
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716387414823.d20beb25.png" alt="1716387414823"></p> <p>启动镜像：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run -it test:v3 ls -l
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716387499040.0baf5282.png" alt="1716387499040"></p> <p>把CMD换成ENTRYPOINT，如下：</p> <p><img src="/javablog/public/assets/img/1716387580023.5a06b16e.png" alt="1716387580023"></p> <p>生成镜像：</p> <p><img src="/javablog/public/assets/img/1716387615448.f889f9c1.png" alt="1716387615448"></p> <h3 id="_5-构建tomcat镜像"><a href="#_5-构建tomcat镜像" class="header-anchor">#</a> 5，构建Tomcat镜像</h3> <p>首先，尝试在DockerHub上搜索Tomcat相关镜像的个数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker search tomcat |wc -l
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>有26个,如果是个人开发或者测试，随意使用一个，若是生产环境使用，就不合适了。</p> <ul><li>项目需要的Tomcat版本可能不同。</li> <li>项目需要的Tomcat变量不一致。</li> <li>项目需要的JDK可能不一致。</li></ul> <p>Dockerfile文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#基础镜像
FROM openjdk:11
#维护者
MAINTAINER ityls&lt;ityls@163.com&gt;
#拷贝tomcat包
ADD ./apache-tomcat-9.0.50.tar.gz /usr/local
#设置工作目录
WORKDIR /usr/local
#设置tomcat环境变量
ENV TOMCAT_HOME=/usr/local/apache-tomcat-9.0.50
ENV PATH=$PATH:$TOMCAT_HOME/bin
#保留端口
EXPOSE 8080
#启动容器运行命令
CMD startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.50/bin/catalina.out
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><img src="/javablog/public/assets/img/1716388034648.33cbaa60.png" alt="1716388034648"></p> <p>构建镜像</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker build -t tomcat:1.0 .
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716388054038.a0629e83.png" alt="1716388054038"></p> <p>启动容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run --name tomcat -d -p 8080:8080 tomcat:1.0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716388123568.b7716f16.png" alt="1716388123568"></p> <p>访问：</p> <p><img src="/javablog/public/assets/img/1716388147030.499b1dc3.png" alt="1716388147030"></p> <h2 id="六-docker网络管理"><a href="#六-docker网络管理" class="header-anchor">#</a> 六，Docker网络管理</h2> <p><img src="/javablog/public/assets/img/1716443913477.19f51a99.png" alt="1716443913477"></p> <h3 id="_1-docker网络详解"><a href="#_1-docker网络详解" class="header-anchor">#</a> 1，Docker网络详解</h3> <p>每启动一个docker容器， docker就会给容器分配一个ip，只要安装docker就会有一个docker0 网卡。</p> <p>清空所有容器来测试：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker stop $(docker ps -aq)
docker rm $(docker ps -aq)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/javablog/public/assets/img/1716444638233.6d46c430.png" alt="1716444638233"></p> <p><img src="/javablog/public/assets/img/1716444707756.5d643290.png" alt="1716444707756"></p> <p>看一下主机的地址：</p> <p><img src="/javablog/public/assets/img/1716444760891.9c9e5a97.png" alt="1716444760891"></p> <p>evth-pair 就是一对的虚拟设备接口，它们都是成对出现，一段彼此连接。 正是因为这个特性，evth-parit桥梁。 连接各种各样网络设备。</p> <p><img src="/javablog/public/assets/img/1716444079452.12487ee9.png" alt="1716444079452"></p> <p>注意：</p> <p>docker 使用linux的桥接， 宿主机中时一个docker容器的网桥。 docker0 docker中所有网络接口都是虚拟的。 虚拟转发效率高只要容器删除 对应的网桥就没有了。</p> <p>创建三个容器：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker run --name mytomcat -d -p 8080:8080 tomcat:1.0
docker run --name mytomcat2 -d -p 8090:8080 tomcat:1.0
docker run --name mysql -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/javablog/public/assets/img/1716445368632.3c76b819.png" alt="1716445368632"></p> <p>进入两台tomcat容器，并查IP，如下：</p> <p><img src="/javablog/public/assets/img/1716445583176.db6414cb.png" alt="1716445583176"></p> <p><img src="/javablog/public/assets/img/1716445670918.060ae472.png" alt="1716445670918"></p> <p>两个容器是可以ping通的：</p> <p><img src="/javablog/public/assets/img/1716445828902.b7450b7a.png" alt="1716445828902"></p> <h3 id="_2-docker容器互联"><a href="#_2-docker容器互联" class="header-anchor">#</a> 2，Docker容器互联</h3> <p><img src="/javablog/public/assets/img/1716444955253.b2de7944.png" alt="1716444955253"></p> <p>思考一个场景,我们编写了一个WEB服务，database url=ip:，项目不重启,数据库ip换掉了, 我们希望可以处理这个问题，可以名字来进行访问容器?</p> <p>语法格式：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>--link &lt;name or id&gt;:alias
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参数：</p> <ul><li>name和id是源容器的name和id，alias是源容器在link下的别名。</li></ul> <p>查看当前容器：</p> <p><img src="/javablog/public/assets/img/1716446180388.d3241c38.png" alt="1716446180388"></p> <p><img src="/javablog/public/assets/img/1716446292976.a3d047d4.png" alt="1716446292976"></p> <p>ping mysql：</p> <p><img src="/javablog/public/assets/img/1716446357565.c2351fb1.png" alt="1716446357565"></p> <h2 id="七-docker公有云"><a href="#七-docker公有云" class="header-anchor">#</a> 七，Docker公有云</h2> <h3 id="_1-docker为什么推送镜像到远程仓库"><a href="#_1-docker为什么推送镜像到远程仓库" class="header-anchor">#</a> 1，Docker为什么推送镜像到远程仓库</h3> <p>如果我们想将这个镜像提供给别人使用时，我们可以将镜像推送到远程仓库，然后别人从远程仓库中下载即可。</p> <p>Docker Hub是Docker社区分享Docker镜像的网站/存储库。地址：https://hub.docker.com/</p> <p><img src="/javablog/public/assets/img/1716446535682.80eb8052.png" alt="1716446535682"></p> <p>阿里云容器镜像服务（简称 ACR）是面向容器镜像、HelmChart 等符合 OCI 标准的云原生制品安全托管及高效分发平台。 ACR 支持全球同步加速、大规模/大镜像分发加速、多代码源构建加速等全链路提效，与容器服务 ACK 无缝集成，帮助企业降低交付复杂度，打造云原生应用一站式解决方案。</p> <p><img src="/javablog/public/assets/img/1716446658598.2d726c31.png" alt="1716446658598"></p> <p><img src="/javablog/public/assets/img/1716446637269.70be2279.png" alt="1716446637269"></p> <h3 id="_2-发布镜像到docker-hub"><a href="#_2-发布镜像到docker-hub" class="header-anchor">#</a> 2，发布镜像到Docker Hub</h3> <p>第一步：</p> <p><img src="/javablog/public/assets/img/1716446768709.53ca3eed.png" alt="1716446768709"></p> <p>第二步：</p> <p><img src="/javablog/public/assets/img/1716446822494.1599a489.png" alt="1716446822494"></p> <p>第三步：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker login --username=kalista  # 密码：xu1023yuabc
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716447196136.8f31df8d.png" alt="1716447196136"></p> <p>第四步：把容器提交到docker hub上</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker commit -m &quot;镜像描述&quot; -a &quot;作者&quot; 容器id/容器名字 远程库的名字:上传到docker hub上的名字
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716447571496.e0fa7ebb.png" alt="1716447571496"></p> <p>第五步：将镜像，容器，远程库进行标识</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker tag 镜像id 远程库的名字:上传到docker hub上的名字
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>第六步：将于远程库有标识关系的库提交</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker push 远程库的名字:上传到docker hub上的名字
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/javablog/public/assets/img/1716447680253.88d40847.png" alt="1716447680253"></p> <p>查看：</p> <p><img src="/javablog/public/assets/img/1716447833245.72880b53.png" alt="1716447833245"></p> <h3 id="_3-发布镜像到阿里云"><a href="#_3-发布镜像到阿里云" class="header-anchor">#</a> 3，发布镜像到阿里云</h3> <p>操作同上，大家可以自习实操一下。</p> <h2 id="八-docker核心技术"><a href="#八-docker核心技术" class="header-anchor">#</a> 八，Docker核心技术</h2> <h3 id="_1-基本架构"><a href="#_1-基本架构" class="header-anchor">#</a> 1，基本架构</h3> <p><img src="/javablog/public/assets/img/1716447993605.f600e78f.png" alt="1716447993605"></p> <p>Docker采用了标准的C/S架构,包括客户端和服务端两大部分。客户端和服务端既可以运行在一个机器上，也可通过socket或者RESTful API来进行容器通信。</p> <p>Docker daemon一般在宿主主机后台运行，作为服务端接受来自客户的请求,并处Docker基本架构理这些请求(创建、运行、分发容器)。在设计上，Docker daemon是一个非常松耦合的架构,通过专门的 Engine模块来分发管理各个来自客户端的任务。</p> <p>Docker客户端则为用户提供一系列可执行命令，用户用这些命令实现与Docker daemon的交互。</p> <h3 id="_2-联合文件"><a href="#_2-联合文件" class="header-anchor">#</a> 2，联合文件</h3> <p><img src="/javablog/public/assets/img/1716448235930.5fee9cfd.png" alt="1716448235930"></p> <p>联合文件系统(UnionFS）是一种轻量级的高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p> <p><strong>Dockerfile</strong></p> <p>Dockerfile用于描述镜像的生成规则。Dockerfile中的每一条命令，都在Docker镜像中以一个独立镜像层的形式存在。</p> <p><strong>Image</strong></p> <p>Image由Dockerfile生成，呈现层级结构，每层镜像包含：镜像文件以及镜像json元数据信息。</p> <p><strong>Container</strong></p> <p>Container是Image的动态运行结果，概括而言，就是在Docker镜像之上，运行进程。</p> <p><img src="/javablog/public/assets/img/1716448319972.e8ed1c3a.png" alt="1716448319972"></p> <p><strong>镜像分层的好处</strong></p> <ul><li>基本上每个软件都是基于某个镜像去运行的，因此一旦某个底层环境出了问题，就不需要去修改全部基于该镜像的软件的镜像，只需要修改底层环境的镜像。</li> <li>这个好处也是最大好处，就是可以共享资源，其他相同环境的软件镜像都共同去享用同一个环境镜像，而不需要每个软件镜像要去创建一个底层环境。</li> <li>可以复用,节省磁盘空间，相同的内容只需加载一份到内存。 修改dockerfile之后，再次构建速度快。</li></ul> <p><strong>优化前</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM centos:6.9
RUN rm -rf /etc/yum.repos.d/*  
RUN curl -o /etc/yum.repos.d/CentOS-Base.repo
RUN curl -o http://mirrors.aliyun.com/repo/Centos-6.repo
RUN curl -o /etc/yum.repos.d/epel.repo
RUN yum install nginx -y
WORKDIR /usr/share/nginx/html
ADD xiaoniao.tar.gz .
ADD init.sh /init.sh
EXPOSE 80
VOLUME /usr/share/nginx/html
CMD [&quot;/bin/bash&quot;,&quot;/init.sh&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>优化后</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>FROM centos:6.9
RUN rm -rf /etc/yum.repos.d/* &amp;&amp; \
 	curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo &amp;&amp; \
 	curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo &amp;&amp; \
 	yum install nginx -y
WORKDIR /usr/share/nginx/html
ADD xiaoniao.tar.gz .
ADD init.sh /init.sh
EXPOSE 80
VOLUME /usr/share/nginx/html
CMD [&quot;/bin/bash&quot;,&quot;/init.sh&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">5/23/2024, 3:26:05 PM</span></div></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#一-docker介绍" class="sidebar-link reco-side-一-docker介绍" data-v-b57cc07c>一，Docker介绍</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-什么是docker" class="sidebar-link reco-side-_1-什么是docker" data-v-b57cc07c>1，什么是Docker</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-为什么要使用docker" class="sidebar-link reco-side-_2-为什么要使用docker" data-v-b57cc07c>2，为什么要使用Docker</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_3-虚拟化与docker" class="sidebar-link reco-side-_3-虚拟化与docker" data-v-b57cc07c>3，虚拟化与Docker</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_4-docker的核心概念" class="sidebar-link reco-side-_4-docker的核心概念" data-v-b57cc07c>4，Docker的核心概念</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_5-docker安装" class="sidebar-link reco-side-_5-docker安装" data-v-b57cc07c>5，Docker安装</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#二-docker命令" class="sidebar-link reco-side-二-docker命令" data-v-b57cc07c>二，Docker命令</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-镜像命令" class="sidebar-link reco-side-_1-镜像命令" data-v-b57cc07c>1，镜像命令</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-容器命令" class="sidebar-link reco-side-_2-容器命令" data-v-b57cc07c>2，容器命令</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_3-其它命令" class="sidebar-link reco-side-_3-其它命令" data-v-b57cc07c>3，其它命令</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#三-docker实践" class="sidebar-link reco-side-三-docker实践" data-v-b57cc07c>三，Docker实践</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-安装jdk" class="sidebar-link reco-side-_1-安装jdk" data-v-b57cc07c>1，安装JDK</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-安装tomcat" class="sidebar-link reco-side-_2-安装tomcat" data-v-b57cc07c>2，安装Tomcat</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_3-安装mysql" class="sidebar-link reco-side-_3-安装mysql" data-v-b57cc07c>3，安装Mysql</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#四-docker数据管理" class="sidebar-link reco-side-四-docker数据管理" data-v-b57cc07c>四，Docker数据管理</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-为什么使用数据卷" class="sidebar-link reco-side-_1-为什么使用数据卷" data-v-b57cc07c>1，为什么使用数据卷</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-配置数据卷" class="sidebar-link reco-side-_2-配置数据卷" data-v-b57cc07c>2，配置数据卷</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_3-数据卷容器" class="sidebar-link reco-side-_3-数据卷容器" data-v-b57cc07c>3，数据卷容器</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_4-mysql数据卷挂载" class="sidebar-link reco-side-_4-mysql数据卷挂载" data-v-b57cc07c>4，Mysql数据卷挂载</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#五-dockerfile" class="sidebar-link reco-side-五-dockerfile" data-v-b57cc07c>五，Dockerfile</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-什么是dockerfile" class="sidebar-link reco-side-_1-什么是dockerfile" data-v-b57cc07c>1，什么是Dockerfile</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-构建镜像" class="sidebar-link reco-side-_2-构建镜像" data-v-b57cc07c>2，构建镜像</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_3-常见的13种指令" class="sidebar-link reco-side-_3-常见的13种指令" data-v-b57cc07c>3，常见的13种指令</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_4-cmd和entrypoint的区别" class="sidebar-link reco-side-_4-cmd和entrypoint的区别" data-v-b57cc07c>4，CMD和ENTRYPOINT的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_5-构建tomcat镜像" class="sidebar-link reco-side-_5-构建tomcat镜像" data-v-b57cc07c>5，构建Tomcat镜像</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#六-docker网络管理" class="sidebar-link reco-side-六-docker网络管理" data-v-b57cc07c>六，Docker网络管理</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-docker网络详解" class="sidebar-link reco-side-_1-docker网络详解" data-v-b57cc07c>1，Docker网络详解</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-docker容器互联" class="sidebar-link reco-side-_2-docker容器互联" data-v-b57cc07c>2，Docker容器互联</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#七-docker公有云" class="sidebar-link reco-side-七-docker公有云" data-v-b57cc07c>七，Docker公有云</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-docker为什么推送镜像到远程仓库" class="sidebar-link reco-side-_1-docker为什么推送镜像到远程仓库" data-v-b57cc07c>1，Docker为什么推送镜像到远程仓库</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-发布镜像到docker-hub" class="sidebar-link reco-side-_2-发布镜像到docker-hub" data-v-b57cc07c>2，发布镜像到Docker Hub</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_3-发布镜像到阿里云" class="sidebar-link reco-side-_3-发布镜像到阿里云" data-v-b57cc07c>3，发布镜像到阿里云</a></li><li class="level-2" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#八-docker核心技术" class="sidebar-link reco-side-八-docker核心技术" data-v-b57cc07c>八，Docker核心技术</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_1-基本架构" class="sidebar-link reco-side-_1-基本架构" data-v-b57cc07c>1，基本架构</a></li><li class="level-3" data-v-b57cc07c><a href="/javablog/public/blogs/pyfp/07.html#_2-联合文件" class="sidebar-link reco-side-_2-联合文件" data-v-b57cc07c>2，联合文件</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/javablog/public/assets/js/app.cf5c5deb.js" defer></script><script src="/javablog/public/assets/js/65.c0920096.js" defer></script><script src="/javablog/public/assets/js/1.3c422ec2.js" defer></script><script src="/javablog/public/assets/js/25.5e62b066.js" defer></script>
  </body>
</html>
